requires 2.0.10

%h{
#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-data-schema.h"
#include "stuffkeeper-data-tag.h"
#include "stuffkeeper-data-item-search.h"
%}

%ph{
/* Include gtk */
#include <gtk/gtk.h>
#include <gdk/gdkkeysyms.h>
#include <glib/gi18n.h>
#include <glade/glade.h>
#include "sexy-icon-entry.h"
#include <config.h>
#include "debug.h"
#include "misc.h"

/* Include the database */

#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-edit-schema.h"
#include "stuffkeeper-show-item.h"
#include "stuffkeeper-item-window.h"
#include "stuffkeeper-export-html.h"
#include "stuffkeeper-item-window.h"
#include "stuffkeeper-plugin-manager.h"
#include "stuffkeeper-plugin.h"

extern GList *interface_list;
%}

%ph{
#include "revision.h"
    const gchar *artists[] = {
        "Jakub Szypulka (http://cubestuff.wordpress.com )",
        "Tango Project (http://tango.freedesktop.org/ )",
    NULL};
    const gchar *authors[] = {
        "Martijn Koedam (qball) <Qball@Stuffkeeper.org>", 
        "\nTester:",
        "Greg Fitzgerald",
        "Rasi <rasi@stuffkeeper.org>",
    NULL};

    typedef enum _LPColumnType{
        LP_ID, 
        LP_TITLE,
        LP_SELECTED,
        LP_ITEM,
        LP_AMOUNT,
        LP_NUM_ROWS
    } LPColumnType;

    typedef enum _LPType {
        LP_TYPE_TAG,
        LP_TYPE_SCHEMA,
        LP_TYPE_SEARCH
    }LPType;
%}

class Stuffkeeper:Interface from G:Object 
{
    private GtkTreeModel        *model_tags         = {NULL};
    private GtkTreeModel        *model_items        = {NULL};
    private GtkTreeModel        *model_schemas      = {NULL};
    /* search items */
    private GtkTreeModel        *model_searches     = {NULL};
    private GtkTreeModel        *model_items_filter = {NULL};

    public GKeyFile            *config_file        = {NULL};

    /* Menu */
    private GtkWidget           *menu               = {NULL};
    private GtkWidget           *menu_item_add      = {NULL};
    /**
     * Treeview 1 & 2
     */
    private GladeXML            *xml;
    private GtkWidget           *win;
    private GtkWidget           *LeftPaneCB;
    private GtkWidget           *treeview1;
    private GtkWidget           *treeview2;
    private GtkCellRenderer     *treeview1_renderer = {NULL};
    private GtkCellRenderer     *renderer_toggle = {NULL};
    
    private GtkWidget           *LeftPane_edit ;
    private GtkWidget           *AddMenuButton ;
    private GtkWidget           *search_entry ;
    private GtkWidget           *hpaned1;
    private GtkWidget           *vpaned1;
    private GtkWidget           *item_label;
    private GtkWidget           *cb_search;

    private GtkWidget           *item_view_container;
    private GtkWidget           *show_item_pane_menu_item;

    private GtkWidget           *menuitem_item_add;

    private StuffkeeperDataBackend *skdbg = {NULL};
    private StuffkeeperPluginManager *spm = {NULL};
    /**
     * Signals 
     */
    /* schema */
    private gulong signal_schema_added = {0};
    private gulong signal_schema_changed = {0};
    private gulong signal_schema_removed = {0};
    /* tag */
    private gulong signal_tag_added = {0};
    private gulong signal_tag_changed = {0};
    private gulong signal_tag_removed = {0};
    /* item */
    private gulong signal_item_added = {0};
    private gulong signal_item_changed = {0};
    private gulong signal_item_removed = {0};

    /* search/filter */
    private gulong search_timeout = {0};
    private gulong signal_search_added = {0};
    private gulong signal_search_changed = {0};
    private gulong signal_search_removed = {0};
    /* backend */
    private gulong signal_backend_locked = {0};

    private int item_sort_column = {3};
    private int item_sort_order = {GTK_SORT_DESCENDING};
    
    private signal last NONE (POINTER)
    void item_added_here(self, Stuffkeeper:Data:Item *item (check null type)) 
    {
	GtkTreeIter iter;
	GtkTreePath *path = NULL;
	GtkListStore *store = GTK_LIST_STORE(self->_priv->model_items_filter);

        if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(store), &iter)) {
	    StuffkeeperDataItem *found_item = NULL;
	    debug_printf("Searching new item in tree\n");
	    do {
		gtk_tree_model_get(GTK_TREE_MODEL(store), &iter, 2, &found_item, -1);
		if(found_item == item) {
		    debug_printf("Found new item in tree\n");
		    path = gtk_tree_model_get_path(GTK_TREE_MODEL(store), &iter);
		    break;
		}
	    } while(gtk_tree_model_iter_next(GTK_TREE_MODEL(store), &iter));
	    if(path) {
		debug_printf("Moving cursor to new item\n");
		gtk_tree_view_set_cursor(GTK_TREE_VIEW(self->_priv->treeview2), path, NULL, FALSE);
		gtk_tree_path_free(path);
	    }
	}
    }

    /**
    * Changes in the GtkTreeModelFilter wrapper, updating the total item label.
     */
    private
    void
    filter_model_row_inserted(self, GtkTreePath *path, GtkTreeIter *iter, GtkTreeModel  *model)
    {
        int num_items = gtk_tree_model_iter_n_children(self->_priv->model_items_filter, NULL);
        gchar *data = g_strdup_printf("%i", num_items); 
        gtk_label_set_text(GTK_LABEL(self->_priv->item_label), data);
        g_free(data);
    }

    private
    void
    filter_model_row_deleted(self, GtkTreePath *path, GtkTreeModel *model)
    {
        int num_items = gtk_tree_model_iter_n_children(self->_priv->model_items_filter, NULL);
        gchar *data = g_strdup_printf("%i", num_items); 
        gtk_label_set_text(GTK_LABEL(self->_priv->item_label), data);
        g_free(data);
    }
    /**
     * Search added
     */
    private 
    void
    search_changed(self, const SearchField *field, StuffkeeperDataItemSearch *search)
    {
        if(!field)
        {
            GtkTreeIter iter;
            GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->model_searches);
            gint id = stuffkeeper_data_item_search_get_id(search);
            if(gtk_tree_model_get_iter_first(model, &iter))
            {
                do{
                    gint oid;
                    gtk_tree_model_get(model, &iter, 0, &oid, -1);
                    if(oid == id)
                    {
                        gchar *title = stuffkeeper_data_item_search_get_title(search);
                        gtk_list_store_set(GTK_LIST_STORE(model), &iter, 
                            LP_TITLE,title,
                            -1);
                        g_free(title);
                    }
                }while(gtk_tree_model_iter_next(model, &iter));
            }
        }
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
    }

    private
    void
    search_added(self, StuffkeeperDataItemSearch *search,  StuffkeeperDataBackend *skdb)
    {
        GtkTreeIter iter;
        gchar *title = stuffkeeper_data_item_search_get_title(search);

        gtk_list_store_insert_with_values(GTK_LIST_STORE(self->_priv->model_searches), &iter, -1,
                LP_ID, stuffkeeper_data_item_search_get_id(search),
                LP_TITLE, title,
                LP_ITEM, search,
                -1);
        g_free(title);
    }

    private
    void 
    search_removed(self, gint id, StuffkeeperDataBackend *skdb)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->model_searches);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, LP_ID, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
                    gtk_combo_box_set_active(GTK_COMBO_BOX(self->_priv->cb_search), 0);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }


    /**
     * Keep Schema's GtkListStore up2date
     */
    private
    void 
    schema_added(self, StuffkeeperDataSchema *schema,StuffkeeperDataBackend *skdb )
    {
        GtkTreeIter iter;
        gchar *title = stuffkeeper_data_schema_get_title(schema);
        gtk_list_store_insert_with_values(GTK_LIST_STORE(self->_priv->model_schemas), &iter, -1,
                    LP_ID, stuffkeeper_data_schema_get_id(schema),
                    LP_TITLE, title,
                    LP_ITEM, schema,
                    LP_AMOUNT, stuffkeeper_data_schema_num_items(schema),-1);


        g_free(title);

	self_update_all_item_add_menus(self);
    }
    private
    void 
    schema_changed(self, StuffkeeperDataSchema *schema, StuffkeeperDataBackend *skdb)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->model_schemas);
        gint id = stuffkeeper_data_schema_get_id(schema);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, LP_ID, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_schema_get_title(schema);
                    gtk_list_store_set(GTK_LIST_STORE(model), &iter, 
                        LP_TITLE,title, 
                        LP_AMOUNT, stuffkeeper_data_schema_num_items(schema),
                        -1);
                    g_free(title);
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }

	self_update_all_item_add_menus(self);
    }
    private
    void 
    schema_removed(self, gint id, StuffkeeperDataBackend *skdb)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->model_schemas);

        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, LP_ID, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
                    break;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }

	self_update_all_item_add_menus(self);
    }

    /**
     * Keep Tag's GtkListStore up2date
     */
    private
    void 
    tag_added(StuffkeeperDataBackend *skdb, StuffkeeperDataTag *tag, GtkTreeModel *store)
    {
        GtkTreeIter iter;
        gchar *title = stuffkeeper_data_tag_get_title(tag);
        gtk_list_store_insert_with_values(GTK_LIST_STORE(store), &iter, -1,
                    LP_ID, stuffkeeper_data_tag_get_id(tag),
                    LP_TITLE,title,
                    LP_ITEM,tag, 
                    LP_AMOUNT, stuffkeeper_data_tag_num_items(tag),
                    -1);
        g_free(title);
    }
    private
    void 
    tag_changed(StuffkeeperDataBackend *skdb, StuffkeeperDataTag *tag, GtkTreeModel *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_tag_get_id(tag);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, LP_ID, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_tag_get_title(tag);
                    gtk_list_store_set(GTK_LIST_STORE(store), &iter, 
                            LP_TITLE,title, 
                            LP_AMOUNT, stuffkeeper_data_tag_num_items(tag),
                            -1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    private
    void 
    tag_removed(StuffkeeperDataBackend *skdb, gint id, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, LP_ID, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    /**
     * Item GtkListStore
     * Update the gtk-list-store with signals from the backend
     */
    private
    void
    item_removed(StuffkeeperDataBackend *skdb, gint id,StuffkeeperInterface *self) 
    {
        GtkTreeIter iter;
        GtkListStore *store = GTK_LIST_STORE(self->_priv->model_items);
        GtkTreeModel *model = GTK_TREE_MODEL(store);

        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    private
    void
    item_added(StuffkeeperDataBackend *skdb, StuffkeeperDataItem *item, StuffkeeperInterface *self) 
    {
        GtkTreeIter iter;
        GtkListStore *store = GTK_LIST_STORE(self->_priv->model_items);

        gchar *title = stuffkeeper_data_item_get_title(item);

        gtk_list_store_insert_with_values(GTK_LIST_STORE(store), &iter,-1,
                    0, stuffkeeper_data_item_get_id(item),
                    1, title, 
                    2, item,
                    3, stuffkeeper_data_item_get_creation_time(item),
                    4, stuffkeeper_data_schema_get_id(stuffkeeper_data_item_get_schema(item)),
                    5, stuffkeeper_data_item_get_modification_time(item),
                    -1);
        g_free(title);
    }
    private
    void
    item_changed(StuffkeeperDataBackend *skdb, const gchar *field, StuffkeeperDataItem *item, StuffkeeperInterface *self) 
    {
        GtkTreeIter iter;
        GtkListStore *store = GTK_LIST_STORE(self->_priv->model_items);
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_item_get_id(item);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_item_get_title(item);
                    gtk_list_store_set(store, &iter, 1,title, 
                            -1);

                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    private
    void
    add_item(self, StuffkeeperDataSchema *schema)
    {
        GtkTreeIter iter;
        StuffkeeperDataItem *item = stuffkeeper_data_backend_new_item(self->_priv->skdbg,schema);
	/* Set new item tags */
        if(gtk_tree_model_get_iter_first(self->_priv->model_tags, &iter))
        {
            do{
                StuffkeeperDataTag *tag = NULL;
                gboolean enabled;
                gtk_tree_model_get(GTK_TREE_MODEL(self->_priv->model_tags), &iter,2, &enabled, 3,&tag, -1); 
                if(enabled)
                {
                    stuffkeeper_data_item_add_tag(item, tag);
                }

            }while(gtk_tree_model_iter_next(self->_priv->model_tags, &iter));
        }
	/* signal to other window components that the item was added on this
	 * window */
	self_item_added_here(self, item);
    }
    /**
     * Add item button clicked 
     */
    public
        void 
        interface_item_add(self,GtkWidget *button)
        {
            gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
            if(locked){printf("**ERROR** should not be callable\n");return;}

            GList *list = stuffkeeper_data_backend_get_schemas(self->_priv->skdbg);
            /* check if there are schema's */
            if(list)
            {
                StuffkeeperDataSchema *schema = g_object_get_data(G_OBJECT(button), "schema");
                /* if there is no schema, get the first*/
                if(schema  == NULL || !STUFFKEEPER_IS_DATA_SCHEMA(schema))
                {
                    schema = list->data;
                }
                self_add_item(self, schema);
                g_list_free(list);
            }

        }

    private
        void 
        interface_item_add_menu_button(self, GtkWidget *button)
        {
            gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
            if(locked){printf("**ERROR** should not be callable\n");return;}
            StuffkeeperDataSchema *schema = g_object_get_data(G_OBJECT(button), "schema");
            if(schema)
            {
                self_add_item(self, schema);
                /* Store last added item. */
                g_object_set_data(G_OBJECT(self->_priv->AddMenuButton), "schema", schema);
            }

        }


    /**
     * Remove selected item
     */
    public
        void interface_item_remove(self)
        {
            gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
            if(locked){printf("**ERROR** should not be callable\n");return;}

            /** Setup a dialog that ask the user if he is sure */
            GtkWidget *tree = self->_priv->treeview2;//glade_xml_get_widget(xml, "treeview2");
            GtkWidget *dialog;
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree));
            GtkTreeModel *model = GTK_TREE_MODEL(gtk_tree_view_get_model(GTK_TREE_VIEW(tree)));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {

                dialog = gtk_message_dialog_new(GTK_WINDOW(self->_priv->win), 
                        GTK_DIALOG_DESTROY_WITH_PARENT|// This belongs to the parent, so if the user closes the parent, close it
                        GTK_DIALOG_MODAL, // It is a warning, it _should_ be modal.
                        GTK_MESSAGE_WARNING, // It is a warning message.
                        GTK_BUTTONS_YES_NO, // yes/no question
                        _("Deleting an entry cannot be undone.\nAre you sure you want to continue?"));
                switch(gtk_dialog_run(GTK_DIALOG(dialog)))
                {
                    case GTK_RESPONSE_YES:
                        {
                            gint id;
                            gtk_tree_model_get(model, &iter ,0,&id, -1);
                            stuffkeeper_data_backend_remove_item(self->_priv->skdbg, id);

                        }
                    default:
                        gtk_widget_destroy(dialog);
                }
            }
        }

    /**
     * Tag is enabled/disabled
     */
    private
        void 
        interface_left_pane_toggled(self, gchar *path, GtkCellRendererToggle *renderer)
        {
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));
            GtkTreeIter iter;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            if(type == LP_TYPE_SEARCH)
            {
                gboolean value = !gtk_cell_renderer_toggle_get_active(renderer);
                if(value == FALSE)
                {
                    gtk_combo_box_set_active(GTK_COMBO_BOX(self->_priv->cb_search), 0);
                }else{
                    GtkTreeIter iter;
                    if(gtk_tree_model_get_iter_from_string(model, &iter, path))
                    {
                        gtk_combo_box_set_active_iter(GTK_COMBO_BOX(self->_priv->cb_search), &iter);
                    }
                }
            }
            else
            {
                if(gtk_tree_model_get_iter_from_string(model, &iter, path))
                {
                    gboolean value = !gtk_cell_renderer_toggle_get_active(renderer);
                    gtk_list_store_set(GTK_LIST_STORE(model), &iter, LP_SELECTED,value,-1);

                    /* refilter the items list */
                    gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
                }
            }
        }

    private
        void interface_item_title_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gint id;
                StuffkeeperDataItem *item;
                gtk_tree_model_get(model, &iter ,0,&id, -1);
                item = stuffkeeper_data_backend_get_item(self->_priv->skdbg, id);
                if(item)
                {
                    stuffkeeper_data_item_set_title(item, new_text);
                }
            }
        }

    private
        void interface_left_pane_edited 
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )

        {
            GtkTreeIter iter;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                GObject *item;

                gtk_tree_model_get(model, &iter ,LP_ITEM,&item, -1);

                if(STUFFKEEPER_IS_DATA_TAG(item)) {
                    stuffkeeper_data_tag_set_title(STUFFKEEPER_DATA_TAG(item), new_text);
                }else if (STUFFKEEPER_IS_DATA_SCHEMA(item)){
                    stuffkeeper_data_schema_set_title(STUFFKEEPER_DATA_SCHEMA(item), new_text);
               }else if (STUFFKEEPER_IS_DATA_ITEM_SEARCH(item)){
                   stuffkeeper_data_item_search_set_title(STUFFKEEPER_DATA_ITEM_SEARCH(item), new_text);
                }
            }
        }
    /**
     * Quit the program
     */
    public
    void quit_program(void)
    {
        gtk_main_quit();
    }

    public 
    gboolean 
    close_window(self)
    {
        int n;
        interface_list = g_list_remove(interface_list, self);
        n = g_list_length(interface_list);
        g_object_unref(self);

        if(n == 0)
        {
           gtk_main_quit();
        }
        return TRUE;
    }
    public
    void
    new_window(self)
    {
        Self *ski;
        ski= stuffkeeper_interface_new(self->config_file);
        interface_list = g_list_append(interface_list, ski);
        stuffkeeper_interface_initialize_interface(ski,self->_priv->skdbg,G_OBJECT(self->_priv->spm));
    }

    /**
     * Filtering the item list
     */
    public
        gboolean 
        interface_visible_func(GtkTreeModel *model, GtkTreeIter *iter, StuffkeeperInterface *self) 
        {
            StuffkeeperDataItem *item;
            /* Get the item */
            gtk_tree_model_get(model, iter, 2,&item, -1);


            if(!item) {
                return FALSE;
            }
            return self_item_is_visible(self, item);
        }
    public
    gboolean
    item_is_visible(self, StuffkeeperDataItem *item)
    {
        int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));
        const gchar *text = gtk_entry_get_text(GTK_ENTRY(self->_priv->search_entry));
        GtkTreeModel *model2 = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
        GtkTreeIter piter;
        GtkTreeIter iter;
        /**
         * Left pane selection filtering
         * Only when search type is not filter
         */
        if(gtk_tree_model_get_iter_first(model2, &piter) && type != LP_TYPE_SEARCH)
        {
            int found = -1;
            do{
                GObject *tag;
                gboolean sel;
                /* get the tag, and if it is selected */
                gtk_tree_model_get(model2, &piter,LP_SELECTED,&sel, LP_ITEM,&tag, -1);

                if(sel && tag)
                {
                    if(type == LP_TYPE_TAG && !stuffkeeper_data_item_has_tag(item, STUFFKEEPER_DATA_TAG(tag)))
                    {
                        return FALSE;
                    }
                    /* if viewing types, and it matches mark found */
                    else if (type == LP_TYPE_SCHEMA && 
                             stuffkeeper_data_schema_get_id(stuffkeeper_data_item_get_schema(item)) == 
                             stuffkeeper_data_schema_get_id(STUFFKEEPER_DATA_SCHEMA(tag)))
                    {
                        found = 1;
                    }
                    /* set that there are items selected */
                    else if (type == LP_TYPE_SCHEMA && found == -1)
                    {
                        found = 0;
                    }
                }

            }while(gtk_tree_model_iter_next(model2, &piter));
            /* if viewing types and no selected item matches return FALSE */
            if(type == LP_TYPE_SCHEMA && found == 0)
            {
                return FALSE;
            }
        }
        /**
         * Execute filter 
         */
        if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->_priv->cb_search), &iter))
        {
            StuffkeeperDataItemSearch *search;
            gtk_tree_model_get(self->_priv->model_searches, &iter, LP_ITEM, &search, -1);
            if(search)
            {
                if(!stuffkeeper_data_item_search_match(search, item))
                {
                    return FALSE;
                }
            }
        }
        /**
         * Search box 
         */
        if(strlen(text) > 0)
        {
            return stuffkeeper_data_item_has_value(item,text); 
        }
        return TRUE;
    }
    private
    gboolean
    search_entry_changed_timeout(self)
    {
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));

        self->_priv->search_timeout =0;
        /* remove it */
        return FALSE;
    }
    
    public
    void
    search_entry_changed(self)
    {
        if(self->_priv->search_timeout) {
            g_source_remove(self->_priv->search_timeout);
            self->_priv->search_timeout = 0;
        }
        self->_priv->search_timeout = g_timeout_add(1000,(GSourceFunc)self_search_entry_changed_timeout, self);
    }
   
    private 
    void
    schema_edit_button_clicked(self, GtkWidget *button)
    {
        gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
        if(locked){printf("**ERROR** should not be callable\n");return;}

        StuffkeeperDataSchema *schema = g_object_get_data(G_OBJECT(button), "schema");
        if(schema)
        {
            StuffkeeperEditSchema *skes = stuffkeeper_edit_schema_new();
            stuffkeeper_edit_schema_set_schema(skes, schema);
        }
    }
    private 
        void
        interface_background_changed(GtkWidget *widget, GtkStyle *old, GtkWidget *wid)
        {
            g_signal_handlers_block_by_func(G_OBJECT(widget), self_interface_background_changed, wid);
            gtk_widget_modify_bg(wid, GTK_STATE_NORMAL, &(widget->style->light[GTK_STATE_NORMAL]));
            g_signal_handlers_unblock_by_func(G_OBJECT(widget),self_interface_background_changed, wid);
        }

    public
    void
    item_pane_checkbox(self,GtkCheckMenuItem *item)
    {
        self_interface_item_selection_changed(self, gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2)));
    }

   private 
        void 
        interface_item_selection_changed (self, GtkTreeSelection *selection)
        {

            GtkTreeModel *model;
            GtkTreeIter iter;
            GList *list;
            gboolean show_pane = gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(self->_priv->show_item_pane_menu_item));

            list = gtk_container_get_children(GTK_CONTAINER(self->_priv->item_view_container));
            if(list)
            {
                GList *node;
                for(node = g_list_first(list); node; node = g_list_next(node))
                {
                    gtk_widget_destroy(GTK_WIDGET(node->data));
                }
                g_list_free(list);
            }
            if(!show_pane)
            {
                gtk_widget_hide(self->_priv->item_view_container);
                return;
            }


            model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {
                StuffkeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    GtkWidget *wid = stuffkeeper_item_view_new(item);
                    gtk_container_add(GTK_CONTAINER(self->_priv->item_view_container), wid);
                    gtk_widget_show_all(self->_priv->item_view_container);
                }
            }
            else
            {
                GtkWidget *frame = gtk_frame_new(NULL);
                GtkWidget *label = gtk_label_new("");
                GtkWidget *event = gtk_event_box_new();
                GtkWidget *hbox = gtk_hbox_new(FALSE, 6);
                GtkWidget *ali = gtk_alignment_new(1.0, 0.5,0,0);

                gtk_frame_set_shadow_type(GTK_FRAME(frame), GTK_SHADOW_ETCHED_IN);
                g_signal_connect(G_OBJECT(event), "style-set", G_CALLBACK(self_interface_background_changed), event);
                gtk_label_set_markup(GTK_LABEL(label), _("<b>No item to preview, select an item from the item list to preview it</b>"));

                gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.5);

                gtk_container_add(GTK_CONTAINER(ali), gtk_image_new_from_icon_name("stuffkeeper", GTK_ICON_SIZE_DIALOG));
                 gtk_box_pack_start(GTK_BOX(hbox),ali, TRUE, TRUE, 0);               
                gtk_box_pack_start(GTK_BOX(hbox),label, TRUE, TRUE, 0);

                gtk_container_add(GTK_CONTAINER(frame),hbox);
                gtk_container_add(GTK_CONTAINER(event),frame);
                gtk_container_add(GTK_CONTAINER(self->_priv->item_view_container), event);
                gtk_widget_show_all(self->_priv->item_view_container);
            }
            return;
        }

     /**
     * Right mouse handling left treeview
     */
    /**
     * Label signals
     */
     private
     void
     add_tag(self, GtkMenuItem *item)
     {
         gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
         if(locked){printf("**ERROR** should not be callable\n");return;}
         g_signal_handler_block(self->_priv->skdbg,self->_priv->signal_tag_added);
         StuffkeeperDataTag *tag = stuffkeeper_data_backend_new_tag(self->_priv->skdbg);

         stuffkeeper_data_tag_set_title(tag, _("New Tag"));
         if(tag)
         {
             GtkTreeIter iter;
             gtk_list_store_append(GTK_LIST_STORE(self->_priv->model_tags), &iter);
             gchar *title = stuffkeeper_data_tag_get_title(tag);
             gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_tags), &iter, 
                     0, stuffkeeper_data_tag_get_id(tag),
                     1,title,
                     3,tag, 
                     4, stuffkeeper_data_tag_num_items(tag),
                     -1);

             if(self->_priv->treeview1_renderer)
             {
                 GtkTreeViewColumn *col = gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->treeview1), 1);
                 GtkTreePath *path = gtk_tree_model_get_path(self->_priv->model_tags, &iter);
                 gtk_tree_view_set_cursor_on_cell(GTK_TREE_VIEW(self->_priv->treeview1), path, col,self->_priv->treeview1_renderer, TRUE);
                 gtk_tree_path_free(path);
             }
             g_free(title);
         }
         g_signal_handler_unblock(self->_priv->skdbg,self->_priv->signal_tag_added);
     }
     private 
     void
     remove_tag(self, GtkMenuItem *item)
     {
         gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
         if(locked){printf("**ERROR** should not be callable\n");return;}
         GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeIter iter;
         if(gtk_tree_selection_get_selected(selection,&model, &iter))
         {
             gint items;
             gint id;
             /* Get id and items */
             gtk_tree_model_get(model, &iter,0,&id,4,&items, -1);

             if(items == 0)
             {
                 stuffkeeper_data_backend_remove_tag(self->_priv->skdbg,id);
             }
         }
     }
    /* Types */

     private
     void
     add_type(self, GtkMenuItem *item)
     {
         gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
         if(locked){printf("**ERROR** should not be callable\n");return;}

         g_signal_handler_block(self->_priv->skdbg,self->_priv->signal_schema_added);
         StuffkeeperDataSchema *schema = stuffkeeper_data_backend_new_schema(self->_priv->skdbg);
         stuffkeeper_data_schema_set_title(schema, _("New Schema"));
         if(schema)
         {
             GtkTreeIter iter;
             gtk_list_store_append(GTK_LIST_STORE(self->_priv->model_schemas), &iter);
             gchar *title = stuffkeeper_data_schema_get_title(schema);
             gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_schemas), &iter, 
                     0, stuffkeeper_data_schema_get_id(schema),
                     1, title,
                     3, schema,
                     4, stuffkeeper_data_schema_num_items(schema),-1);



             if(self->_priv->treeview1_renderer)
             {
                 GtkTreeViewColumn *col = gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->treeview1), 1);
                 GtkTreePath *path = gtk_tree_model_get_path(self->_priv->model_schemas, &iter);
                 gtk_tree_view_set_cursor_on_cell(GTK_TREE_VIEW(self->_priv->treeview1), path, col,self->_priv->treeview1_renderer, TRUE);
                 gtk_tree_path_free(path);
             }
         }
         g_signal_handler_unblock(self->_priv->skdbg,self->_priv->signal_schema_added);
     }
     private 
     void
     remove_type(self, GtkMenuItem *item)
     {
         gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
         if(locked){printf("**ERROR** should not be callable\n");return;}

         GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeIter iter;
         if(gtk_tree_selection_get_selected(selection,&model, &iter))
         {
             gint items;
             gint id;
             /* Get id and items */
             gtk_tree_model_get(model, &iter,0,&id,4,&items, -1);

             if(items == 0)
             {
                 stuffkeeper_data_backend_remove_schema(self->_priv->skdbg,id);
             }
         }


     }
     private 
     void
     edit_type(self, GtkMenuItem *item)
     {
         gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
         if(locked){printf("**ERROR** should not be callable\n");return;}

         GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeIter iter;
         if(gtk_tree_selection_get_selected(selection,&model, &iter))
         {
             StuffkeeperDataSchema *schema;
             gtk_tree_model_get(model, &iter, 3, &schema, -1);
             if(schema)
             {
                 StuffkeeperEditSchema *skes = stuffkeeper_edit_schema_new();
                 stuffkeeper_edit_schema_set_schema(skes, schema);
             }
         }
     }
    
    /* right mouse menu item treeview */
    public
    gboolean 
    treeview2_button_press_event(self, GdkEventButton *event, GtkWidget *widget)
    {

        return FALSE;
    }
    private
    void
    menu_plugin_called(self, GtkWidget *item)
    {
        StuffkeeperPlugin *plugin = g_object_get_data(G_OBJECT(item), "plugin");
        if(plugin)
        {
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkWidget *tree = self->_priv->treeview2;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {
                StuffkeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    stuffkeeper_plugin_run_item(STUFFKEEPER_PLUGIN(plugin), item);
                    return;
                }
            }
        }
    }

    public
    gboolean 
    treeview2_button_release_event(self, GdkEventButton *event, GtkWidget *widget)
    {
        debug_printf("treeview2 buttom release event\n");
        if(event->button == 3)
        {
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection,&model, &iter))
            {
                GtkWidget *menu;                
                GtkWidget *menu_item;
                GList *node,*iter;
                /* create menu */
                menu = gtk_menu_new();

                menu_item = gtk_image_menu_item_new_from_stock(GTK_STOCK_OPEN, NULL);
                g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_interface_item_open), self);
                gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);

                if(!stuffkeeper_data_backend_get_locked(self->_priv->skdbg))
                {
                    menu_item = gtk_image_menu_item_new_from_stock(GTK_STOCK_REMOVE, NULL);
                    g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_interface_item_remove), self);
                    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                }


                menu_item = gtk_image_menu_item_new_with_label(_("Export"));
                gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), gtk_image_new_from_stock(GTK_STOCK_SAVE, GTK_ICON_SIZE_MENU));
                g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_export_html_item), self);
                gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);


                node = stuffkeeper_plugin_manager_get_loaded_plugins(self->_priv->spm); 
                if(node)
                {
                    for(iter = g_list_first(node);iter;iter = g_list_next(iter))
                    {
                        StuffkeeperPlugin *plugin = iter->data; 
                        if(stuffkeeper_plugin_get_plugin_type(plugin)&PLUGIN_ITEM)
                        {
                            gint width = 16, height=16;
                            GdkPixbuf *pb = stuffkeeper_plugin_get_icon(plugin);

                            menu_item = gtk_image_menu_item_new_with_label(stuffkeeper_plugin_get_name(plugin));
                            if(pb)
                            {
                                GdkPixbuf *scale = gdk_pixbuf_scale_simple(pb,width, height, GDK_INTERP_BILINEAR);
                                gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item),gtk_image_new_from_pixbuf(scale));
                                g_object_unref(scale);
                            }

                            g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_menu_plugin_called), self);
                            g_object_set_data(G_OBJECT(menu_item), "plugin", plugin);
                            gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                        }
                    }
                    g_list_free(node);
                }

                /* popup the menu */
                gtk_widget_show_all(menu);

                gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, event->button, event->time);
                return FALSE;
            }
        }
        return FALSE;
    }



    /* Right mouse button press */
   public
    gboolean 
    treeview1_button_press_event(self, GdkEventButton *event, GtkWidget *widget)
    {

        return FALSE;
    }
    public 
    gboolean
    treeview1_button_release_event(self, GdkEventButton *event, GtkWidget *widget)
    {
        if(stuffkeeper_data_backend_get_locked(self->_priv->skdbg))
        {
            /* no right menu in locked mode */
            return FALSE;
        }


        /* Right mouse click, ignore rest */
        if(event->button == 3)
        {
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview1));
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            GtkTreeIter iter;
            GtkWidget *menu;
            GtkWidget *menu_item;

            debug_printf("treeview 1 button press event\n");
            /* Create menu */
            menu = gtk_menu_new();

            if(type == LP_TYPE_TAG)
            {
                /* Add tag */
                menu_item = gtk_image_menu_item_new_with_label(_("New tag"));
                gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                        gtk_image_new_from_stock(GTK_STOCK_ADD, GTK_ICON_SIZE_MENU));
                g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_add_tag), self);
                gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                if(gtk_tree_selection_get_selected(selection,&model, &iter))
                {
                    int items;
                    /* Get the number of items */
                    gtk_tree_model_get(model, &iter, 4, &items, -1);

                    /* no items, then you can delete it*/
                    if(items ==  0)
                    {
                        menu_item = gtk_image_menu_item_new_with_label(_("Remove tag"));
                        gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                                gtk_image_new_from_stock(GTK_STOCK_REMOVE, GTK_ICON_SIZE_MENU));
                        g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_remove_tag),self);
                        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                    }
                }
            }
            else if (type == LP_TYPE_SCHEMA) 
            {
                /* Add item */
                menu_item = gtk_image_menu_item_new_with_label(_("New type"));
                gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                        gtk_image_new_from_stock(GTK_STOCK_ADD, GTK_ICON_SIZE_MENU));
                g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_add_type), self);
                gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                if(gtk_tree_selection_get_selected(selection,&model, &iter))
                {
                    int items;
                    /* Get the number of items */
                    gtk_tree_model_get(model, &iter, 4, &items, -1);

                    /* no items, then you can delete it*/
                    if(items ==  0)
                    {
                        menu_item = gtk_image_menu_item_new_with_label(_("Remove type"));
                        gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                                gtk_image_new_from_stock(GTK_STOCK_REMOVE, GTK_ICON_SIZE_MENU));
                        g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_remove_type),self);
                        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                    }
                    menu_item = gtk_image_menu_item_new_with_label(_("Edit type"));
                    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                            gtk_image_new_from_stock(GTK_STOCK_EDIT, GTK_ICON_SIZE_MENU));
                    g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_edit_type),self);
                    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);

                }

            } else if (type == LP_TYPE_SEARCH)
            {
                /* Add item */
                menu_item = gtk_image_menu_item_new_with_label(_("New filter"));
                gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                        gtk_image_new_from_stock(GTK_STOCK_ADD, GTK_ICON_SIZE_MENU));
                g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_new_search), self);
                gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                if(gtk_tree_selection_get_selected(selection,&model, &iter))
                {
                    int id;
                    StuffkeeperDataItemSearch *search;
                    /* Get the number of items */
                    gtk_tree_model_get(model, &iter, 0, &id,3, &search, -1);

                    /* no items, then you can delete it*/
                    if(id >=  0)
                    {

                        menu_item = gtk_image_menu_item_new_with_label(_("Remove filter"));
                        g_object_set_data(G_OBJECT(menu_item), "search", search);
                        gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                                gtk_image_new_from_stock(GTK_STOCK_REMOVE, GTK_ICON_SIZE_MENU));
                        g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_remove_search_menu),self);
                        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);


                        menu_item = gtk_image_menu_item_new_with_label(_("Edit filter"));
                        g_object_set_data(G_OBJECT(menu_item), "search", search);
                        gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                                gtk_image_new_from_stock(GTK_STOCK_EDIT, GTK_ICON_SIZE_MENU));
                        g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_edit_search_menu),self);
                        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                    }
                }
            }

            /* popup the menu */
            gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, event->button, event->time);
            /* show the widget */
            gtk_widget_show_all(menu);
            /* don't pass message */
            return TRUE;
        }
        return FALSE;
    }


    public
        StuffkeeperInterface * 
        new(GKeyFile *config_file)
        {
            GtkAccelGroup *agroup = NULL;
            int value,width,height;
            GError *error = NULL;
            Self *self = GET_NEW;

            self->_priv->xml = glade_xml_new(PACKAGE_DATADIR"/stuffkeeper.glade","win",NULL);

            self->config_file = config_file;

            if(self->_priv->xml == NULL)
            {
                g_object_unref(self);
                debug_printf("Failed top open xml file\n");
                return NULL;
            }
            self->_priv->hpaned1 =  glade_xml_get_widget(self->_priv->xml, "hpaned1");
            self->_priv->vpaned1 =  glade_xml_get_widget(self->_priv->xml, "vpaned1");
            self->_priv->LeftPaneCB  = glade_xml_get_widget(self->_priv->xml, "LeftPaneCB");
            self->_priv->treeview1 = glade_xml_get_widget(self->_priv->xml, "treeview1");
            self->_priv->treeview2 = glade_xml_get_widget(self->_priv->xml, "treeview2");

            self->_priv->LeftPane_edit = glade_xml_get_widget(self->_priv->xml, "LeftPane_edit");
            self->_priv->AddMenuButton = glade_xml_get_widget(self->_priv->xml, "AddMenuButton");

            self->_priv->item_label = glade_xml_get_widget(self->_priv->xml, "item_label");
            self->_priv->item_view_container = glade_xml_get_widget(self->_priv->xml, "item_view_container");
            self->_priv->show_item_pane_menu_item = glade_xml_get_widget(self->_priv->xml, "show_item_pane_menu_item");
            
             self->_priv->cb_search = glade_xml_get_widget(self->_priv->xml, "cb_search");
            
	    self->_priv->menuitem_item_add = glade_xml_get_widget(self->_priv->xml, "menuitem_item_add");

            self->_priv->win = glade_xml_get_widget(self->_priv->xml, "win");

            /* Accel group */
            agroup = gtk_accel_group_new();
            gtk_window_add_accel_group(GTK_WINDOW(self->_priv->win), agroup);

            gtk_widget_hide_on_delete(self->_priv->win);

            /**
             * Custom search widget, glade does not support, sexy-icon and screws up alignment 
             */
            /* sexy icon + setup */
            self->_priv->search_entry = sexy_icon_entry_new();
            /* Add clear button */
            sexy_icon_entry_add_clear_button(SEXY_ICON_ENTRY(self->_priv->search_entry));
            /* Add find icon */
            sexy_icon_entry_set_icon(SEXY_ICON_ENTRY(self->_priv->search_entry),SEXY_ICON_ENTRY_PRIMARY, 
                GTK_IMAGE(gtk_image_new_from_stock(GTK_STOCK_FIND, GTK_ICON_SIZE_MENU)));

            gtk_box_pack_end(GTK_BOX(glade_xml_get_widget(self->_priv->xml,"hbox3")), self->_priv->search_entry, FALSE, TRUE,0);
            g_signal_connect_swapped(G_OBJECT(self->_priv->search_entry), "changed", G_CALLBACK(self_search_entry_changed), self);

            gtk_widget_show_all(GTK_WIDGET(self->_priv->search_entry));

            gtk_widget_add_accelerator(self->_priv->search_entry, "grab-focus",agroup, GDK_f, GDK_CONTROL_MASK,0);

            /* read config */
            value = g_key_file_get_integer(self->config_file, "WINDOW", "hpane", &error);
            if(error ) {
                debug_printf("No valid pane position: %s\n", error->message);
                /* Free error */
                g_error_free(error);
                error = NULL;
            }
            else if(value > 50)
            {
                debug_printf("Setting position: %i\n", value);
                gtk_paned_set_position(GTK_PANED(self->_priv->hpaned1), value);
            }
            value = g_key_file_get_integer(self->config_file, "WINDOW", "vpane", &error);
            if(error ) {
                debug_printf("No valid vpane position: %s\n", error->message);
                /* Free error */
                g_error_free(error);
                error = NULL;
            }
            else if(value > 50)
            {
                debug_printf("Setting position: %i\n", value);
                gtk_paned_set_position(GTK_PANED(self->_priv->vpaned1), value);
            }
            /* Restore size and position */

            width = g_key_file_get_integer(self->config_file, "WINDOW", "width", &error);
            if(error) {
                g_error_free(error);
                error = NULL;
            } else {
                height = g_key_file_get_integer(self->config_file, "WINDOW", "height", &error);
                if(error) {
                    g_error_free(error);
                    error = NULL;
                } else {
                    gtk_window_resize(GTK_WINDOW(self->_priv->win), width, height);
                }
            }
            /* Move window */
            width = g_key_file_get_integer(self->config_file, "WINDOW", "x-pos", &error);
            if(error) {
                g_error_free(error);
                error = NULL;
            } else {
                height = g_key_file_get_integer(self->config_file, "WINDOW", "y-pos", &error);
                if(error) {
                    g_error_free(error);
                    error = NULL;
                } else {
                    gtk_window_move(GTK_WINDOW(self->_priv->win), width, height);
                }
            }
            /* show pane */
            width = g_key_file_get_integer(self->config_file, "WINDOW", "show-item-pane", &error);
            if(error) {
                g_error_free(error);
                error = NULL;
            } else {
                gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(self->_priv->show_item_pane_menu_item),width);
            }

            /* setup treeview */
            gtk_tree_view_set_fixed_height_mode(GTK_TREE_VIEW(self->_priv->treeview2), TRUE);
            gtk_tree_view_set_enable_search(GTK_TREE_VIEW(self->_priv->treeview2), FALSE);


            glade_xml_signal_autoconnect_full(self->_priv->xml, (GladeXMLConnectFunc)self____glade_xml_connect_foreach, (gpointer)self);
            /* some testing */
            gtk_widget_show(self->_priv->win);
            /* put this after the show, or it will turn up black, for some oddball reason */
            self_interface_item_selection_changed(self, gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2)));

            return self;
        }

    public
    void
    left_pane_changed(self, GtkComboBox *box)
    {
        int i = gtk_combo_box_get_active(box);
        if(i==0){
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_tags));
        }else if (i == 1){
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_schemas));
        }else if ( i == 2) {
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_searches));
        }

        /* refilter the items list */
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
    }

    public
    void
    search_type_changed(self, GtkComboBox *box)
    {
        GtkTreeIter iter, node;
        if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->_priv->cb_search), &iter))
        {
            StuffkeeperDataItemSearch *search;
            GtkWidget *item = glade_xml_get_widget(self->_priv->xml, "menuitem_filter_remove");
            GtkWidget *item1 = glade_xml_get_widget(self->_priv->xml, "menuitem_filter_edit");
            gint id;
            gtk_tree_model_get(self->_priv->model_searches, &iter,0,&id, 3, &search, -1);

            if(id == -1) {
                gtk_widget_set_sensitive(item, FALSE);
                gtk_widget_set_sensitive(item1, FALSE);
            } else {
                gtk_widget_set_sensitive(item, TRUE);
                gtk_widget_set_sensitive(item1, TRUE);
            }
            if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->model_searches), &node)) {
                do{
                    gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_searches), &node, 2, FALSE,-1);
                }while(gtk_tree_model_iter_next(GTK_TREE_MODEL(self->_priv->model_searches), &node));
            }
            gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_searches), &iter, 2, TRUE,-1);
        }
        /* refilter the items list */
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
    }

    /* Add item menu */
    private
    void 
    update_all_item_add_menus(self) {
	self_update_item_add_menu(self, GTK_MENU_SHELL(self->_priv->menu), FALSE);
	self_update_item_add_menu(self, GTK_MENU_SHELL(self->_priv->menu_item_add), TRUE);
    }

    private
    void 
    update_item_add_menu(self, Gtk:MenuShell *menu, gboolean add_hotkeys)
    {
        GtkTreeIter iter;
        GList *node,*items = NULL;

        items = gtk_container_get_children(GTK_CONTAINER(menu));
        for(node = items; node;node = g_list_next(node))
        {
            gtk_widget_destroy(GTK_WIDGET(node->data));
        }
        if(items)
            g_list_free(items);

        if(gtk_tree_model_get_iter_first(self->_priv->model_schemas,&iter))
        {
	    gchar *menu_hotkeys = NULL;
	    gchar **menu_hotkeys_list = NULL;
	    gchar **menu_hotkey_ptr = NULL;

	    /* Colon-seperated list of shortcut-prefixes for menu items the
	     * last item on the list will be repeated for all menu entries
	     * witout their own items */
	    if(add_hotkeys) {
		menu_hotkeys = _("_1. :_2. :_3. :_4. :_5. :_6. :_7. :_8. :_9. :_0. :_A. :_B. :_C. :_D. :_E. :_F. :_G. :_H. :_I. :_J. :_K. :_L. :_M. :_M. :_N. :_O. :_P. :_Q. :_R. :_S. :_T. :_U. :_V. :_W. :_X. :_Y. :_Z. :   ");
		menu_hotkeys_list = g_strsplit(menu_hotkeys, ":", -1);
		menu_hotkey_ptr = menu_hotkeys_list;
	    }
            do{
                gchar *title = NULL;
		gchar *menu_entry = NULL;
                GtkWidget *m = NULL;
                StuffkeeperDataSchema *schema = NULL;

                gtk_tree_model_get(self->_priv->model_schemas, &iter, 1, &title,3,&schema, -1);
		if(add_hotkeys) {
		    if(title && g_strstr_len(title, -1, "_")) {
			gchar **tsplit;
			/* Need to escape underscores in the title */
			tsplit = g_strsplit(title, "_", -1);
			g_free(title);
			title = g_strjoinv("__",tsplit);
			g_strfreev(tsplit);
		    }
		    menu_entry = g_strconcat(*menu_hotkey_ptr, (title == NULL)?_("n/a"):title, NULL);
		    m=gtk_image_menu_item_new_with_mnemonic(menu_entry);
		} else {
		    m=gtk_image_menu_item_new_with_label((title == NULL)?_("n/a"):title);
		}
                gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(m), 
                    gtk_image_new_from_pixbuf(stuffkeeper_data_schema_get_pixbuf(schema)));
                gtk_menu_shell_insert(GTK_MENU_SHELL(menu), m,-1);
                g_object_set_data(G_OBJECT(m), "schema", schema);
                g_signal_connect_swapped(G_OBJECT(m), "activate", G_CALLBACK(self_interface_item_add_menu_button), self);
                gtk_widget_show_all(menu);
                if(title) {
                    g_free(title);
		}
		if(menu_entry) {
			g_free(menu_entry);
		}
		if(add_hotkeys && menu_hotkey_ptr[1]) {
		    menu_hotkey_ptr++;
		}

            } while(gtk_tree_model_iter_next(self->_priv->model_schemas, &iter));
	    if(add_hotkeys) {
		g_strfreev(menu_hotkeys_list);
	    }
        }
    }

    public
    void
    style_changed(GtkWidget *tree,GtkStyle *old, GtkCellRenderer *renderer)
    {
        debug_printf("style changed\n");
        g_object_set(G_OBJECT(renderer), 
                    "background-set", TRUE, "background-gdk",&(GTK_WIDGET(tree)->style->bg[GTK_STATE_SELECTED]), 
                    "foreground-set", TRUE, "foreground-gdk",&(GTK_WIDGET(tree)->style->fg[GTK_STATE_SELECTED]), 
                    NULL);
    }


    public
    void
    get_pixbuf(GtkTreeViewColumn *column, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter, gpointer data)
    {
        StuffkeeperDataItem *item;
        StuffkeeperDataSchema *schema;
        GdkPixbuf *pb;
        gtk_tree_model_get(model, iter, 2, &item, -1); 
        schema = stuffkeeper_data_item_get_schema(item);
        if(schema)
        {
            pb = stuffkeeper_data_schema_get_pixbuf(schema);
            g_object_set(renderer, "pixbuf", pb,NULL);
        }
    }

    private
    void
    backend_locked(self, GParamSpec *arg1, StuffkeeperDataBackend *backend)
    {
        GtkWidget *button = glade_xml_get_widget(self->_priv->xml, "toggle_locked");
        gboolean value = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(button));
        gboolean locked = stuffkeeper_data_backend_get_locked(backend);

        if(value != locked)
        {
            g_signal_handler_block(self->_priv->skdbg,self->_priv->signal_backend_locked);
            gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(button), locked);
            g_signal_handler_unblock(self->_priv->skdbg,self->_priv->signal_backend_locked);
        }

        button = glade_xml_get_widget(self->_priv->xml, "menuitem_view_locked");
        value = gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(button));
        if(value != locked)
        {
            g_signal_handler_block(self->_priv->skdbg,self->_priv->signal_backend_locked);
            gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(button), locked);
            g_signal_handler_unblock(self->_priv->skdbg,self->_priv->signal_backend_locked);
        }

        /* change the interface */
        if(locked)
        {
            g_object_set(G_OBJECT(self->_priv->treeview1_renderer), "editable", FALSE, NULL);
            gtk_widget_hide(glade_xml_get_widget(self->_priv->xml, "toolbar1"));
            gtk_widget_hide(glade_xml_get_widget(self->_priv->xml, "menuitem_item_sep"));
            gtk_widget_hide(glade_xml_get_widget(self->_priv->xml, "menuitem_item_add"));
            gtk_widget_hide(glade_xml_get_widget(self->_priv->xml, "menuitem_item_remove"));
            gtk_widget_hide(glade_xml_get_widget(self->_priv->xml, "menuitem_item_clone"));
            gtk_widget_hide(glade_xml_get_widget(self->_priv->xml, "menuitem_filter"));
            gtk_widget_hide(glade_xml_get_widget(self->_priv->xml, "menuitem_type_new"));
            gtk_widget_hide(glade_xml_get_widget(self->_priv->xml, "menuitem_type_import"));
        } else {
            g_object_set(G_OBJECT(self->_priv->treeview1_renderer), "editable", TRUE, NULL);
            gtk_widget_show(glade_xml_get_widget(self->_priv->xml, "toolbar1"));
            gtk_widget_show(glade_xml_get_widget(self->_priv->xml, "menuitem_item_sep"));
            gtk_widget_show(glade_xml_get_widget(self->_priv->xml, "menuitem_item_add"));
            gtk_widget_show(glade_xml_get_widget(self->_priv->xml, "menuitem_item_remove"));
            gtk_widget_show(glade_xml_get_widget(self->_priv->xml, "menuitem_item_clone"));
            gtk_widget_show(glade_xml_get_widget(self->_priv->xml, "menuitem_filter"));
            gtk_widget_show(glade_xml_get_widget(self->_priv->xml, "menuitem_type_new"));
            gtk_widget_show(glade_xml_get_widget(self->_priv->xml, "menuitem_type_import"));
        }


    }
    public
    void
    menu_backend_locked_toggled(self, GtkCheckMenuItem *item)
    {
        gboolean value = gtk_check_menu_item_get_active(item);
        gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
        if(locked != value)
        {
            stuffkeeper_data_backend_set_locked(self->_priv->skdbg, value);
        }
    }
    public
    void
    backend_locked_toggled(self, GtkToggleButton *button)
    {
        gboolean value = gtk_toggle_button_get_active(button);
        gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
        if(locked != value)
        {
            stuffkeeper_data_backend_set_locked(self->_priv->skdbg, value);
        }
    }

    /**
     * Initialize the main gui
     */
    public
        void 
        initialize_interface(self, StuffkeeperDataBackend *skdb,GObject *spm)
        {
            GError *error = NULL;
            gint value = 0, sort_order;
            GList *iter, *node;
            GtkTreeViewColumn *column;
            GtkCellRenderer *renderer;
            GtkTreeSelection *sel;
            /**
             * StuffkeeperDataBackend
             */
            self->_priv->skdbg = skdb;
            self->_priv->spm = STUFFKEEPER_PLUGIN_MANAGER(spm);
            /* locked signal */
            self->_priv->signal_backend_locked = g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), "notify::locked", G_CALLBACK(self_backend_locked), self);

            /* Setting up backends */
            self->_priv->model_schemas = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER,G_TYPE_INT);
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_schemas), 1, GTK_SORT_ASCENDING);

	    /* New Item menus */
            self->_priv->menu = gtk_menu_new();
            gtk_menu_tool_button_set_menu(GTK_MENU_TOOL_BUTTON(self->_priv->AddMenuButton), (self->_priv->menu));
            self->_priv->menu_item_add = gtk_menu_new();
	    gtk_menu_item_set_submenu(GTK_MENU_ITEM(self->_priv->menuitem_item_add), self->_priv->menu_item_add);

            /** Load the schemas*/
            node = stuffkeeper_data_backend_get_schemas(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_schema_added(self, STUFFKEEPER_DATA_SCHEMA(iter->data), self->_priv->skdbg);
            }
            if(node) g_list_free(node);

            self->_priv->signal_schema_added = g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), 
                    "schema-added",   
                    G_CALLBACK(self_schema_added),
                    self); 
            self->_priv->signal_schema_removed =g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), 
                    "schema-removed", 
                    G_CALLBACK(self_schema_removed),
                    self);
            self->_priv->signal_schema_changed=g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), 
                    "schema-changed", 
                    G_CALLBACK(self_schema_changed),
                    self);




            /* Tags */
            self->_priv->model_tags = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER,G_TYPE_INT);
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_tags), 1, GTK_SORT_ASCENDING);
            /** Load the tags */
            node = stuffkeeper_data_backend_get_tags(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_tag_added(self->_priv->skdbg, iter->data,self->_priv->model_tags);
            }
            if(node) g_list_free(node);
            /* handle an added tag */
            self->_priv->signal_tag_added = g_signal_connect(G_OBJECT(self->_priv->skdbg),
                    "tag-added",
                    G_CALLBACK(self_tag_added),
                    self->_priv->model_tags);
             self->_priv->signal_tag_changed = g_signal_connect(G_OBJECT(self->_priv->skdbg),
                    "tag-changed",
                    G_CALLBACK(self_tag_changed),
                    self->_priv->model_tags);
              self->_priv->signal_tag_removed = g_signal_connect(G_OBJECT(self->_priv->skdbg),
                    "tag-removed",
                    G_CALLBACK(self_tag_removed),
                    self->_priv->model_tags);

            self->_priv->model_items = (GtkTreeModel *)gtk_list_store_new(6, G_TYPE_INT,G_TYPE_STRING,G_TYPE_POINTER,G_TYPE_INT,G_TYPE_INT,G_TYPE_INT);
            sort_order = g_key_file_get_integer(self->config_file, "WINDOW", "item-sort-order", &error);
            if(error != NULL)
            {
                sort_order= GTK_SORT_DESCENDING;
                g_error_free(error);
                error = NULL;
            }
            else
            {
                self->_priv->item_sort_order = sort_order;
                if(sort_order == GTK_SORT_DESCENDING)
                {
                    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(glade_xml_get_widget(self->_priv->xml, "menu_sort_descending")),TRUE);
                }else{
                    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(glade_xml_get_widget(self->_priv->xml, "menu_sort_ascending")),TRUE);
                }
            }
            value = g_key_file_get_integer(self->config_file, "WINDOW", "item-sort-column", &error);
            if(error == NULL) {
                self->_priv->item_sort_column = value;
                gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_items), value, sort_order);
                switch(value) {
                    case 1:
                        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(glade_xml_get_widget(self->_priv->xml, "menu_sort_by_title")),TRUE);
                        break;
                    case 4:
                         gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(glade_xml_get_widget(self->_priv->xml, "menu_sort_by_schema")),TRUE);
                        break;
                    case 5:
                        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(glade_xml_get_widget(self->_priv->xml, "menu_sort_by_modification_time")),TRUE);
                        break;
                    default:
                        gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(glade_xml_get_widget(self->_priv->xml, "menu_sort_by_creation_time")),TRUE);
                        break;
                }
            } else {
                g_error_free(error);
                error = NULL;
                gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_items), 3, sort_order);
            }
            /** Load the items*/
            node = stuffkeeper_data_backend_get_items(self->_priv->skdbg);
            stuffkeeper_data_backend_begin_transaction(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_item_added(self->_priv->skdbg, STUFFKEEPER_DATA_ITEM(iter->data),self);
            }
            stuffkeeper_data_backend_end_transaction(self->_priv->skdbg);
            if(node) g_list_free(node);
            self->_priv->signal_item_added = g_signal_connect(G_OBJECT(self->_priv->skdbg), 
                    "item-added",   
                    G_CALLBACK(self_item_added),
                    self); 
            self->_priv->signal_item_removed = g_signal_connect(G_OBJECT(self->_priv->skdbg), 
                    "item-removed",
                    G_CALLBACK(self_item_removed),
                    self);
            self->_priv->signal_item_changed = g_signal_connect(G_OBJECT(self->_priv->skdbg), 
                    "item-changed", 
                    G_CALLBACK(self_item_changed),
                    self);

            /**
             * Searches
             */
            self->_priv->model_searches = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER, G_TYPE_INT);

            gtk_combo_box_set_model(GTK_COMBO_BOX(self->_priv->cb_search), self->_priv->model_searches);
            {
                GObject* search = stuffkeeper_data_item_search_new_dummy();
                self_search_added(self, STUFFKEEPER_DATA_ITEM_SEARCH(search), self->_priv->skdbg);
            }
            node = stuffkeeper_data_backend_get_searches(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_search_added(self, STUFFKEEPER_DATA_ITEM_SEARCH(iter->data),self->_priv->skdbg);
            }
            if(node) g_list_free(node);
            self->_priv->signal_search_added = g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), 
                    "search-added",
                    G_CALLBACK(self_search_added),
                    self); 
            self->_priv->signal_search_removed = g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), 
                    "search-removed",
                    G_CALLBACK(self_search_removed),
                    self);
            self->_priv->signal_search_changed = g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), 
                    "search-changed",
                    G_CALLBACK(self_search_changed),
                    self);





            /**
             * Items
             */
            /* A filtered items */
            self->_priv->model_items_filter = gtk_tree_model_filter_new(GTK_TREE_MODEL(self->_priv->model_items), NULL);
            g_signal_connect_swapped(G_OBJECT(self->_priv->model_items_filter), "row-inserted", G_CALLBACK(self_filter_model_row_inserted), self);
            g_signal_connect_swapped(G_OBJECT(self->_priv->model_items_filter), "row-deleted", G_CALLBACK(self_filter_model_row_deleted), self);

            renderer = gtk_cell_renderer_pixbuf_new();

            gtk_tree_view_insert_column_with_data_func(GTK_TREE_VIEW(self->_priv->treeview2), -1,"test", renderer, 
                    self_get_pixbuf, self, NULL);

            gtk_tree_view_column_set_sizing(
                        GTK_TREE_VIEW_COLUMN(gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->treeview2), 0)), 
                        GTK_TREE_VIEW_COLUMN_FIXED);
            
              gtk_tree_view_column_set_fixed_width(

                    GTK_TREE_VIEW_COLUMN(gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->treeview2), 0)), 
                    24+gtk_tree_view_column_get_spacing(GTK_TREE_VIEW_COLUMN(gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->treeview2), 0))));

            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->treeview2), -1, "items", renderer, "text", 1, NULL);
//            g_object_set(renderer, "editable", TRUE,NULL);
            gtk_tree_view_column_set_sizing(
                    GTK_TREE_VIEW_COLUMN(gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->treeview2), 1)), 
                    GTK_TREE_VIEW_COLUMN_FIXED);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_item_title_edited), self);

            /* Look at the tree */
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview2), GTK_TREE_MODEL(self->_priv->model_items_filter));

            /* get changed selection */
            sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            g_signal_connect_swapped(G_OBJECT(sel), "changed", G_CALLBACK(self_interface_item_selection_changed), self);

            /* Tag list */
            gtk_tree_model_filter_set_visible_func(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter), 
                    (GtkTreeModelFilterVisibleFunc)self_interface_visible_func, self, NULL);



            /* TAGS */
            column = gtk_tree_view_column_new();

            /* Toggle button  */

            self->_priv->renderer_toggle = renderer = gtk_cell_renderer_toggle_new();
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE);
            gtk_tree_view_column_set_attributes(column, renderer, "active", 2, NULL);
            /* handle toggled */
            g_signal_connect_swapped(G_OBJECT(renderer), "toggled", G_CALLBACK(self_interface_left_pane_toggled), self);


            gtk_tree_view_append_column(GTK_TREE_VIEW(self->_priv->treeview1), column);
            
            /* TAGS */
            column = gtk_tree_view_column_new();
            /* Tag name */
            self->_priv->treeview1_renderer = renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, TRUE);
            gtk_tree_view_column_set_attributes(column, renderer, "text", 1, NULL);
            g_object_set(renderer, "editable", TRUE,NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_left_pane_edited), self);

            /* Number of items */
            renderer = gtk_cell_renderer_text_new();
            g_object_set(G_OBJECT(renderer), 
                    "background-set", TRUE, "background-gdk",&(GTK_WIDGET(self->_priv->treeview1)->style->bg[GTK_STATE_SELECTED]), 
                    "foreground-set", TRUE, "foreground-gdk",&(GTK_WIDGET(self->_priv->treeview1)->style->fg[GTK_STATE_SELECTED]), 
                    NULL);
            g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_style_changed), renderer);            


            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE);
            gtk_tree_view_column_set_attributes(column, renderer, "text", 4, NULL);

            gtk_tree_view_append_column(GTK_TREE_VIEW(self->_priv->treeview1), column);

            g_signal_connect_swapped(G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview1))),
                            "changed", 
                            G_CALLBACK(self_treeview1_selection_changed), 
                            self);

            gtk_combo_box_set_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB), 0);


            renderer = gtk_cell_renderer_text_new();
            gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(self->_priv->cb_search), renderer, TRUE);
            gtk_cell_layout_add_attribute(GTK_CELL_LAYOUT(self->_priv->cb_search), renderer, "text", 1);

            gtk_combo_box_set_active(GTK_COMBO_BOX(self->_priv->cb_search), 0);

            /** initial setup the list */

            /* update label */
            self_filter_model_row_inserted(self, NULL, NULL, NULL);


            /* update lock state */
            self_backend_locked(self, NULL, self->_priv->skdbg);


            node = stuffkeeper_plugin_manager_get_loaded_plugins(STUFFKEEPER_PLUGIN_MANAGER(spm)); 
            if(node){
                GtkWidget *parent = glade_xml_get_widget(self->_priv->xml, "menuitem_tools");
                GtkWidget *menu = gtk_menu_new();
                gtk_menu_item_set_submenu(GTK_MENU_ITEM(parent), menu);
                for(iter = node;iter;iter = g_list_next(iter))
                {
                    StuffkeeperPlugin *plugin = iter->data; 
                    if(stuffkeeper_plugin_get_plugin_type(plugin)&PLUGIN_MENU)
                    {
                        gint width = 16, height=16;
                        GtkWidget *item = gtk_image_menu_item_new_with_label(stuffkeeper_plugin_get_name(plugin));
                        GdkPixbuf *pb = stuffkeeper_plugin_get_icon(plugin);

                        gtk_icon_size_lookup(GTK_ICON_SIZE_MENU, &width, &height);
                        if(pb)
                        {

                            GdkPixbuf *scale = gdk_pixbuf_scale_simple(pb,width, height, GDK_INTERP_BILINEAR);
                            gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(item),gtk_image_new_from_pixbuf(scale));
                            g_object_unref(scale);
                        }
                        gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
                        g_object_set_data(G_OBJECT(item), "plugin",plugin); 
                        g_signal_connect_swapped(G_OBJECT(item), "activate", G_CALLBACK(self_tool_activate), self);
                    }
                }
                gtk_widget_show_all(menu);
            }
            if(node)
                g_list_free(node);


            gtk_widget_show(self->_priv->win);
        }
        private
        void
        tool_activate(self,GtkWidget *item)
        {
            StuffkeeperPlugin *plugin = g_object_get_data(G_OBJECT(item), "plugin");
            if(plugin)
            {
                stuffkeeper_plugin_run_menu(STUFFKEEPER_PLUGIN(plugin),self->_priv->skdbg);
            }
        }

        override (G:Object)
        void
        finalize(G:Object *obj)
        {
            int value;
            Self *self = SELF(obj);
            debug_printf("** Finalize stuffkeeper interface\n");
            if(self->_priv->signal_backend_locked) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_backend_locked);
                self->_priv->signal_backend_locked = 0;
            }
            if(self->_priv->signal_schema_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_schema_added);
                self->_priv->signal_schema_added = 0;
            }
            if(self->_priv->signal_schema_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_schema_changed);
                self->_priv->signal_schema_changed = 0;
            }
            if(self->_priv->signal_schema_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_schema_removed);
                self->_priv->signal_schema_removed = 0;
            }

            if(self->_priv->signal_item_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_item_added);
                self->_priv->signal_item_added = 0;
            }
            if(self->_priv->signal_item_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_item_changed);
                self->_priv->signal_item_changed = 0;
            }
            if(self->_priv->signal_item_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_item_removed);
                self->_priv->signal_item_removed = 0;
            }
            if(self->_priv->signal_search_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_search_added);
                self->_priv->signal_search_added = 0;
            }
            if(self->_priv->signal_search_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_search_changed);
                self->_priv->signal_search_changed = 0;
            }
            if(self->_priv->signal_search_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_search_removed);
                self->_priv->signal_search_removed = 0;
            }


            if(self->_priv->signal_tag_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_tag_added);
                self->_priv->signal_tag_added = 0;
            }
            if(self->_priv->signal_tag_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_tag_changed);
                self->_priv->signal_tag_changed = 0;
            }
            if(self->_priv->signal_tag_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_tag_removed);
                self->_priv->signal_tag_removed = 0;
            }
            if(self->_priv->search_timeout) {
                g_source_remove(self->_priv->search_timeout);
                self->_priv->search_timeout = 0;
            }
            value = gtk_paned_get_position(GTK_PANED(self->_priv->hpaned1));
            g_key_file_set_integer(self->config_file, "WINDOW", "hpane", value);
            value = gtk_paned_get_position(GTK_PANED(self->_priv->vpaned1));
            g_key_file_set_integer(self->config_file, "WINDOW", "vpane", value);
            gtk_window_get_size(GTK_WINDOW(self->_priv->win), &value, NULL);
            g_key_file_set_integer(self->config_file, "WINDOW", "width", value);
            gtk_window_get_size(GTK_WINDOW(self->_priv->win), NULL, &value);
            g_key_file_set_integer(self->config_file, "WINDOW", "height", value);
            /* position */
            gtk_window_get_position(GTK_WINDOW(self->_priv->win), &value, NULL);
            g_key_file_set_integer(self->config_file, "WINDOW", "x-pos", value);
            gtk_window_get_position(GTK_WINDOW(self->_priv->win), NULL, &value);
            g_key_file_set_integer(self->config_file, "WINDOW", "y-pos", value);

            value =  gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(self->_priv->show_item_pane_menu_item));
            g_key_file_set_integer(self->config_file, "WINDOW", "show-item-pane", value);


            gtk_widget_destroy(self->_priv->win);
            
            if(self->_priv->xml)
            {
                g_object_unref(self->_priv->xml);
            }

            if(self->_priv->model_schemas)
            {
                g_object_unref(self->_priv->model_schemas);
                self->_priv->model_schemas = NULL;
            }
            PARENT_HANDLER(obj);
        }
        /**
         * Item popup
         */
        public
        void
        interface_item_open(self)
        {
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection,&model, &iter))
            {
                StuffkeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    self_popup_item(self, item);
                }                                                          
            }
        }

        public 
        void
        item_row_activated(self, GtkTreePath *path, GtkTreeViewColumn *column, GtkTreeView *view)
        {

            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            debug_printf("item row activated\n");
            if(gtk_tree_model_get_iter(model,&iter, path)) 
            {
                StuffkeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    self_popup_item(self, item);
                }
            }
        }

        /**
         * Popup an item list
         * TODO: Check it item is destroyed, and if it is remove the window
         */
        public
        void 
        popup_item(self, Stuffkeeper:Data:Item *item)
        {
            stuffkeeper_item_window_new(self->_priv->skdbg, item,self->config_file);

        }

    private
    void
        ___glade_xml_connect_foreach(const gchar *handler_name,
                GObject *object,
                const gchar *signal_name,
                const gchar *signal_data,
                GObject *connect_object,
                gboolean after,
                gpointer user_data)
        {
            static GModule * allsymbols = NULL;

            if (!allsymbols) allsymbols = g_module_open(NULL, 0);
            if (allsymbols) {
                gchar * func_name = g_strdup_printf("stuffkeeper_interface_%s", handler_name);
                GCallback func;

                if (!g_module_symbol(allsymbols, func_name, (gpointer)&func)){
                    if (!g_module_symbol(allsymbols, handler_name, (gpointer)&func)) {
                        g_warning("could not find signal handler '%s'.", func_name);
                        g_free(func_name);
                        return;
                    }
                }
                if (after)
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_AFTER | G_CONNECT_SWAPPED);
                else
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_SWAPPED);
                g_free(func_name);
            }
        }

        private 
        void
        dialog_activate_link(GtkAboutDialog *dialog, const gchar *uri, Self *self) 
        {
            open_url(uri);
        }
        private 
        void
        dialog_activate_email(GtkAboutDialog *dialog, const gchar *uri, Self *self) 
        {
            open_email(uri);
        }

        public
        void
        about_dialog(self)
        {
            GtkWidget *dialog = gtk_about_dialog_new();
            GdkPixbuf *pixbuf = NULL;
            /* set url handler */
            gtk_about_dialog_set_url_hook((GtkAboutDialogActivateLinkFunc)self_dialog_activate_link,self, NULL);
            gtk_about_dialog_set_email_hook((GtkAboutDialogActivateLinkFunc)self_dialog_activate_email,self, NULL);
            /* Set config time defines */
            gtk_about_dialog_set_program_name(GTK_ABOUT_DIALOG(dialog), PROGRAM_NAME);
            if(strlen(revision)>0)
            {
                gchar *str = g_strdup_printf("%s\n%s: %s", PROGRAM_VERSION, _("Revision"), revision);
                gtk_about_dialog_set_version(GTK_ABOUT_DIALOG(dialog),str);
                g_free(str);
            }
            else
            {
                gtk_about_dialog_set_version(GTK_ABOUT_DIALOG(dialog), PROGRAM_VERSION);
            }
            gtk_about_dialog_set_website(GTK_ABOUT_DIALOG(dialog), PROGRAM_WEBSITE); 

            gtk_about_dialog_set_copyright(GTK_ABOUT_DIALOG(dialog), _("Copyright 2008 Qball Cow"));
            gtk_about_dialog_set_license(GTK_ABOUT_DIALOG(dialog),
                    _("GNU General Public License"));


            pixbuf = gtk_icon_theme_load_icon (gtk_icon_theme_get_default (), "stuffkeeper", 64, 0, NULL);
            gtk_about_dialog_set_logo(GTK_ABOUT_DIALOG(dialog),pixbuf);


            gtk_about_dialog_set_artists(GTK_ABOUT_DIALOG(dialog),artists);
            gtk_about_dialog_set_authors(GTK_ABOUT_DIALOG(dialog),authors);
            gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG(dialog), _("translator-credits"));

            gtk_dialog_run(GTK_DIALOG(dialog));
            gtk_widget_destroy(dialog);

        }
        /** 
         * Backup
         */
        public
        void
        filename_changed(self, GtkWidget *entry)
        {
            GladeXML *xml =glade_get_widget_tree(entry);
            GtkWidget *button =  glade_xml_get_widget(xml,"save_button"); 
            const gchar *text = gtk_entry_get_text(GTK_ENTRY(entry));
            gtk_widget_set_sensitive(button, (strlen(text) > 0)?TRUE:FALSE);
        }

        public
        void
        make_backup(self)
        {
            GladeXML *xml = glade_xml_new(PACKAGE_DATADIR"/stuffkeeper.glade","dialog_backup",NULL);
            GtkWidget *dialog = glade_xml_get_widget(xml,"dialog_backup");

            glade_xml_signal_autoconnect_full(xml, (GladeXMLConnectFunc)self____glade_xml_connect_foreach, (gpointer)self);
            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case -5:
                    {
                        gchar *directory = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(glade_xml_get_widget(xml, "location_chooser")));
                        GtkWidget *entry = glade_xml_get_widget(xml, "entry_filename"); 
                        const gchar *file = gtk_entry_get_text(GTK_ENTRY(entry)); 
                        const gchar *source = stuffkeeper_data_backend_get_path(self->_priv->skdbg);
                        if(file)                                                                                      
                        {
                            gchar *suffix = g_path_get_dirname(directory);
                            gchar *exec = g_strdup_printf("tar -cz -C '%s' -f '%s%c%s.tar.gz' '.'",source, directory,G_DIR_SEPARATOR,file);
                            g_spawn_command_line_async(exec, NULL);
                            g_free(suffix);
                            g_free(exec);
                            g_free(directory);
                        }
                    }
                default:
                    break;
            }
            gtk_widget_destroy(dialog);
            g_object_unref(xml);
        }

        public
        void
        restore_backup(self)
        {
            GtkWidget *dialog = NULL;
            
            dialog = gtk_message_dialog_new_with_markup(
            GTK_WINDOW(self->_priv->win), 
            GTK_DIALOG_DESTROY_WITH_PARENT,
            GTK_MESSAGE_WARNING,
            GTK_BUTTONS_OK_CANCEL,
            _("Restoring from a backup will destroy the current database.\nUse with care."));

            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case GTK_RESPONSE_CANCEL:
                    gtk_widget_destroy(dialog);
                    return;
                default:
                    gtk_widget_destroy(dialog);
            }


            dialog = gtk_file_chooser_dialog_new("Open archive", 
                        NULL, 
                        GTK_FILE_CHOOSER_ACTION_OPEN,
                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                        GTK_STOCK_OPEN, GTK_RESPONSE_OK, 
                        NULL);
            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case GTK_RESPONSE_OK:
                {
                    const gchar *directory= stuffkeeper_data_backend_get_path(self->_priv->skdbg);
                    gchar *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
                    if(filename)
                    {
                        gchar *exec = g_strdup_printf("tar -zxf '%s' -C '%s' ",filename, directory);
                        gchar *path = g_strdup(stuffkeeper_data_backend_get_path(self->_priv->skdbg));
                        stuffkeeper_data_backend_close_yourself(self->_priv->skdbg);
                        g_spawn_command_line_sync(exec,NULL, NULL, NULL,NULL);
                        g_free(exec);
                        g_free(filename);
                        stuffkeeper_data_backend_load(self->_priv->skdbg, path);


                        g_free(path);
                    }
                }
                default:
                    break;

            }
            gtk_widget_destroy(dialog);
        }


        public
        void
        reload(self)
        {
            gchar *path = g_strdup(stuffkeeper_data_backend_get_path(self->_priv->skdbg));
            stuffkeeper_data_backend_close_yourself(self->_priv->skdbg);
            stuffkeeper_data_backend_load(self->_priv->skdbg, path);
            g_free(path);
        }
        public
            void
            visit_homepage(self)
            {
                open_url(PROGRAM_WEBSITE);
            }
        public
            void
            visit_bugtracker(self)
            {
                open_url(PROGRAM_BUGTRACKER);
            }



        /**
         * HTML Export 
         */
        /* Export the whole db */
        public
        void
        export_to_html(self)
        {
            stuffkeeper_export_html_new_schema(self,self->_priv->skdbg,GTK_LIST_STORE(self->_priv->model_schemas));
        }

        /* export selected item */
        public
        void
        export_html_item(self)
        {
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkWidget *tree = self->_priv->treeview2;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {
                StuffkeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    stuffkeeper_export_html_new(self,self->_priv->skdbg,STUFFKEEPER_DATA_ITEM(item));
                    return;
                }
            }
        }
        
        /**
         * Search new 
         */
        public
        void 
        new_search(self)
        {
            gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
            if(locked){printf("**ERROR** should not be callable\n");return;}
            StuffkeeperDataItemSearch *search = stuffkeeper_data_backend_new_search(self->_priv->skdbg);
            stuffkeeper_data_item_search_edit_search_gui(search);
        }

        public
        void
        remove_search(self)
        {
            gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
            if(locked){printf("**ERROR** should not be callable\n");return;}
            GtkTreeIter iter;
            if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->_priv->cb_search), &iter))
            {
                StuffkeeperDataItemSearch *search;
                gint id;
                gtk_tree_model_get(self->_priv->model_searches, &iter,0,&id, 3, &search, -1);
                if(search && id != -1)
                {
                    stuffkeeper_data_backend_remove_search(self->_priv->skdbg, id);
                }
            }


        }
        public
            void
        edit_search(self)
        {
            gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
            if(locked){printf("**ERROR** should not be callable\n");return;}
            GtkTreeIter iter;
            if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->_priv->cb_search), &iter))
            {
                StuffkeeperDataItemSearch *search;
                gint id;
                gtk_tree_model_get(self->_priv->model_searches, &iter,0,&id, 3, &search, -1);
                if(search && id != -1)
                {
                    stuffkeeper_data_item_search_edit_search_gui(search);
                }
            }


        }



        public
        void
        remove_search_menu(self, GtkWidget *menu_item)
        {
            gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
            if(locked){printf("**ERROR** should not be callable\n");return;}
            StuffkeeperDataItemSearch *search;
            search = g_object_get_data(G_OBJECT(menu_item), "search");
            if(search) 
            {
                gint id = stuffkeeper_data_item_search_get_id(search);
                stuffkeeper_data_backend_remove_search(self->_priv->skdbg, id);
            }
        }
        public
        void
        edit_search_menu(self,GtkWidget *menu_item)
        {
            gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
            if(locked){printf("**ERROR** should not be callable\n");return;}
            StuffkeeperDataItemSearch *search;
            search = g_object_get_data(G_OBJECT(menu_item), "search");
            if(search)
            {
                stuffkeeper_data_item_search_edit_search_gui(search);
            }
        }

        private
        void
        treeview1_selection_changed(self, GtkTreeSelection *selection)
        {
        }
        /**
         * Sorting
         */
        public 
            void
        sort_item_descending(self,GtkRadioButton *style)
        {
            g_key_file_set_integer(self->config_file, "WINDOW", "item-sort-order", GTK_SORT_DESCENDING);
            self->_priv->item_sort_order = GTK_SORT_DESCENDING;
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_items),
                    self->_priv->item_sort_column,
                    self->_priv->item_sort_order);
        }

        public 
            void
        sort_item_ascending(self,GtkRadioButton *style)
        {
            g_key_file_set_integer(self->config_file, "WINDOW", "item-sort-order", GTK_SORT_ASCENDING);
            self->_priv->item_sort_order = GTK_SORT_ASCENDING;
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_items),
                    self->_priv->item_sort_column,
                    self->_priv->item_sort_order);
        }
        public 
        void
        sort_item_by_modification_time(self,GtkRadioButton *style)
        {
            g_key_file_set_integer(self->config_file, "WINDOW", "item-sort-column", 5);
            self->_priv->item_sort_column = 5;
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_items),
                    self->_priv->item_sort_column,
                    self->_priv->item_sort_order);
        }

        public 
        void
        sort_item_by_creation_time(self,GtkRadioButton *style)
        {
            g_key_file_set_integer(self->config_file, "WINDOW", "item-sort-column", 3);
            self->_priv->item_sort_column = 3;
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_items),
                    self->_priv->item_sort_column,
                    self->_priv->item_sort_order);
        }
        public 
        void
        sort_item_by_title(self,GtkRadioButton *style)
        {
            g_key_file_set_integer(self->config_file, "WINDOW", "item-sort-column", 1);
            self->_priv->item_sort_column = 1;
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_items),
                    self->_priv->item_sort_column,
                    self->_priv->item_sort_order);
        }
        public 
        void
        sort_item_by_schema(self,GtkRadioButton *style)
        {
            g_key_file_set_integer(self->config_file, "WINDOW", "item-sort-column", 4);
            self->_priv->item_sort_column = 4;
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_items),
                    self->_priv->item_sort_column,
                    self->_priv->item_sort_order);
        }
        /* storing saving schemas */
        private
        void
        schema_style_set(GtkWidget *event, GtkStyle *style, GladeXML *xml)
        {
            GtkWidget *dialog = glade_xml_get_widget(xml,"export_schema_dialog");
            GtkWidget *event = glade_xml_get_widget(xml, "eventbox_schema");
            GtkWidget *label =  glade_xml_get_widget(xml, "label_title_schema");
            gtk_widget_modify_bg(event,
                    GTK_STATE_NORMAL, 
                    &((dialog)->style->bg[GTK_STATE_SELECTED]));
            gtk_widget_modify_text(label,
                              GTK_STATE_NORMAL, 
                              &((dialog)->style->text[GTK_STATE_SELECTED]));
            gtk_widget_modify_fg(label,
                    GTK_STATE_NORMAL, 
                              &((dialog)->style->fg[GTK_STATE_SELECTED]));
            
        }


        public
        void
        schema_new(self)
        {
            gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
            if(locked){printf("**ERROR** should not be callable\n");return;}

            StuffkeeperDataSchema *schema = stuffkeeper_data_backend_new_schema(self->_priv->skdbg);
            StuffkeeperEditSchema *skes = stuffkeeper_edit_schema_new();
            stuffkeeper_edit_schema_set_schema(skes, schema);
        }

        public
        void
        schema_import(self)
        {
            gboolean locked = stuffkeeper_data_backend_get_locked(self->_priv->skdbg);
            if(locked){printf("**ERROR** should not be callable\n");return;}

           GtkFileFilter *filter = NULL;
            GtkWidget *dialog = gtk_file_chooser_dialog_new(_("Import type"), 
                    NULL, 
                    GTK_FILE_CHOOSER_ACTION_OPEN,
                    GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                    GTK_STOCK_OPEN, GTK_RESPONSE_OK, 
                    NULL);
            filter = gtk_file_filter_new();
            gtk_file_filter_set_name(filter, _("Types files"));
            gtk_file_filter_add_pattern(filter, "*.type");
            gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), filter);


            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case GTK_RESPONSE_OK:
                {
                    gchar *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
                    stuffkeeper_data_backend_load_from_xml(self->_priv->skdbg,filename);
                    g_free(filename);
                }
                default:
                    break;
            }
            gtk_widget_destroy(dialog);
        }
    
        public
        void
        entry_changed(GtkWidget *entry, GtkWidget *button)
        {
            const gchar *text = gtk_entry_get_text(GTK_ENTRY(entry));
            if(text[0] == '\0') {
                gtk_widget_set_sensitive(button, FALSE);
            } else {
                gtk_widget_set_sensitive(button, TRUE);
            }
        }

        public
        void
        schema_export(self)
        {
            GtkCellRenderer *renderer;
            GtkWidget *entry, *cb_schema;
            GladeXML *xml = glade_xml_new(PACKAGE_DATADIR"/stuffkeeper.glade","export_schema_dialog",NULL);
            GtkWidget *dialog = glade_xml_get_widget(xml,"export_schema_dialog");

            g_signal_connect(G_OBJECT(dialog), "style-set", G_CALLBACK(self_schema_style_set),xml);

            /* entry */
            entry = glade_xml_get_widget(xml, "entry_name");
            g_signal_connect(G_OBJECT(entry), "changed", G_CALLBACK(self_entry_changed), glade_xml_get_widget(xml, "save_button1"));
            cb_schema = glade_xml_get_widget(xml, "cb_schema");

            gtk_combo_box_set_model(GTK_COMBO_BOX(cb_schema), GTK_TREE_MODEL(self->_priv->model_schemas));
            gtk_combo_box_set_active(GTK_COMBO_BOX(cb_schema), 0);
            renderer = gtk_cell_renderer_text_new();
            gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(cb_schema),renderer, TRUE);
            gtk_cell_layout_add_attribute(GTK_CELL_LAYOUT(cb_schema),renderer, "text",1 );


            glade_xml_signal_autoconnect_full(xml, (GladeXMLConnectFunc)self____glade_xml_connect_foreach, (gpointer)self);
            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case -5:
                    {
                        GtkTreeIter iter;
                        gchar *directory = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(glade_xml_get_widget(xml, "fc_directory")));
                        const gchar *file = gtk_entry_get_text(GTK_ENTRY(entry)); 
                        if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(cb_schema),&iter))
                        {
                            gchar *path = NULL;
                            gchar *filename = g_strdup_printf("%s.type", file);
                            StuffkeeperDataSchema *schema = NULL;
                            /* get model schema */
                            gtk_tree_model_get(self->_priv->model_schemas, &iter,3, &schema, -1); 
                            /* build path */
                            path = g_build_path(G_DIR_SEPARATOR_S, directory, filename,NULL);
                            /* save it */
                            stuffkeeper_data_schema_save_to_xml(schema,path);
                            g_free(path);
                            g_free(filename);
                        }
                        g_free(directory);
                    }
                default:
                    break;
            }
            gtk_widget_destroy(dialog);
            g_object_unref(xml);
        }


        /**
         * First run 
         */
        public
        void
        first_run(self)
        {
            GDir *dir;
            GError *error = NULL;
            gchar *path = g_build_path(G_DIR_SEPARATOR_S,PACKAGE_DATADIR, "types",NULL);
            /* open the directory */
            dir = g_dir_open(path, 0, &error);
            if(error)
            {
                printf("Error opening: '%s': '%s'\n", path, error->message);
                g_error_free(error);
            }
            if(dir)
            {
                const char *filename = NULL;
                while((filename = g_dir_read_name(dir)))
                {
                    gchar *full_path = g_build_path(G_DIR_SEPARATOR_S,PACKAGE_DATADIR, "types",filename,NULL);
                    stuffkeeper_data_backend_load_from_xml(self->_priv->skdbg, full_path);
                    g_free(full_path);
                }
                g_dir_close(dir);
            }
            g_free(path);
        }
        public
        void
        present(self)
        {
            gtk_window_present(GTK_WINDOW(self->_priv->win));
        }
}
