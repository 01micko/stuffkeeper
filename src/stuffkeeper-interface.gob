requires 2.0.10

%h{
/* Include gtk */
#include <gtk/gtk.h>
#include <glib/gi18n.h>
#include <glade/glade.h>
#include "sexy-icon-entry.h"
#include "config.h"
#include "debug.h"
#include "misc.h"

/* Include the database */

#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-data-schema.h"
#include "stuffkeeper-data-item-search.h"
#include "stuffkeeper-edit-schema.h"
#include "stuffkeeper-show-item.h"
#include "stuffkeeper-item-window.h"
#include "stuffkeeper-export-csv.h"
#include "stuffkeeper-export-html.h"

#include "stuffkeeper-item-view.h"

extern GList *interface_list;
%}

%ph{
    const gchar *artists[] = {
        "Jakub Szypulka (http://cubestuff.wordpress.com )",
        "Tango Project (http://tango.freedesktop.org/ )",
    NULL};
    const gchar *authors[] = {
        "Martijn Koedam (qball) <Qball@Sarine.nl>", 
        "\nTester:",
        "Greg Fitzgerald",
    NULL};
%}

class StuffKeeper:Interface from G:Object 
{
    private GtkTreeModel *model_tags = {NULL};
    private GtkTreeModel *model_items= {NULL};
    private GtkTreeModel *model_schemas = {NULL};
    /* search items */
    private GtkTreeModel *model_searches = {NULL};

    private GtkTreeModel *model_items_filter = {NULL};
    private GKeyFile *config_file = {NULL};

    /* Menu */
    /* A hash list used to store the items, the item id is the hash key */
    /* Don't free the list */
    private GHashTable *schemas_items = {g_hash_table_new_full(g_int_hash, g_int_equal,g_free, NULL)} destroywith g_hash_table_destroy ;
    private GtkWidget *menu = {NULL};
    /**
     * Treeview 1 & 2
     */
     private GladeXML *xml;
     private GtkWidget *win;
    private GtkWidget *LeftPaneCB ;
    private GtkWidget *treeview1 ;
    private GtkWidget *treeview2 ;
    private GtkWidget *item_vbox ;
    
    private GtkWidget *LeftPane_edit ;
    private GtkWidget *AddMenuButton ;
    private GtkWidget *search_entry ;
    private GtkWidget *hpaned1;
    private GtkWidget *vpaned1;
    private GtkWidget *item_label;
    private GtkWidget *cb_search;

    private GtkWidget *item_view_container;
    private GtkWidget *show_item_pane_menu_item;

    private StuffKeeperDataBackend *skdbg = {NULL};
    /**
     * Fix so the signals are correctly destroy
     */
    private gulong signal_schema_added = {0};
    private gulong signal_schema_changed = {0};
    private gulong signal_schema_removed = {0};

    private gulong signal_tag_added = {0};
    private gulong signal_tag_changed = {0};
    private gulong signal_tag_removed = {0};

    private gulong signal_item_added = {0};
    private gulong signal_item_changed = {0};
    private gulong signal_item_removed = {0};
    
    private gulong search_timeout = {0};


    private gulong signal_search_added = {0};
    private gulong signal_search_changed = {0};
    private gulong signal_search_removed = {0};

    /**
     * Search added
     */
    public
    void
    search_changed(self, const SearchField *field, StuffKeeperDataItemSearch *search)
    {
        if(!field)
        {
            GtkTreeIter iter;
            GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->model_searches);
            gint id = stuffkeeper_data_item_search_get_id(search);
            if(gtk_tree_model_get_iter_first(model, &iter))
            {
                do{
                    gint oid;
                    gtk_tree_model_get(model, &iter, 0, &oid, -1);
                    if(oid == id)
                    {
                        gchar *title = stuffkeeper_data_item_search_get_title(search);
                        gtk_list_store_set(GTK_LIST_STORE(model), &iter, 1,title,-1);
                        g_free(title);
                    }
                }while(gtk_tree_model_iter_next(model, &iter));
            }
        }
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
    }

    public
    void
    search_added(self, StuffKeeperDataItemSearch *search,  StuffKeeperDataBackend *skdb)
    {
        GtkTreeIter iter;
        gtk_list_store_append(GTK_LIST_STORE(self->_priv->model_searches), &iter);
        gchar *title = stuffkeeper_data_item_search_get_title(search);
        gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_searches), &iter, 
                0, stuffkeeper_data_item_search_get_id(search),
                1, title,
                2, search,
                -1);
        g_free(title);
    }
    public
        void 
    search_removed(self, gint id, StuffKeeperDataBackend *skdb)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->model_searches);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
                    gtk_combo_box_set_active(GTK_COMBO_BOX(self->_priv->cb_search), 0);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }


    /**
     * Keep Schema's GtkListStore up2date
     */
    public
    void 
    schema_added(self, StuffKeeperDataSchema *schema,StuffKeeperDataBackend *skdb )
    {
        GtkTreeIter iter;
        gint id;
        gtk_list_store_append(GTK_LIST_STORE(self->_priv->model_schemas), &iter);
        gchar *title = stuffkeeper_data_schema_get_title(schema);
        gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_schemas), &iter, 
                    0, stuffkeeper_data_schema_get_id(schema),
                    1, title,
                    3, schema,
                    4, stuffkeeper_data_schema_num_items(schema),-1);



        id = stuffkeeper_data_schema_get_id(schema);
        if(schema)
        {
            GtkWidget *m = gtk_menu_item_new_with_label((title==NULL)?"n/a":title);
            gint *ide;
            ide = g_malloc0(sizeof(gint));
            *ide = id;
            g_hash_table_insert(self->_priv->schemas_items, ide, m); 
            /* menu */
            gtk_menu_shell_insert(GTK_MENU_SHELL(self->_priv->menu), m,-1);
            g_object_set_data(G_OBJECT(m), "schema", schema);
            g_signal_connect_swapped(G_OBJECT(m), "activate", G_CALLBACK(self_interface_item_add_menu_button), self);
            gtk_widget_show_all(self->_priv->menu);
        }
        g_free(title);
    }
    public
    void 
    schema_changed(self, StuffKeeperDataSchema *schema, StuffKeeperDataBackend *skdb)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->model_schemas);
        gint id = stuffkeeper_data_schema_get_id(schema);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_schema_get_title(schema);
                    gtk_list_store_set(GTK_LIST_STORE(model), &iter, 1,title, 4, stuffkeeper_data_schema_num_items(schema),-1);
                    g_free(title);
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
        debug_printf("schema changed: %i\n",id);
        GtkWidget *item = g_hash_table_lookup(self->_priv->schemas_items, &id);
        if(item) {
            gchar *name = stuffkeeper_data_schema_get_title(schema);
            GtkWidget *label = gtk_bin_get_child(GTK_BIN(item));
            gtk_label_set_text(GTK_LABEL(label), name);
            g_free(name);

        }

        model = GTK_TREE_MODEL(self->_priv->model_items);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                GtkTreePath *path = gtk_tree_model_get_path(model, &iter);
                gtk_tree_model_row_changed(model, path, &iter);
                gtk_tree_path_free(path);
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void 
    schema_removed(self, gint id, StuffKeeperDataBackend *skdb)
    {
        GtkTreeIter iter;
        GtkWidget *widget = NULL;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->model_schemas);


        widget = g_hash_table_lookup(self->_priv->schemas_items,&id);
        if(widget)
        {
            gtk_widget_destroy(widget);
            g_hash_table_remove(self->_priv->schemas_items,&id);
        }

        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    /**
     * Keep Tag's GtkListStore up2date
     */
    public
    void 
    tag_added(StuffKeeperDataBackend *skdb, StuffKeeperDataTag *tag, GtkTreeModel *store)
    {
        GtkTreeIter iter;
        gtk_list_store_append(GTK_LIST_STORE(store), &iter);
        gchar *title = stuffkeeper_data_tag_get_title(tag);
        gtk_list_store_set(GTK_LIST_STORE(store), &iter, 
                    0, stuffkeeper_data_tag_get_id(tag),
                    1,title,
                    3,tag, 
                    4, stuffkeeper_data_tag_num_items(tag),
                    -1);
        g_free(title);
    }
    public
    void 
    tag_changed(StuffKeeperDataBackend *skdb, StuffKeeperDataTag *tag, GtkTreeModel *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_tag_get_id(tag);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_tag_get_title(tag);
                    gtk_list_store_set(GTK_LIST_STORE(store), &iter, 
                            1,title, 
                            4, stuffkeeper_data_tag_num_items(tag),
                            -1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void 
    tag_removed(StuffKeeperDataBackend *skdb, gint id, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    /**
     * Item GtkListStore
     * Update the gtk-list-store with signals from the backend
     */
    public
    void
    item_removed(StuffKeeperDataBackend *skdb, gint id,StuffKeeperInterface *self) 
    {
        GtkTreeIter iter;
        GtkListStore *store = GTK_LIST_STORE(self->_priv->model_items);
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gchar *data = g_strdup_printf("%i", stuffkeeper_data_backend_get_num_items(skdb)-1);
        gtk_label_set_text(GTK_LABEL(self->_priv->item_label), data);
        g_free(data);




        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void
    item_added(StuffKeeperDataBackend *skdb, StuffKeeperDataItem *item, StuffKeeperInterface *self) 
    {
        GtkTreeIter iter;
        gchar *data;
        GtkListStore *store = GTK_LIST_STORE(self->_priv->model_items);
        gtk_list_store_append(GTK_LIST_STORE(store), &iter);
        gchar *title = stuffkeeper_data_item_get_title(item);
        gtk_list_store_set(GTK_LIST_STORE(store), &iter, 
                    0, stuffkeeper_data_item_get_id(item),
                    1, title, 
                    2, item,
                    3, stuffkeeper_data_item_get_creation_time(item),
                    -1);
        g_free(title);

        data = g_strdup_printf("%i", stuffkeeper_data_backend_get_num_items(skdb));
        gtk_label_set_text(GTK_LABEL(self->_priv->item_label), data);
        g_free(data);

    }
    public
    void
    item_changed(StuffKeeperDataBackend *skdb, const gchar *field, StuffKeeperDataItem *item, StuffKeeperInterface *self) 
    {
        GtkTreeIter iter;
        GtkListStore *store = GTK_LIST_STORE(self->_priv->model_items);
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_item_get_id(item);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_item_get_title(item);
                    gtk_list_store_set(store, &iter, 1,title, -1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    private
    void
    add_item(self, StuffKeeperDataSchema *schema)
    {
        GtkTreeIter iter;
        StuffKeeperDataItem *item = stuffkeeper_data_backend_new_item(self->_priv->skdbg,schema/*list->data*/);
        stuffkeeper_data_item_set_title(item,"New Item");
        if(gtk_tree_model_get_iter_first(self->_priv->model_tags, &iter))
        {
            do{
                StuffKeeperDataTag *tag = NULL;
                gboolean enabled;
                gtk_tree_model_get(GTK_TREE_MODEL(self->_priv->model_tags), &iter,2, &enabled, 3,&tag, -1); 
                if(enabled)
                {
                    stuffkeeper_data_item_add_tag(item, tag);
                }

            }while(gtk_tree_model_iter_next(self->_priv->model_tags, &iter));
        }

    }
    /**
     * Add item button clicked 
     */
    public
        void 
        interface_item_add(self,GtkWidget *button)
        {

            GList *list = stuffkeeper_data_backend_get_schemas(self->_priv->skdbg);
            /* check if there are schema's */
            if(list)
            {
                StuffKeeperDataSchema *schema = g_object_get_data(G_OBJECT(button), "schema");
                /* if there is no schema, get the first*/
                if(schema  == NULL || !STUFFKEEPER_IS_DATA_SCHEMA(schema))
                {
                    schema = list->data;
                }
                self_add_item(self, schema);
                g_list_free(list);
            }

        }

    public
        void 
        interface_item_add_menu_button(self, GtkWidget *button)
        {
            StuffKeeperDataSchema *schema = g_object_get_data(G_OBJECT(button), "schema");
            if(schema)
            {
                self_add_item(self, schema);
                /* Store last added item. */
                g_object_set_data(G_OBJECT(self->_priv->AddMenuButton), "schema", schema);
            }

        }





    /**
     * Remove selected item
     */
    public
        void interface_item_remove(self)
        {
            /** Setup a dialog that ask the user if he is sure */
            GtkWidget *tree = self->_priv->treeview2;//glade_xml_get_widget(xml, "treeview2");
            GtkWidget *dialog;
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree));
            GtkTreeModel *model = GTK_TREE_MODEL(gtk_tree_view_get_model(GTK_TREE_VIEW(tree)));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {

                dialog = gtk_message_dialog_new(GTK_WINDOW(self->_priv->win), 
                        GTK_DIALOG_DESTROY_WITH_PARENT|// This belongs to the parent, so if the user closes the parent, close it
                        GTK_DIALOG_MODAL, // It is a warning, it _should_ be modal.
                        GTK_MESSAGE_WARNING, // It is a warning message.
                        GTK_BUTTONS_YES_NO, // yes/no question
                        "Deleting an entry cannot be undone.\nAre you sure you want to continue?");
                switch(gtk_dialog_run(GTK_DIALOG(dialog)))
                {
                    case GTK_RESPONSE_YES:
                        {
                            gint id;
                            gtk_tree_model_get(model, &iter ,0,&id, -1);
                            stuffkeeper_data_backend_remove_item(self->_priv->skdbg, id);

                        }
                    default:
                        gtk_widget_destroy(dialog);
                }
            }
        }

    /**
     * Tag is enabled/disabled
     */
    public
        void 
        interface_left_pane_toggled(self, gchar *path, GtkCellRendererToggle *renderer)
        {
            GtkTreeIter iter;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gboolean value = !gtk_cell_renderer_toggle_get_active(renderer);
                gtk_list_store_set(GTK_LIST_STORE(model), &iter, 2,value,-1);

                /* refilter the items list */
                gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
            }
        }

    public
        void interface_item_title_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gint id;
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter ,0,&id, -1);
                item = stuffkeeper_data_backend_get_item(self->_priv->skdbg, id);
                if(item)
                {
                    stuffkeeper_data_item_set_title(item, new_text);
                }

            }
        }

    public
        void interface_left_pane_edited 
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )

        {
            GtkTreeIter iter;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                GObject *item;

                gtk_tree_model_get(model, &iter ,3,&item, -1);

                if(STUFFKEEPER_IS_DATA_TAG(item))
                {
                    stuffkeeper_data_tag_set_title(STUFFKEEPER_DATA_TAG(item), new_text);
                }else if (STUFFKEEPER_IS_DATA_SCHEMA(item)){
                    stuffkeeper_data_schema_set_title(STUFFKEEPER_DATA_SCHEMA(item), new_text);
                }
                

            }
        }
    /**
     * Quit the program
     */
    public
        void quit_program(void)
        {
            gtk_main_quit();
        }

    public 
    gboolean 
    close_window(self)
    {
        int n;
        interface_list = g_list_remove(interface_list, self);
        n = g_list_length(interface_list);
        g_object_unref(self);

        if(n == 0)
        {
           gtk_main_quit();
        }
        return TRUE;
    }
    public
    void
    new_window(self)
    {
        Self *ski;
        ski= stuffkeeper_interface_new(self->_priv->config_file);
        interface_list = g_list_append(interface_list, ski);
        stuffkeeper_interface_initialize_interface(ski,self->_priv->skdbg);
    }

    /**
     * Filtering the item list
     */
    public
        gboolean 
        interface_visible_func(GtkTreeModel *model, GtkTreeIter *iter, StuffKeeperInterface *self) 
        {
            GtkTreeModel *model2 = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            StuffKeeperDataItem *item;
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));
            const gchar *text = gtk_entry_get_text(GTK_ENTRY(self->_priv->search_entry));
            
            
            
            
            /* Get the item */
            gtk_tree_model_get(model, iter, 2,&item, -1);


            if(!item) {
                return FALSE;
            }

            GtkTreeIter piter;
            if(gtk_tree_model_get_iter_first(model2, &piter))
            {
                int found = -1;
                do{
                    GObject *tag;
                    gboolean sel;
                    /* get the tag, and if it is selected */
                    gtk_tree_model_get(model2, &piter,2,&sel, 3,&tag, -1);

                    if(sel && tag)
                    {
                        if(type == 0 && !stuffkeeper_data_item_has_tag(item, STUFFKEEPER_DATA_TAG(tag)))
                        {
                            return FALSE;
                        }
                        /* if viewing types, and it matches mark found */
                        else if (type == 1 && 
                            stuffkeeper_data_schema_get_id(stuffkeeper_data_item_get_schema(item)) == 
                            stuffkeeper_data_schema_get_id(STUFFKEEPER_DATA_SCHEMA(tag)))
                        {
                            found = 1;
                        }
                        /* set that there are items selected */
                        else if (type == 1 && found == -1)
                        {
                            found = 0;
                        }
                    }

                }while(gtk_tree_model_iter_next(model2, &piter));
                /* if viewing types and no selected item matches return FALSE */
                if(type == 1 && found == 0)
                {
                    return FALSE;
                }
            }
            {
                GtkTreeIter iter;
                if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->_priv->cb_search), &iter))
                {
                    StuffKeeperDataItemSearch *search;
                    gtk_tree_model_get(self->_priv->model_searches, &iter, 2, &search, -1);
                    if(search)
                    {
                        if(!stuffkeeper_data_item_search_match(search, item))
                        {
                            return FALSE;
                        }
                    }
                }


            }

            if(strlen(text) > 0)
            {
                return stuffkeeper_data_item_has_value(item,text); 

            }
            return TRUE;
        }
    private
    gboolean
    search_entry_changed_timeout(self)
    {
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));

        self->_priv->search_timeout =0;
        /* remove it */
        return FALSE;
    }
    
    public
    void
    search_entry_changed(self)
    {
        if(self->_priv->search_timeout) {
            g_source_remove(self->_priv->search_timeout);
            self->_priv->search_timeout = 0;
        }
        self->_priv->search_timeout = g_timeout_add(1000,(GSourceFunc)self_search_entry_changed_timeout, self);
    }
   
    private 
    void
    schema_edit_button_clicked(self, GtkWidget *button)
    {
        StuffKeeperDataSchema *schema = g_object_get_data(G_OBJECT(button), "schema");
        if(schema)
        {
            StuffKeeperEditSchema *skes = stuffkeeper_edit_schema_new();
            stuffkeeper_edit_schema_set_schema(skes, schema);
        }
    }
    private 
        void
        interface_background_changed(GtkWidget *widget, GtkStyle *old, GtkWidget *wid)
        {
            g_signal_handlers_block_by_func(G_OBJECT(widget), self_interface_background_changed, wid);
            gtk_widget_modify_bg(wid, GTK_STATE_NORMAL, &(widget->style->light[GTK_STATE_NORMAL]));
            g_signal_handlers_unblock_by_func(G_OBJECT(widget),self_interface_background_changed, wid);
        }

    public
    void
    item_pane_checkbox(self,GtkCheckMenuItem *item)
    {
        self_interface_item_selection_changed(self, gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2)));
    }

    public
        void 
        interface_item_selection_changed (self, GtkTreeSelection *selection)
        {

            GtkTreeModel *model;
            GtkTreeIter iter;
            GList *list;
            gboolean show_pane = gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(self->_priv->show_item_pane_menu_item));

            list = gtk_container_get_children(GTK_CONTAINER(self->_priv->item_view_container));
            if(list)
            {
                GList *node;
                for(node = g_list_first(list); node; node = g_list_next(node))
                {
                    gtk_widget_destroy(GTK_WIDGET(node->data));
                }
                g_list_free(list);
            }
            if(!show_pane)
            {
                gtk_widget_hide(self->_priv->item_view_container);
                return;
            }


            model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    GtkWidget *wid = stuffkeeper_item_view_new(item);
                    gtk_container_add(GTK_CONTAINER(self->_priv->item_view_container), wid);
                    gtk_widget_show_all(self->_priv->item_view_container);
                }
            }
            else
            {
                GtkWidget *frame = gtk_frame_new(NULL);
                GtkWidget *label = gtk_label_new("");
                GtkWidget *event = gtk_event_box_new();
                gtk_frame_set_shadow_type(GTK_FRAME(frame), GTK_SHADOW_ETCHED_IN);
                g_signal_connect(G_OBJECT(event), "style-set", G_CALLBACK(self_interface_background_changed), event);
                gtk_label_set_markup(GTK_LABEL(label), "<b>No item to preview, select an item from the item list to preview it</b>");
                gtk_container_add(GTK_CONTAINER(frame),label);
                gtk_container_add(GTK_CONTAINER(event),frame);
                gtk_container_add(GTK_CONTAINER(self->_priv->item_view_container), event);
                gtk_widget_show_all(self->_priv->item_view_container);
            }
            return;
        }

     /**
     * Right mouse handling left treeview
     */
    /**
     * Label signals
     */
     private
     void
     add_tag(self, GtkMenuItem *item)
     {
         StuffKeeperDataTag *tag = stuffkeeper_data_backend_new_tag(self->_priv->skdbg);
         stuffkeeper_data_tag_set_title(tag, "New Tag");
     }
     private 
     void
     remove_tag(self, GtkMenuItem *item)
     {
         GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeIter iter;
         if(gtk_tree_selection_get_selected(selection,&model, &iter))
         {
             gint items;
             gint id;
             /* Get id and items */
             gtk_tree_model_get(model, &iter,0,&id,4,&items, -1);

             if(items == 0)
             {
                 stuffkeeper_data_backend_remove_tag(self->_priv->skdbg,id);
             }
         }
     }
    /* Types */

     private
     void
     add_type(self, GtkMenuItem *item)
     {
         StuffKeeperDataSchema *schema = stuffkeeper_data_backend_new_schema(self->_priv->skdbg);
         stuffkeeper_data_schema_set_title(schema, "New Schema");
     }
     private 
     void
     remove_type(self, GtkMenuItem *item)
     {
         GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeIter iter;
         if(gtk_tree_selection_get_selected(selection,&model, &iter))
         {
             gint items;
             gint id;
             /* Get id and items */
             gtk_tree_model_get(model, &iter,0,&id,4,&items, -1);

             if(items == 0)
             {
                 stuffkeeper_data_backend_remove_schema(self->_priv->skdbg,id);
             }
         }


     }
     private 
     void
     edit_type(self, GtkMenuItem *item)
     {
         GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
         GtkTreeIter iter;
         if(gtk_tree_selection_get_selected(selection,&model, &iter))
         {
             StuffKeeperDataSchema *schema;
             gtk_tree_model_get(model, &iter, 3, &schema, -1);
             if(schema)
             {
                 StuffKeeperEditSchema *skes = stuffkeeper_edit_schema_new();
                 stuffkeeper_edit_schema_set_schema(skes, schema);
             }
         }
     }
    
    /* right mouse menu item treeview */
    public
    gboolean 
    treeview2_button_press_event(self, GdkEventButton *event, GtkWidget *widget)
    {
        debug_printf("treeview2 buttom press event\n");
        if(event->button == 3)
        {
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection,&model, &iter))
            {
                GtkWidget *menu;                
                GtkWidget *menu_item;
                /* create menu */
                menu = gtk_menu_new();

                menu_item = gtk_image_menu_item_new_from_stock(GTK_STOCK_OPEN, NULL);
                g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_interface_item_open), self);
                gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);

                menu_item = gtk_image_menu_item_new_from_stock(GTK_STOCK_REMOVE, NULL);
                g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_interface_item_remove), self);
                gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);


                menu_item = gtk_image_menu_item_new_with_label("Export to html");
                gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), gtk_image_new_from_stock(GTK_STOCK_SAVE, GTK_ICON_SIZE_MENU));
                g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_export_html_item), self);
                gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                /* popup the menu */
                gtk_widget_show_all(menu);

                gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, event->button, event->time);
                return FALSE;
            }
        }
        return FALSE;
    }



    /* Right mouse button press */
    public 
    gboolean
    treeview1_button_press_event(self, GdkEventButton *event, GtkWidget *widget)
    {

        /* Right mouse click, ignore rest */
        if(event->button == 3)
        {
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview1));
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            GtkTreeIter iter;
            GtkWidget *menu;
            GtkWidget *menu_item;

            debug_printf("treeview 1 button press event\n");
            /* Create menu */
            menu = gtk_menu_new();

            if(type == 0)
            {
                /* Add tag */
                menu_item = gtk_image_menu_item_new_with_label("New tag");
                gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                        gtk_image_new_from_stock(GTK_STOCK_ADD, GTK_ICON_SIZE_MENU));
                g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_add_tag), self);
                gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                if(gtk_tree_selection_get_selected(selection,&model, &iter))
                {
                    int items;
                    /* Get the number of items */
                    gtk_tree_model_get(model, &iter, 4, &items, -1);
            
                    /* no items, then you can delete it*/
                    if(items ==  0)
                    {
                        menu_item = gtk_image_menu_item_new_with_label("Remove tag");
                        gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                                gtk_image_new_from_stock(GTK_STOCK_REMOVE, GTK_ICON_SIZE_MENU));
                        g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_remove_tag),self);
                        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);

                    }
                }

            }
            else 
            {
                /* Add item */
                menu_item = gtk_image_menu_item_new_with_label("New type");
                gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                        gtk_image_new_from_stock(GTK_STOCK_ADD, GTK_ICON_SIZE_MENU));
                g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_add_type), self);
                gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                if(gtk_tree_selection_get_selected(selection,&model, &iter))
                {
                    int items;
                    /* Get the number of items */
                    gtk_tree_model_get(model, &iter, 4, &items, -1);

                    /* no items, then you can delete it*/
                    if(items ==  0)
                    {
                        menu_item = gtk_image_menu_item_new_with_label("Remove type");
                        gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                                gtk_image_new_from_stock(GTK_STOCK_REMOVE, GTK_ICON_SIZE_MENU));
                        g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_remove_type),self);
                        gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);
                    }
                    menu_item = gtk_image_menu_item_new_with_label("Edit type");
                    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(menu_item), 
                            gtk_image_new_from_stock(GTK_STOCK_EDIT, GTK_ICON_SIZE_MENU));
                    g_signal_connect_swapped(G_OBJECT(menu_item), "activate", G_CALLBACK(self_edit_type),self);
                    gtk_menu_shell_append(GTK_MENU_SHELL(menu), menu_item);

                }

            }

            /* popup the menu */
            gtk_menu_popup(GTK_MENU(menu), NULL, NULL, NULL, NULL, event->button, event->time);
            /* show the widget */
            gtk_widget_show_all(menu);
            /* don't pass message */
            return TRUE;
        }
        return FALSE;
    }

    public
        StuffKeeperInterface * 
        new(GKeyFile *config_file)
        {
            int value,width,height;
            GError *error = NULL;
            Self *self = GET_NEW;

            self->_priv->xml = glade_xml_new(PACKAGE_DATADIR"/stuffkeeper.glade","win",NULL);

            self->_priv->config_file = config_file;

            if(self->_priv->xml == NULL)
            {
                g_object_unref(self);
                debug_printf("Failed top open xml file\n");
                return NULL;
            }
            self->_priv->hpaned1 =  glade_xml_get_widget(self->_priv->xml, "hpaned1");
            self->_priv->vpaned1 =  glade_xml_get_widget(self->_priv->xml, "vpaned1");
            self->_priv->LeftPaneCB  = glade_xml_get_widget(self->_priv->xml, "LeftPaneCB");
            self->_priv->treeview1 = glade_xml_get_widget(self->_priv->xml, "treeview1");
            self->_priv->treeview2 = glade_xml_get_widget(self->_priv->xml, "treeview2");
            self->_priv->item_vbox = glade_xml_get_widget(self->_priv->xml, "item_vbox");

            self->_priv->LeftPane_edit = glade_xml_get_widget(self->_priv->xml, "LeftPane_edit");
            self->_priv->AddMenuButton = glade_xml_get_widget(self->_priv->xml, "AddMenuButton");

            self->_priv->item_label = glade_xml_get_widget(self->_priv->xml, "item_label");
            self->_priv->item_view_container = glade_xml_get_widget(self->_priv->xml, "item_view_container");
            self->_priv->show_item_pane_menu_item = glade_xml_get_widget(self->_priv->xml, "show_item_pane_menu_item");
            
             self->_priv->cb_search = glade_xml_get_widget(self->_priv->xml, "cb_search");
            
            self->_priv->win = glade_xml_get_widget(self->_priv->xml, "win");


            gtk_widget_hide_on_delete(self->_priv->win);

            /**
             * Custom search widget, glade does not support, sexy-icon and screws up alignment 
             */
            /* sexy icon + setup */
            self->_priv->search_entry = sexy_icon_entry_new();
            /* Add clear button */
            sexy_icon_entry_add_clear_button(SEXY_ICON_ENTRY(self->_priv->search_entry));
            /* Add find icon */
            sexy_icon_entry_set_icon(SEXY_ICON_ENTRY(self->_priv->search_entry),SEXY_ICON_ENTRY_PRIMARY, 
                GTK_IMAGE(gtk_image_new_from_stock(GTK_STOCK_FIND, GTK_ICON_SIZE_MENU)));

            gtk_box_pack_end(GTK_BOX(glade_xml_get_widget(self->_priv->xml,"hbox3")), self->_priv->search_entry, FALSE, TRUE,0);
            g_signal_connect_swapped(G_OBJECT(self->_priv->search_entry), "changed", G_CALLBACK(self_search_entry_changed), self);

            gtk_widget_show_all(GTK_WIDGET(self->_priv->search_entry));

            /* read config */
            value = g_key_file_get_integer(self->_priv->config_file, "WINDOW", "hpane", &error);
            if(error ) {
                debug_printf("No valid pane position: %s\n", error->message);
                /* Free error */
                g_error_free(error);
                error = NULL;
            }
            else if(value > 50)
            {
                debug_printf("Setting position: %i\n", value);
                gtk_paned_set_position(GTK_PANED(self->_priv->hpaned1), value);
            }
            value = g_key_file_get_integer(self->_priv->config_file, "WINDOW", "vpane", &error);
            if(error ) {
                debug_printf("No valid vpane position: %s\n", error->message);
                /* Free error */
                g_error_free(error);
                error = NULL;
            }
            else if(value > 50)
            {
                debug_printf("Setting position: %i\n", value);
                gtk_paned_set_position(GTK_PANED(self->_priv->vpaned1), value);
            }
            /* Restore size and position */

            width = g_key_file_get_integer(self->_priv->config_file, "WINDOW", "width", &error);
            if(error) {
                g_error_free(error);
                error = NULL;
            } else {
                height = g_key_file_get_integer(self->_priv->config_file, "WINDOW", "height", &error);
                if(error) {
                    g_error_free(error);
                    error = NULL;
                } else {
                    gtk_window_resize(GTK_WINDOW(self->_priv->win), width, height);
                }
            }
            /* Move window */
            width = g_key_file_get_integer(self->_priv->config_file, "WINDOW", "x-pos", &error);
            if(error) {
                g_error_free(error);
                error = NULL;
            } else {
                height = g_key_file_get_integer(self->_priv->config_file, "WINDOW", "y-pos", &error);
                if(error) {
                    g_error_free(error);
                    error = NULL;
                } else {
                    gtk_window_move(GTK_WINDOW(self->_priv->win), width, height);
                }
            }
            /* show pane */
            width = g_key_file_get_integer(self->_priv->config_file, "WINDOW", "show-item-pane", &error);
            if(error) {
                g_error_free(error);
                error = NULL;
            } else {
                gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(self->_priv->show_item_pane_menu_item),width);
            }



            glade_xml_signal_autoconnect_full(self->_priv->xml, (GladeXMLConnectFunc)self____glade_xml_connect_foreach, (gpointer)self);
            /* some testing */
            gtk_widget_show(self->_priv->win);
            /* put this after the show, or it will turn up black, for some oddball reason */
            self_interface_item_selection_changed(self, gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2)));

            return self;
        }

    public
    void
    left_pane_changed(self, GtkComboBox *box)
    {
        int i = gtk_combo_box_get_active(box);
        if(i==0){
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_tags));
        }else{
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_schemas));
        }
        /* refilter the items list */
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
    }
    public
    void
    search_type_changed(self, GtkComboBox *box)
    {
        GtkTreeIter iter;
        if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->_priv->cb_search), &iter))
        {
            StuffKeeperDataItemSearch *search;
            GtkWidget *item = glade_xml_get_widget(self->_priv->xml, "menuitem_remove_search");
            GtkWidget *item1 = glade_xml_get_widget(self->_priv->xml, "menuitem_edit_search");
            gint id;
            gtk_tree_model_get(self->_priv->model_searches, &iter,0,&id, 2, &search, -1);
            if(id == -1) {
                gtk_widget_set_sensitive(item, FALSE);
                gtk_widget_set_sensitive(item1, FALSE);
            } else {
                gtk_widget_set_sensitive(item, TRUE);
                gtk_widget_set_sensitive(item1, TRUE);
            }
        }
        /* refilter the items list */
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
    }

    /* Add item menu */
    public
    void
    interface_item_add_menu(self, GtkWidget *but)
    {
        debug_printf("show menu\n");

    }

    public
    void
    style_changed(GtkWidget *tree,GtkStyle *old, GtkCellRenderer *renderer)
    {
        debug_printf("style changed\n");
        g_object_set(G_OBJECT(renderer), 
                    "background-set", TRUE, "background-gdk",&(GTK_WIDGET(tree)->style->bg[GTK_STATE_SELECTED]), 
                    "foreground-set", TRUE, "foreground-gdk",&(GTK_WIDGET(tree)->style->fg[GTK_STATE_SELECTED]), 
                    NULL);
    }


    public
    void
    get_pixbuf(GtkTreeViewColumn *column, GtkCellRenderer *renderer, GtkTreeModel *model, GtkTreeIter *iter, gpointer data)
    {
        StuffKeeperDataItem *item;
        StuffKeeperDataSchema *schema;
        GdkPixbuf *pb;
        gtk_tree_model_get(model, iter, 2, &item, -1); 
        schema = stuffkeeper_data_item_get_schema(item);
        if(schema)
        {
            pb = stuffkeeper_data_schema_get_pixbuf(schema);
            g_object_set(renderer, "pixbuf", pb,NULL);
        }
    }

    /**
     * Initialize the main gui
     */
    public
        void 
        initialize_interface(self, StuffKeeperDataBackend *skdb)
        {
            GList *iter, *node;
            GtkTreeViewColumn *column;
            GtkCellRenderer *renderer;
            GtkTreeSelection *sel;
            /**
             * StuffKeeperDataBackend
             */
            self->_priv->skdbg = skdb;



            self->_priv->menu = gtk_menu_new();
            gtk_menu_tool_button_set_menu(GTK_MENU_TOOL_BUTTON(self->_priv->AddMenuButton), (self->_priv->menu));




            /* Setting up backends */
            self->_priv->model_schemas = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER,G_TYPE_INT);
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_schemas), 4, GTK_SORT_DESCENDING);
            /** Load the schemas*/
            node = stuffkeeper_data_backend_get_schemas(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_schema_added(self, STUFFKEEPER_DATA_SCHEMA(iter->data), self->_priv->skdbg);
            }
            if(node) g_list_free(node);

            self->_priv->signal_schema_added = g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), "schema-added",   G_CALLBACK(self_schema_added),self); 
            self->_priv->signal_schema_removed =g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), "schema-removed", G_CALLBACK(self_schema_removed),self);
            self->_priv->signal_schema_changed=g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), "schema-changed", G_CALLBACK(self_schema_changed),self);





            /* Tags */
            self->_priv->model_tags = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER,G_TYPE_INT);
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_tags), 4, GTK_SORT_DESCENDING);
            /** Load the tags */
            node = stuffkeeper_data_backend_get_tags(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_tag_added(self->_priv->skdbg, iter->data,self->_priv->model_tags);
            }
            if(node) g_list_free(node);
            /* handle an added tag */
            self->_priv->signal_tag_added = g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-added",G_CALLBACK(self_tag_added),self->_priv->model_tags);
             self->_priv->signal_tag_changed = g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-changed",G_CALLBACK(self_tag_changed),self->_priv->model_tags);
              self->_priv->signal_tag_removed = g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-removed",G_CALLBACK(self_tag_removed),self->_priv->model_tags);

            self->_priv->model_items = (GtkTreeModel *)gtk_list_store_new(4, G_TYPE_INT,G_TYPE_STRING,G_TYPE_POINTER,G_TYPE_INT);
            gtk_tree_sortable_set_sort_column_id(GTK_TREE_SORTABLE(self->_priv->model_items), 3, GTK_SORT_DESCENDING);
            /** Load the items*/
            node = stuffkeeper_data_backend_get_items(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_item_added(self->_priv->skdbg, STUFFKEEPER_DATA_ITEM(iter->data),self);
            }
            if(node) g_list_free(node);
            self->_priv->signal_item_added = g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-added",   G_CALLBACK(self_item_added),self); 
            self->_priv->signal_item_removed = g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-removed", G_CALLBACK(self_item_removed),self);
            self->_priv->signal_item_changed = g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-changed", G_CALLBACK(self_item_changed),self);

            /**
             * Searches
             */
            self->_priv->model_searches = (GtkTreeModel *)gtk_list_store_new(3, G_TYPE_INT,G_TYPE_STRING,G_TYPE_POINTER);

            gtk_combo_box_set_model(GTK_COMBO_BOX(self->_priv->cb_search), self->_priv->model_searches);
            {
                GObject* search = stuffkeeper_data_item_search_new_dummy();
                self_search_added(self, STUFFKEEPER_DATA_ITEM_SEARCH(search), self->_priv->skdbg);
            }
            node = stuffkeeper_data_backend_get_searches(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_search_added(self, STUFFKEEPER_DATA_ITEM_SEARCH(iter->data),self->_priv->skdbg);
            }
            if(node) g_list_free(node);
            self->_priv->signal_search_added = g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), "search-added",   G_CALLBACK(self_search_added),self); 
            self->_priv->signal_search_removed = g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), "search-removed", G_CALLBACK(self_search_removed),self);
            self->_priv->signal_search_changed = g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), "search-changed", G_CALLBACK(self_search_changed),self);





            /**
             * Items
             */
            /* A filtered items */
            self->_priv->model_items_filter = gtk_tree_model_filter_new(GTK_TREE_MODEL(self->_priv->model_items), NULL);
            renderer = gtk_cell_renderer_pixbuf_new();
            gtk_tree_view_insert_column_with_data_func(GTK_TREE_VIEW(self->_priv->treeview2), -1,"test", renderer, 
                    self_get_pixbuf, self, NULL);
            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->treeview2), -1, "items", renderer, "text", 1, NULL);
            g_object_set(renderer, "editable", TRUE,NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_item_title_edited), self);

            /* Look at the tree */
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview2), GTK_TREE_MODEL(self->_priv->model_items_filter));

            /* get changed selection */
            sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            g_signal_connect_swapped(G_OBJECT(sel), "changed", G_CALLBACK(self_interface_item_selection_changed), self);

            /* Tag list */
            gtk_tree_model_filter_set_visible_func(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter), 
                    (GtkTreeModelFilterVisibleFunc)self_interface_visible_func, self, NULL);



            /* TAGS */
            column = gtk_tree_view_column_new();

            /* Toggle button  */

            renderer = gtk_cell_renderer_toggle_new();
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE);
            gtk_tree_view_column_set_attributes(column, renderer, "active", 2, NULL);
            /* handle toggled */
            g_signal_connect_swapped(G_OBJECT(renderer), "toggled", G_CALLBACK(self_interface_left_pane_toggled), self);

            /* Tag name */
            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, TRUE);
            gtk_tree_view_column_set_attributes(column, renderer, "text", 1, NULL);
            g_object_set(renderer, "editable", TRUE,NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_left_pane_edited), self);

            /* Number of items */
            renderer = gtk_cell_renderer_text_new();
            g_object_set(G_OBJECT(renderer), 
                    "background-set", TRUE, "background-gdk",&(GTK_WIDGET(self->_priv->treeview1)->style->bg[GTK_STATE_SELECTED]), 
                    "foreground-set", TRUE, "foreground-gdk",&(GTK_WIDGET(self->_priv->treeview1)->style->fg[GTK_STATE_SELECTED]), 
                    NULL);
            g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_style_changed), renderer);            


            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE);
            gtk_tree_view_column_set_attributes(column, renderer, "text", 4, NULL);

            gtk_tree_view_append_column(GTK_TREE_VIEW(self->_priv->treeview1), column);

            gtk_combo_box_set_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB), 0);




          


            renderer = gtk_cell_renderer_text_new();
            gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(self->_priv->cb_search), renderer, TRUE);
            gtk_cell_layout_add_attribute(GTK_CELL_LAYOUT(self->_priv->cb_search), renderer, "text", 1);

            gtk_combo_box_set_active(GTK_COMBO_BOX(self->_priv->cb_search), 0);

            /** initial setup the list */
            gchar *data = g_strdup_printf("%i", stuffkeeper_data_backend_get_num_items(skdb));
            gtk_label_set_text(GTK_LABEL(self->_priv->item_label), data);
            g_free(data);





            //glade_xml_signal_autoconnect(xml);
            /*gtk_window_resize(GTK_WINDOW(self), 800,600);
            gtk_widget_show(GTK_WIDGET(self));
            */
            gtk_widget_show(self->_priv->win);
        }

        override (G:Object)
        void
        finalize(G:Object *obj)
        {
            int value;
            Self *self = SELF(obj);
            debug_printf("** Finalize stuffkeeper interface\n");
            if(self->_priv->signal_schema_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_schema_added);
                self->_priv->signal_schema_added = 0;
            }
            if(self->_priv->signal_schema_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_schema_changed);
                self->_priv->signal_schema_changed = 0;
            }
            if(self->_priv->signal_schema_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_schema_removed);
                self->_priv->signal_schema_removed = 0;
            }

            if(self->_priv->signal_item_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_item_added);
                self->_priv->signal_item_added = 0;
            }
            if(self->_priv->signal_item_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_item_changed);
                self->_priv->signal_item_changed = 0;
            }
            if(self->_priv->signal_item_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_item_removed);
                self->_priv->signal_item_removed = 0;
            }
            if(self->_priv->signal_search_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_search_added);
                self->_priv->signal_search_added = 0;
            }
            if(self->_priv->signal_search_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_search_changed);
                self->_priv->signal_search_changed = 0;
            }
            if(self->_priv->signal_search_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_search_removed);
                self->_priv->signal_search_removed = 0;
            }


            if(self->_priv->signal_tag_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_tag_added);
                self->_priv->signal_tag_added = 0;
            }
            if(self->_priv->signal_tag_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_tag_changed);
                self->_priv->signal_tag_changed = 0;
            }
            if(self->_priv->signal_tag_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_tag_removed);
                self->_priv->signal_tag_removed = 0;
            }
            if(self->_priv->search_timeout) {
                g_source_remove(self->_priv->search_timeout);
                self->_priv->search_timeout = 0;
            }
            value = gtk_paned_get_position(GTK_PANED(self->_priv->hpaned1));
            g_key_file_set_integer(self->_priv->config_file, "WINDOW", "hpane", value);
            value = gtk_paned_get_position(GTK_PANED(self->_priv->vpaned1));
            g_key_file_set_integer(self->_priv->config_file, "WINDOW", "vpane", value);
            gtk_window_get_size(GTK_WINDOW(self->_priv->win), &value, NULL);
            g_key_file_set_integer(self->_priv->config_file, "WINDOW", "width", value);
            gtk_window_get_size(GTK_WINDOW(self->_priv->win), NULL, &value);
            g_key_file_set_integer(self->_priv->config_file, "WINDOW", "height", value);
            /* position */
            gtk_window_get_position(GTK_WINDOW(self->_priv->win), &value, NULL);
            g_key_file_set_integer(self->_priv->config_file, "WINDOW", "x-pos", value);
            gtk_window_get_position(GTK_WINDOW(self->_priv->win), NULL, &value);
            g_key_file_set_integer(self->_priv->config_file, "WINDOW", "y-pos", value);

            value =  gtk_check_menu_item_get_active(GTK_CHECK_MENU_ITEM(self->_priv->show_item_pane_menu_item));
            g_key_file_set_integer(self->_priv->config_file, "WINDOW", "show-item-pane", value);


            gtk_widget_destroy(self->_priv->win);

        }
        /**
         * Item popup
         */
        public
        void
        interface_item_open(self)
        {
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection,&model, &iter))
            {
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    self_popup_item(self, item);
                }                                                          
            }
        }
        public 
        void
        item_row_activated(self, GtkTreePath *path, GtkTreeViewColumn *column, GtkTreeView *view)
        {

            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            debug_printf("item row activated\n");
            if(gtk_tree_model_get_iter(model,&iter, path)) 
            {
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    self_popup_item(self, item);
                }
            }
        }

        /**
         * Popup an item list
         * TODO: Check it item is destroyed, and if it is remove the window
         */
        public
        void 
        popup_item(self, StuffKeeper:Data:Item *item)
        {
            stuffkeeper_item_window_new(self->_priv->skdbg, item,self->_priv->config_file);

        }

    private
    void
        ___glade_xml_connect_foreach(const gchar *handler_name,
                GObject *object,
                const gchar *signal_name,
                const gchar *signal_data,
                GObject *connect_object,
                gboolean after,
                gpointer user_data)
        {
            static GModule * allsymbols = NULL;

            if (!allsymbols) allsymbols = g_module_open(NULL, 0);
            if (allsymbols) {
                gchar * func_name = g_strdup_printf("stuffkeeper_interface_%s", handler_name);
                GCallback func;

                if (!g_module_symbol(allsymbols, func_name, (gpointer)&func)){
                    if (!g_module_symbol(allsymbols, handler_name, (gpointer)&func)) {
                        g_warning("could not find signal handler '%s'.", func_name);
                        g_free(func_name);
                        return;
                    }
                }
                if (after)
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_AFTER | G_CONNECT_SWAPPED);
                else
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_SWAPPED);
                g_free(func_name);
            }
        }

        private 
        void
        dialog_activate_link(GtkAboutDialog *dialog, const gchar *uri, Self *self) 
        {
            open_url(uri);
        }
        private 
        void
        dialog_activate_email(GtkAboutDialog *dialog, const gchar *uri, Self *self) 
        {
            open_email(uri);
        }

        public
        void
        about_dialog(self)
        {
            GtkWidget *dialog = gtk_about_dialog_new();
            GdkPixbuf *pixbuf = NULL;
            /* set url handler */
            gtk_about_dialog_set_url_hook((GtkAboutDialogActivateLinkFunc)self_dialog_activate_link,self, NULL);
            gtk_about_dialog_set_email_hook((GtkAboutDialogActivateLinkFunc)self_dialog_activate_email,self, NULL);
            /* Set config time defines */
            gtk_about_dialog_set_program_name(GTK_ABOUT_DIALOG(dialog), PROGRAM_NAME);
            gtk_about_dialog_set_version(GTK_ABOUT_DIALOG(dialog), PROGRAM_VERSION);
            gtk_about_dialog_set_website(GTK_ABOUT_DIALOG(dialog), PROGRAM_WEBSITE); 

            gtk_about_dialog_set_copyright(GTK_ABOUT_DIALOG(dialog), "Copyright 2008 Qball Cow");
            gtk_about_dialog_set_license(GTK_ABOUT_DIALOG(dialog),
                    _("GNU General Public License"));


            pixbuf = gtk_icon_theme_load_icon (gtk_icon_theme_get_default (), "stuffkeeper", 64, 0, NULL);
            gtk_about_dialog_set_logo(GTK_ABOUT_DIALOG(dialog),pixbuf);


            gtk_about_dialog_set_artists(GTK_ABOUT_DIALOG(dialog),artists);
            gtk_about_dialog_set_authors(GTK_ABOUT_DIALOG(dialog),authors);
            gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG(dialog), _("translator-credits"));

            gtk_dialog_run(GTK_DIALOG(dialog));
            gtk_widget_destroy(dialog);

        }
        /** 
         * Backup
         */
        public
        void
        filename_changed(self, GtkWidget *entry)
        {
            GladeXML *xml =glade_get_widget_tree(entry);
            GtkWidget *button =  glade_xml_get_widget(xml,"save_button"); 
            const gchar *text = gtk_entry_get_text(GTK_ENTRY(entry));
            gtk_widget_set_sensitive(button, (strlen(text) > 0)?TRUE:FALSE);
        }

        public
        void
        make_backup(self)
        {
            GladeXML *xml = glade_xml_new(PACKAGE_DATADIR"/stuffkeeper.glade","dialog_backup",NULL);
            GtkWidget *dialog = glade_xml_get_widget(xml,"dialog_backup");

            glade_xml_signal_autoconnect_full(xml, (GladeXMLConnectFunc)self____glade_xml_connect_foreach, (gpointer)self);
            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case -5:
                    {
                        gchar *directory = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(glade_xml_get_widget(xml, "location_chooser")));
                        GtkWidget *entry = glade_xml_get_widget(xml, "entry_filename"); 
                        const gchar *file = gtk_entry_get_text(GTK_ENTRY(entry)); 
                        const gchar *source = stuffkeeper_data_backend_get_path(self->_priv->skdbg);
                        if(file)                                                                                      
                        {
                            gchar *suffix = g_path_get_dirname(directory);
                            gchar *exec = g_strdup_printf("tar -cz -C '%s' -f '%s%c%s.tar.gz' '.'",source, directory,G_DIR_SEPARATOR,file);
                            g_spawn_command_line_async(exec, NULL);
                            g_free(suffix);
                            g_free(exec);
                            g_free(directory);
                        }
                    }
                default:
                    break;
            }
            gtk_widget_destroy(dialog);
            g_object_unref(xml);
        }

        public
        void
        restore_backup(self)
        {
            GtkWidget *dialog = gtk_file_chooser_dialog_new("Open archive", 
                        NULL, 
                        GTK_FILE_CHOOSER_ACTION_OPEN,
                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                        GTK_STOCK_OPEN, GTK_RESPONSE_OK, 
                        NULL);
            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case GTK_RESPONSE_OK:
                {
                    const gchar *directory= stuffkeeper_data_backend_get_path(self->_priv->skdbg);
                    gchar *filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
                    if(filename)
                    {
                        gchar *exec = g_strdup_printf("tar -zxf '%s' -C '%s' ",filename, directory);
                        gchar *path = g_strdup(stuffkeeper_data_backend_get_path(self->_priv->skdbg));
                        stuffkeeper_data_backend_close_yourself(self->_priv->skdbg);
                        g_spawn_command_line_sync(exec,NULL, NULL, NULL,NULL);
                        g_free(exec);
                        g_free(filename);
                        stuffkeeper_data_backend_load(self->_priv->skdbg, path);


                        g_free(path);
                    }
                }
                default:
                    break;

            }
            gtk_widget_destroy(dialog);
        }


        public
        void
        reload(self)
        {
            gchar *path = g_strdup(stuffkeeper_data_backend_get_path(self->_priv->skdbg));
            stuffkeeper_data_backend_close_yourself(self->_priv->skdbg);
            stuffkeeper_data_backend_load(self->_priv->skdbg, path);
            g_free(path);
        }
        public
            void
            visit_homepage(self)
            {
                open_url(PROGRAM_WEBSITE);
            }
        /**
         * HTML Export 
         */
        /* Export the whole db */
        public
        void
        export_to_csv(self)
        {
            stuffkeeper_export_csv_new(STUFFKEEPER_DATA_BACKEND(self->_priv->skdbg),GTK_LIST_STORE(self->_priv->model_schemas));
        }

        public
        void
        export_to_html(self)
        {
            stuffkeeper_export_html_new_schema(GTK_LIST_STORE(self->_priv->model_schemas));
        }

        /* export selected item */
        public
        void
        export_html_item(self)
        {
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkWidget *tree = self->_priv->treeview2;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    stuffkeeper_export_html_new(STUFFKEEPER_DATA_ITEM(item));
                    return;
                }
            }
        }
        
        /**
         * Search new 
         */
        public
        void 
        new_search(self)
        {
            stuffkeeper_data_backend_new_search(self->_priv->skdbg);
        }

        public
        void
        remove_search(self)
        {
            GtkTreeIter iter;
            if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->_priv->cb_search), &iter))
            {
                StuffKeeperDataItemSearch *search;
                gint id;
                gtk_tree_model_get(self->_priv->model_searches, &iter,0,&id, 2, &search, -1);
                if(search && id != -1)
                {
                    stuffkeeper_data_backend_remove_search(self->_priv->skdbg, id);
                }
            }


        }
        public
            void
        edit_search(self)
        {
            GtkTreeIter iter;
            if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(self->_priv->cb_search), &iter))
            {
                StuffKeeperDataItemSearch *search;
                gint id;
                gtk_tree_model_get(self->_priv->model_searches, &iter,0,&id, 2, &search, -1);
                if(search && id != -1)
                {
/*                    stuffkeeper_data_backend_remove_search(self->_priv->skdbg, id);*/
                    stuffkeeper_data_item_search_edit_search_gui(search);
                }
            }


        }
}
