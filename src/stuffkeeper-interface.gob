requires 2.0.10

%h{
/* Include gtk */
#include <gtk/gtk.h>
#include <glade/glade.h>
/* Include the database */

#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-data-schema.h"
#include "stuffkeeper-data-label.h"
#include "stuffkeeper-data-entry.h"
#include "stuffkeeper-data-boolean.h"
#include "stuffkeeper-data-spinbutton.h"
#include "stuffkeeper-data-rating.h"
#include "stuffkeeper-data-taglist.h"

%}


class StuffKeeper:Interface from Gtk:Widget (GladeXML "stuffkeeper.glade" "win")
{
    private GtkTreeModel *model_tags = {NULL};
    private GtkTreeModel *model_items= {NULL};
    private GtkTreeModel *model_schemas = {NULL};

    private GtkTreeModel *model_items_filter = {NULL};
    /**
     * Treeview 1 & 2
     */
    private GtkWidget *LeftPaneCB GladeXML;
    private GtkWidget *treeview1 GladeXML;
    private GtkWidget *treeview2 GladeXML;
    private GtkWidget *add_tag_entry GladeXML;
    private GtkWidget *item_vbox GladeXML;
    private GtkWidget *item_event_box GladeXML;
    private StuffKeeperDataBackend *skdbg = {NULL};
    /**
     * Keep Schema's GtkListStore up2date
     */
    public
    void 
    schema_added(StuffKeeperDataBackend *skdb, StuffKeeperDataSchema *schema, GtkListStore *store)
    {
        GtkTreeIter iter;
        gtk_list_store_append(store, &iter);
        gchar *title = stuffkeeper_data_schema_get_title(schema);
        gtk_list_store_set(store, &iter, 0, stuffkeeper_data_schema_get_id(schema),1,title,3,schema, 4, stuffkeeper_data_schema_num_items(schema),-1);
        g_free(title);
    }
    public
    void 
    schema_changed(StuffKeeperDataBackend *skdb, StuffKeeperDataSchema *schema, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_schema_get_id(schema);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_schema_get_title(schema);
                    gtk_list_store_set(store, &iter, 1,title, 4, stuffkeeper_data_schema_num_items(schema),-1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void 
    schema_removed(StuffKeeperDataBackend *skdb, gint id, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    /**
     * Keep Tag's GtkListStore up2date
     */
    public
    void 
    tag_added(StuffKeeperDataBackend *skdb, StuffKeeperDataTag *tag, GtkListStore *store)
    {
        GtkTreeIter iter;
        gtk_list_store_append(store, &iter);
        gchar *title = stuffkeeper_data_tag_get_title(tag);
        gtk_list_store_set(store, &iter, 0, stuffkeeper_data_tag_get_id(tag),1,title,3,tag, 4, stuffkeeper_data_tag_num_items(tag),-1);
        g_free(title);
    }
    public
    void 
    tag_changed(StuffKeeperDataBackend *skdb, StuffKeeperDataTag *tag, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_tag_get_id(tag);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_tag_get_title(tag);
                    gtk_list_store_set(store, &iter, 1,title, 4, stuffkeeper_data_tag_num_items(tag),-1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void 
    tag_removed(StuffKeeperDataBackend *skdb, gint id, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    /**
     * Item GtkListStore
     * Update the gtk-list-store with signals from the backend
     */
    public
    void
    item_removed(StuffKeeperDataBackend *skdb, gint id, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void
    item_added(StuffKeeperDataBackend *skdb, StuffKeeperDataItem *item, GtkListStore *store)
    {
        GtkTreeIter iter;
        gtk_list_store_append(store, &iter);
        gchar *title = stuffkeeper_data_item_get_title(item);
        gtk_list_store_set(store, &iter, 0, stuffkeeper_data_item_get_id(item),1,title, 2,item,-1);
        g_free(title);


    }
    public
    void
    item_changed(StuffKeeperDataBackend *skdb, StuffKeeperDataItem *item, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_item_get_id(item);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_item_get_title(item);
                    printf("Item items: %i\n", id);
                    gtk_list_store_set(store, &iter, 1,title, -1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }































































































    /**
     * Add item button clicked 
     */
    public
        void 
        interface_item_add(self)
        {
            /** TODO, set schema */
            GList *list = stuffkeeper_data_backend_get_schemas(self->_priv->skdbg);
            if(list)
            {
                StuffKeeperDataItem *item = stuffkeeper_data_backend_new_item(self->_priv->skdbg,list->data);
                stuffkeeper_data_item_set_title(item,"New Item");
                g_list_free(list);
            }

        }
    /**
     * Remove selected item
     */
    public
        void interface_item_remove(self)
        {
            GtkWidget *tree = self->_priv->treeview2;//glade_xml_get_widget(xml, "treeview2");
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree));
            GtkTreeModel *model = GTK_TREE_MODEL(gtk_tree_view_get_model(GTK_TREE_VIEW(tree)));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {
                gint id;
                gtk_tree_model_get(model, &iter ,0,&id, -1);
                printf("requesting removal of: %i\n", id);
                stuffkeeper_data_backend_remove_item(self->_priv->skdbg, id);

            }
        }

    /**
     * Tag is enabled/disabled
     */
    public
        void 
        interface_left_pane_toggled(self, gchar *path, GtkCellRendererToggle *renderer)
        {
            GtkTreeIter iter;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gboolean value = !gtk_cell_renderer_toggle_get_active(renderer);
                gtk_list_store_set(GTK_LIST_STORE(model), &iter, 2,value,-1);

                /* refilter the items list */
                gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
            }
        }

    public
        void interface_item_title_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            printf("edited: %s\n", new_text);
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gint id;
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter ,0,&id, -1);
                printf("get item: %i\n",id);
                item = stuffkeeper_data_backend_get_item(self->_priv->skdbg, id);
                if(item)
                {
                    stuffkeeper_data_item_set_title(item, new_text);
                }

            }
        }

    public
        void interface_left_pane_edited 
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )

        {
            GtkTreeIter iter;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                GObject *item;

                gtk_tree_model_get(model, &iter ,3,&item, -1);

                if(STUFFKEEPER_IS_DATA_TAG(item))
                {
                    stuffkeeper_data_tag_set_title(STUFFKEEPER_DATA_TAG(item), new_text);
                }else if (STUFFKEEPER_IS_DATA_SCHEMA(item)){
                    stuffkeeper_data_schema_set_title(STUFFKEEPER_DATA_SCHEMA(item), new_text);
                }
                

            }
        }
    /**
     * Quit the program
     */
    public
        void quit_program(void)
        {
            gtk_main_quit();
        }

    /**
     * Filtering the item list
     */
    public
        gboolean 
        interface_visible_func(GtkTreeModel *model, GtkTreeIter *iter, StuffKeeperInterface *self) 
        {
            GtkTreeModel *model2 = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            StuffKeeperDataItem *item;
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));

            /* Get the item */
            gtk_tree_model_get(model, iter, 2,&item, -1);

            if(!item) {
                return FALSE;
            }

            GtkTreeIter piter;
            if(gtk_tree_model_get_iter_first(model2, &piter))
            {
                do{
                    GObject *tag;
                    gboolean sel;
                    /* get the tag, and if it is selected */
                    gtk_tree_model_get(model2, &piter,2,&sel, 3,&tag, -1);

                    if(sel && tag)
                    {
                        if(type == 0 && !stuffkeeper_data_item_has_tag(item, STUFFKEEPER_DATA_TAG(tag)))
                        {
                            return FALSE;
                        }
                        else if (type == 1 && 
                        stuffkeeper_data_schema_get_id(stuffkeeper_data_item_get_schema(item)) != stuffkeeper_data_schema_get_id(STUFFKEEPER_DATA_SCHEMA(tag)))
                        {
                            return FALSE;
                        }
                    }

                }while(gtk_tree_model_iter_next(model2, &piter));
            }

            return TRUE; 
        }

    public
        void 
        interface_entry_add(self,GtkWidget *button)
        {

            GtkWidget *entry= self->_priv->add_tag_entry;
            const gchar *title = gtk_entry_get_text(GTK_ENTRY(entry));
            StuffKeeperDataTag *tag;
            if(title == NULL || strlen(title) == 0)
                return;
            tag = stuffkeeper_data_backend_add_tag(self->_priv->skdbg,NULL,g_random_int());
            if(title && strlen(title) > 0)
                stuffkeeper_data_tag_set_title(tag, title);
        }

    public
        void 
        interface_item_selection_changed (self, GtkTreeSelection *selection)
        {
            GtkTreeModel *model;
            GtkWidget *container,*tree,*event;
            GList *list;
            /** Remove all old widgets */
            container = self->_priv->item_vbox; ///glade_xml_get_widget(xml, "item_vbox");

            event =  self->_priv->item_event_box;//glade_xml_get_widget(xml, "item_event_box");
            gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &(container->style->white));

            list = gtk_container_get_children(GTK_CONTAINER(container));
            if(list)
            {
                GList *node;
                for(node = g_list_first(list); node; node = g_list_next(node))
                {
                    gtk_widget_destroy(GTK_WIDGET(node->data));
                }
                g_list_free(list);
            }
            /**/
            tree = self->_priv->treeview2;//glade_xml_get_widget(xml, "treeview2");



            model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    /* The title */
                    GtkWidget *vbox;
                    GtkWidget *label1;

                    vbox = gtk_hbox_new(FALSE, 6);
                    /* Title */
                    label1 = gtk_label_new("");
                    gtk_label_set_markup(GTK_LABEL(label1), "<b>Title:</b>");
                    gtk_misc_set_alignment(GTK_MISC(label1), 1,0.5);
                    gtk_box_pack_start(GTK_BOX(vbox),label1, FALSE,TRUE, 0);

                    label1 = stuffkeeper_data_entry_new(item,NULL);
                    gtk_box_pack_start(GTK_BOX(vbox),label1, TRUE,TRUE, 0);

                    /* type */
                    StuffKeeperDataSchema *schema = stuffkeeper_data_item_get_schema(item);
                    label1 =gtk_label_new("");
                    gtk_label_set_markup(GTK_LABEL(label1), "<b>Type:</b>");
                    gtk_box_pack_start(GTK_BOX(vbox),label1, FALSE,TRUE, 0);

                    if(schema) {
                        label1 = stuffkeeper_data_label_new_schema(schema);
                    } else {
                        label1 = gtk_label_new("N/A");
                    }


                    gtk_box_pack_start(GTK_BOX(vbox),label1, FALSE,TRUE, 0);
                    gtk_box_pack_start(GTK_BOX(container),vbox, FALSE,TRUE, 0);
                    label1 = gtk_label_new("");
                    gtk_label_set_markup(GTK_LABEL(label1),"<span weight='bold' size='x-large'>Fields:</span>");
                    gtk_misc_set_alignment(GTK_MISC(label1), 0,0.5);
                    gtk_misc_set_padding(GTK_MISC(label1), 0,8);
                    gtk_box_pack_start(GTK_BOX(container),label1, FALSE,TRUE, 0);

                    /**
                     * Get the attached schema and fill in the rest from there
                     */
                    if(schema)
                    {
                        gsize length;
                        int i;
                        gchar **retv = stuffkeeper_data_schema_get_fields(schema, &length);
                        /* num fields + one for the tags */
                        vbox = gtk_table_new(length+1, 2, FALSE);
                        gtk_table_set_row_spacings(GTK_TABLE(vbox), 6);
                        gtk_table_set_col_spacings(GTK_TABLE(vbox), 6);
                        for(i=0;i<length;i++)
                        {
                            FieldType type = stuffkeeper_data_schema_get_field_type(schema, retv[i]);
                            gchar *field_name = stuffkeeper_data_schema_get_field_name(schema, retv[i]);

                            /* Title */
                            label1 = gtk_label_new("");
                            gchar *val = g_markup_printf_escaped("<b>%s</b>", field_name);
                            gtk_label_set_markup(GTK_LABEL(label1), val);
                            g_free(val);
                            gtk_misc_set_alignment(GTK_MISC(label1), 1,0.5);
                            gtk_table_attach(GTK_TABLE(vbox), label1, 0,1,i,i+1,GTK_SHRINK|GTK_FILL, GTK_FILL, 0,0);
                            if(type == FIELD_TYPE_STRING)
                            {
                                label1 = stuffkeeper_data_entry_new(item,retv[i]);
                            }
                            else if (type == FIELD_TYPE_INTEGER)
                            {
                                label1 = stuffkeeper_data_spinbutton_new(item,retv[i]);
                            }else if (type == FIELD_TYPE_BOOLEAN) {
                                label1 = stuffkeeper_data_boolean_new(item,retv[i]);
                            }else if (type == FIELD_TYPE_RATING) {
                                label1 = stuffkeeper_data_rating_new(item,retv[i]);
                            }else {
                                label1 = gtk_label_new("not supported\n");
                            }
                            gtk_table_attach(GTK_TABLE(vbox), label1, 1,2,i,i+1,GTK_SHRINK|GTK_FILL, GTK_FILL, 0,0);


                            g_free(field_name);
                        }
                        /**
                         * Fill in the Tag list 
                         */
                        /* Title */
                        label1 = gtk_label_new("");
                        gchar *val = g_markup_printf_escaped("<b>%s</b>", "Tags");
                        gtk_label_set_markup(GTK_LABEL(label1), val);
                        g_free(val);
                        gtk_misc_set_alignment(GTK_MISC(label1), 1,0.5);
                        gtk_table_attach(GTK_TABLE(vbox), label1, 0,1,i,i+1,GTK_SHRINK|GTK_FILL, GTK_FILL, 0,0);

                        label1 = stuffkeeper_data_taglist_new(self->_priv->skdbg,item);
                        gtk_table_attach(GTK_TABLE(vbox), label1, 1,2,i,i+1,GTK_SHRINK|GTK_FILL, GTK_FILL, 0,0);

                        gtk_box_pack_start(GTK_BOX(container),vbox, FALSE,TRUE, 0);
                        g_strfreev(retv);
                    }

                }
            }
            gtk_widget_show_all(container);

        }

    public
        void 
        interface_remove_tag(self)
        {
            GtkWidget *tree = self->_priv->treeview1;//glade_xml_get_widget(xml, "treeview1");

            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
            GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(sel, &model, &iter))
            {
                StuffKeeperDataTag *tag;
                gtk_tree_model_get(model, &iter, 3, &tag, -1);
                if(tag)
                {
                    if(stuffkeeper_data_tag_num_items(tag) > 0)
                    {
                        printf("This tag is not empty\n");
                    }
                    else
                    {
                        gint id = stuffkeeper_data_tag_get_id(tag); 
                        printf("removing item: %i\n", id);
                        stuffkeeper_data_backend_remove_tag(self->_priv->skdbg,id);
                    }
                }
            }
        }

    public
        StuffKeeperInterface * 
        new(void)
        {
            return GET_NEW;
        }

    public
    void
    left_pane_changed(self, GtkComboBox *box)
    {
        int i = gtk_combo_box_get_active(box);
        if(i==0){
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_tags));
        }else{
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_schemas));
        }
        /* refilter the items list */
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
    }
    /**
     * Initialize the main gui
     */
    public
        void 
        initialize_interface(self, StuffKeeperDataBackend *skdb)
        {
            GtkTreeViewColumn *column;
            GtkCellRenderer *renderer;
            GtkTreeSelection *sel;
            /**
             * StuffKeeperDataBackend
             */
            self->_priv->skdbg = skdb;

            /* Setting up backends */
            /* Tags */
            self->_priv->model_tags = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER,G_TYPE_INT);
            /* handle an added tag */
            g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-added",G_CALLBACK(self_tag_added),self->_priv->model_tags);
            g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-changed",G_CALLBACK(self_tag_changed),self->_priv->model_tags);
            g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-removed",G_CALLBACK(self_tag_removed),self->_priv->model_tags);

            self->_priv->model_items = (GtkTreeModel *)gtk_list_store_new(3, G_TYPE_INT,G_TYPE_STRING,G_TYPE_POINTER);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-added",   G_CALLBACK(self_item_added), self->_priv->model_items);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-removed", G_CALLBACK(self_item_removed),self->_priv->model_items);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-changed", G_CALLBACK(self_item_changed),self->_priv->model_items);

            self->_priv->model_schemas = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER,G_TYPE_INT);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "schema-added",   G_CALLBACK(self_schema_added), self->_priv->model_schemas);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "schema-removed", G_CALLBACK(self_schema_removed),self->_priv->model_schemas);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "schema-changed", G_CALLBACK(self_schema_changed),self->_priv->model_schemas);
            /**
             * Items
             */
            /* A filtered items */
            self->_priv->model_items_filter = gtk_tree_model_filter_new(GTK_TREE_MODEL(self->_priv->model_items), NULL);

            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->treeview2), -1, "test", renderer, "text", 1, NULL);
            g_object_set(renderer, "editable", TRUE,NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_item_title_edited), self);

            /* Look at the tree */
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview2), GTK_TREE_MODEL(self->_priv->model_items_filter));

            /* get changed selection */
            sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            g_signal_connect_swapped(G_OBJECT(sel), "changed", G_CALLBACK(self_interface_item_selection_changed), self);

            /* Tag list */
            gtk_tree_model_filter_set_visible_func(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter), 
                    (GtkTreeModelFilterVisibleFunc)self_interface_visible_func, self, NULL);



            /* TAGS */
            column = gtk_tree_view_column_new();

            /* Toggle button  */

            renderer = gtk_cell_renderer_toggle_new();
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE);
            gtk_tree_view_column_set_attributes(column, renderer, "active", 2, NULL);
            /* handle toggled */
            g_signal_connect_swapped(G_OBJECT(renderer), "toggled", G_CALLBACK(self_interface_left_pane_toggled), self);

            /* Tag name */
            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, TRUE);
            gtk_tree_view_column_set_attributes(column, renderer, "text", 1, NULL);
            g_object_set(renderer, "editable", TRUE,NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_left_pane_edited), self);

            /* Number of items */
            renderer = gtk_cell_renderer_text_new();
            g_object_set(G_OBJECT(renderer), "background-set", TRUE, "background", "black", "foreground-set", TRUE, "foreground", "white",NULL);
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE);
            gtk_tree_view_column_set_attributes(column, renderer, "text", 4, NULL);

            gtk_tree_view_append_column(GTK_TREE_VIEW(self->_priv->treeview1), column);

            gtk_combo_box_set_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB), 0);









            //glade_xml_signal_autoconnect(xml);
        }
}
