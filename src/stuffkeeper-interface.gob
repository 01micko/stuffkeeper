requires 2.0.10

%h{
/* Include gtk */
#include <gtk/gtk.h>
#include <glade/glade.h>
#include <config.h>
/* Include the database */

#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-data-schema.h"
#include "stuffkeeper-data-label.h"
#include "stuffkeeper-data-entry.h"
#include "stuffkeeper-data-boolean.h"
#include "stuffkeeper-data-spinbutton.h"
#include "stuffkeeper-data-rating.h"
#include "stuffkeeper-data-taglist.h"
#include "stuffkeeper-edit-schema.h"
#include "stuffkeeper-show-item.h"
#include "stuffkeeper-item-window.h"

extern GList *interface_list;
%}


class StuffKeeper:Interface from G:Object 
{
    private GtkTreeModel *model_tags = {NULL};
    private GtkTreeModel *model_items= {NULL};
    private GtkTreeModel *model_schemas = {NULL};

    private GtkTreeModel *model_items_filter = {NULL};

    /* Menu */
    /* A hash list used to store the items, the item id is the hash key */
    /* Don't free the list */
    private GHashTable *schemas_items = {g_hash_table_new_full(g_int_hash, g_int_equal,g_free, NULL)} destroywith g_hash_table_destroy ;
    private GtkWidget *menu = {NULL};
    /**
     * Treeview 1 & 2
     */
     private GladeXML *xml;
     private GtkWidget *win;
    private GtkWidget *LeftPaneCB ;
    private GtkWidget *treeview1 ;
    private GtkWidget *treeview2 ;
    private GtkWidget *item_vbox ;
    private GtkWidget *item_event_box ;
    
    private GtkWidget *LeftPane_edit ;
    private GtkWidget *AddMenuButton ;
    private GtkWidget *search_entry ;
    private GtkWidget *item_label;

    private StuffKeeperDataBackend *skdbg = {NULL};
    /**
     * Fix so the signals are correctly destroy
     */
    private gulong signal_schema_added = {0};
    private gulong signal_schema_changed = {0};
    private gulong signal_schema_removed = {0};

    private gulong signal_tag_added = {0};
    private gulong signal_tag_changed = {0};
    private gulong signal_tag_removed = {0};

    private gulong signal_item_added = {0};
    private gulong signal_item_changed = {0};
    private gulong signal_item_removed = {0};








    /**
     * Keep Schema's GtkListStore up2date
     */
    public
    void 
    schema_added(self, StuffKeeperDataSchema *schema,StuffKeeperDataBackend *skdb )
    {
        GtkTreeIter iter;
        gint id;
        gtk_list_store_append(GTK_LIST_STORE(self->_priv->model_schemas), &iter);
        gchar *title = stuffkeeper_data_schema_get_title(schema);
        gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_schemas), &iter, 
                    0, stuffkeeper_data_schema_get_id(schema),
                    1, title,
                    3, schema,
                    4, stuffkeeper_data_schema_num_items(schema),-1);



        id = stuffkeeper_data_schema_get_id(schema);
        if(schema)
        {
            GtkWidget *m = gtk_menu_item_new_with_label((title==NULL)?"n/a":title);
            gint *ide;
            ide = g_malloc0(sizeof(gint));
            *ide = id;
            g_hash_table_insert(self->_priv->schemas_items, ide, m); 
            /* menu */
            gtk_menu_shell_insert(GTK_MENU_SHELL(self->_priv->menu), m,-1);
            g_object_set_data(G_OBJECT(m), "schema", schema);
            g_signal_connect_swapped(G_OBJECT(m), "activate", G_CALLBACK(self_interface_item_add_menu_button), self);
            gtk_widget_show_all(self->_priv->menu);
        }
        g_free(title);
    }
    public
    void 
    schema_changed(self, StuffKeeperDataSchema *schema, StuffKeeperDataBackend *skdb)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->model_schemas);
        gint id = stuffkeeper_data_schema_get_id(schema);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_schema_get_title(schema);
                    gtk_list_store_set(GTK_LIST_STORE(model), &iter, 1,title, 4, stuffkeeper_data_schema_num_items(schema),-1);
                    g_free(title);
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
        printf("schema changed: %i\n",id);
        GtkWidget *item = g_hash_table_lookup(self->_priv->schemas_items, &id);
        if(item) {
            gchar *name = stuffkeeper_data_schema_get_title(schema);
            GtkWidget *label = gtk_bin_get_child(GTK_BIN(item));
            gtk_label_set_text(GTK_LABEL(label), name);
            g_free(name);

        }
    }
    public
    void 
    schema_removed(self, gint id, StuffKeeperDataBackend *skdb)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->model_schemas);

        g_hash_table_remove(self->_priv->schemas_items,&id);

        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(GTK_LIST_STORE(model), &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    /**
     * Keep Tag's GtkListStore up2date
     */
    public
    void 
    tag_added(StuffKeeperDataBackend *skdb, StuffKeeperDataTag *tag, GtkTreeModel *store)
    {
        GtkTreeIter iter;
        gtk_list_store_append(GTK_LIST_STORE(store), &iter);
        gchar *title = stuffkeeper_data_tag_get_title(tag);
        gtk_list_store_set(GTK_LIST_STORE(store), &iter, 0, stuffkeeper_data_tag_get_id(tag),1,title,3,tag, 4, stuffkeeper_data_tag_num_items(tag),-1);
        g_free(title);
    }
    public
    void 
    tag_changed(StuffKeeperDataBackend *skdb, StuffKeeperDataTag *tag, GtkTreeModel *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_tag_get_id(tag);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_tag_get_title(tag);
                    gtk_list_store_set(GTK_LIST_STORE(store), &iter, 1,title, 4, stuffkeeper_data_tag_num_items(tag),-1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void 
    tag_removed(StuffKeeperDataBackend *skdb, gint id, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    /**
     * Item GtkListStore
     * Update the gtk-list-store with signals from the backend
     */
    public
    void
    item_removed(StuffKeeperDataBackend *skdb, gint id,StuffKeeperInterface *self) 
    {
        GtkTreeIter iter;
        GtkListStore *store = GTK_LIST_STORE(self->_priv->model_items);
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gchar *data = g_strdup_printf("%i", stuffkeeper_data_backend_get_num_items(skdb)-1);
        gtk_label_set_text(GTK_LABEL(self->_priv->item_label), data);
        g_free(data);




        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void
    item_added(StuffKeeperDataBackend *skdb, StuffKeeperDataItem *item, StuffKeeperInterface *self) 
    {
        GtkTreeIter iter;
        gchar *data;
        GtkListStore *store = GTK_LIST_STORE(self->_priv->model_items);
        gtk_list_store_append(GTK_LIST_STORE(store), &iter);
        gchar *title = stuffkeeper_data_item_get_title(item);
        gtk_list_store_set(GTK_LIST_STORE(store), &iter, 0, stuffkeeper_data_item_get_id(item),1,title, 2,item,-1);
        g_free(title);

        data = g_strdup_printf("%i", stuffkeeper_data_backend_get_num_items(skdb));
        gtk_label_set_text(GTK_LABEL(self->_priv->item_label), data);
        g_free(data);

    }
    public
    void
    item_changed(StuffKeeperDataBackend *skdb, const gchar *field, StuffKeeperDataItem *item, StuffKeeperInterface *self) 
    {
        GtkTreeIter iter;
        GtkListStore *store = GTK_LIST_STORE(self->_priv->model_items);
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_item_get_id(item);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_item_get_title(item);
                    gtk_list_store_set(store, &iter, 1,title, -1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }


    /**
     * Add item button clicked 
     */
    public
        void 
        interface_item_add(self)
        {
            /** TODO, set schema */
            GList *list = stuffkeeper_data_backend_get_schemas(self->_priv->skdbg);
            if(list)
            {
                StuffKeeperDataItem *item = stuffkeeper_data_backend_new_item(self->_priv->skdbg,list->data);
                stuffkeeper_data_item_set_title(item,"New Item");
                g_list_free(list);
            }

        }

    public
        void 
        interface_item_add_menu_button(self, GtkWidget *button)
        {
            StuffKeeperDataSchema *schema = g_object_get_data(G_OBJECT(button), "schema");
            if(schema)
            {
                StuffKeeperDataItem *item = stuffkeeper_data_backend_new_item(self->_priv->skdbg,schema);
                stuffkeeper_data_item_set_title(item,"New Item");
            }

        }





    /**
     * Remove selected item
     */
    public
        void interface_item_remove(self)
        {
            /** Setup a dialog that ask the user if he is sure */
            GtkWidget *dialog;

            dialog = gtk_message_dialog_new(GTK_WINDOW(self->_priv->win), 
                        GTK_DIALOG_DESTROY_WITH_PARENT|// This belongs to the parent, so if the user closes the parent, close it
                        GTK_DIALOG_MODAL, // It is a warning, it _should_ be modal.
                        GTK_MESSAGE_WARNING, // It is a warning message.
                        GTK_BUTTONS_YES_NO, // yes/no question
                    "Deleting an entry cannot be undone.\nAre you sure you want to continue?");
            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case GTK_RESPONSE_YES:
                    {
                        GtkWidget *tree = self->_priv->treeview2;//glade_xml_get_widget(xml, "treeview2");
                        GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree));
                        GtkTreeModel *model = GTK_TREE_MODEL(gtk_tree_view_get_model(GTK_TREE_VIEW(tree)));
                        GtkTreeIter iter;
                        if(gtk_tree_selection_get_selected(selection, &model, &iter))
                        {
                            gint id;
                            gtk_tree_model_get(model, &iter ,0,&id, -1);
                            stuffkeeper_data_backend_remove_item(self->_priv->skdbg, id);

                        }
                    }
                default:
                    gtk_widget_destroy(dialog);
            }
        }

    /**
     * Tag is enabled/disabled
     */
    public
        void 
        interface_left_pane_toggled(self, gchar *path, GtkCellRendererToggle *renderer)
        {
            GtkTreeIter iter;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gboolean value = !gtk_cell_renderer_toggle_get_active(renderer);
                gtk_list_store_set(GTK_LIST_STORE(model), &iter, 2,value,-1);

                /* refilter the items list */
                gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
            }
        }

    public
        void interface_item_title_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gint id;
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter ,0,&id, -1);
                item = stuffkeeper_data_backend_get_item(self->_priv->skdbg, id);
                if(item)
                {
                    stuffkeeper_data_item_set_title(item, new_text);
                }

            }
        }

    public
        void interface_left_pane_edited 
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )

        {
            GtkTreeIter iter;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                GObject *item;

                gtk_tree_model_get(model, &iter ,3,&item, -1);

                if(STUFFKEEPER_IS_DATA_TAG(item))
                {
                    stuffkeeper_data_tag_set_title(STUFFKEEPER_DATA_TAG(item), new_text);
                }else if (STUFFKEEPER_IS_DATA_SCHEMA(item)){
                    stuffkeeper_data_schema_set_title(STUFFKEEPER_DATA_SCHEMA(item), new_text);
                }
                

            }
        }
    /**
     * Quit the program
     */
    public
        void quit_program(void)
        {
            gtk_main_quit();
        }

    public 
    void
    close_window(self)
    {
        int n;
        interface_list = g_list_remove(interface_list, self);
        n = g_list_length(interface_list);
        gtk_widget_destroy(GTK_WIDGET(self->_priv->win));
        g_object_unref(self);

        if(n == 0)
        {
            gtk_main_quit();
        }
    }
    public
    void
    new_window(self)
    {
        Self *ski;
        ski= stuffkeeper_interface_new();
        interface_list = g_list_append(interface_list, ski);
        stuffkeeper_interface_initialize_interface(ski,self->_priv->skdbg);
    }

    /**
     * Filtering the item list
     */
    public
        gboolean 
        interface_visible_func(GtkTreeModel *model, GtkTreeIter *iter, StuffKeeperInterface *self) 
        {
            GtkTreeModel *model2 = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            StuffKeeperDataItem *item;
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));
            const gchar *text = gtk_entry_get_text(GTK_ENTRY(self->_priv->search_entry));
            /* Get the item */
            gtk_tree_model_get(model, iter, 2,&item, -1);

            if(!item) {
                return FALSE;
            }

            GtkTreeIter piter;
            if(gtk_tree_model_get_iter_first(model2, &piter))
            {
                do{
                    GObject *tag;
                    gboolean sel;
                    /* get the tag, and if it is selected */
                    gtk_tree_model_get(model2, &piter,2,&sel, 3,&tag, -1);

                    if(sel && tag)
                    {
                        if(type == 0 && !stuffkeeper_data_item_has_tag(item, STUFFKEEPER_DATA_TAG(tag)))
                        {
                            return FALSE;
                        }
                        else if (type == 1 && 
                        stuffkeeper_data_schema_get_id(stuffkeeper_data_item_get_schema(item)) != stuffkeeper_data_schema_get_id(STUFFKEEPER_DATA_SCHEMA(tag)))
                        {
                            return FALSE;
                        }
                    }

                }while(gtk_tree_model_iter_next(model2, &piter));
            }

            if(strlen(text))
            {
                int found = 0;
                gsize length = 0;
                gchar **values = stuffkeeper_data_item_get_values(item, &length);
                int i;
                if(values)
                {
                    for(i=0;i<length && !found;i++)
                    {
                        if(values[i])
                            if(strstr(values[i], text)) found = TRUE;
                    }
                    g_strfreev(values);
                }
                return found;
            }

            return TRUE; 
        }
    public
    void
    search_entry_changed(self)
    {
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
    }

    public
        void 
        interface_entry_add(self,GtkWidget *button)
        {
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));
            if(type == 0) /* Add an tag */
            {
                StuffKeeperDataTag *tag;
                tag = stuffkeeper_data_backend_add_tag(self->_priv->skdbg,NULL,g_random_int());
                stuffkeeper_data_tag_set_title(tag, "New Tag");
            }
            else if(type == 1) /* Add new schema */
            {
                StuffKeeperDataSchema *schema;
                schema = stuffkeeper_data_backend_new_schema(self->_priv->skdbg);
                stuffkeeper_data_schema_set_title(schema, "New Schema");
            }
        }
    public
    void
    interface_header_changed(GtkWidget *widget, GtkStyle *old, GtkWidget *wid)
    {
        gtk_widget_modify_bg(GTK_WIDGET(wid), GTK_STATE_NORMAL, &(widget->style->bg[GTK_STATE_SELECTED]));
        gtk_widget_modify_fg(GTK_WIDGET(wid), GTK_STATE_NORMAL, &(widget->style->fg[GTK_STATE_SELECTED]));
        gtk_widget_modify_text(GTK_WIDGET(wid), GTK_STATE_NORMAL, &(widget->style->text[GTK_STATE_SELECTED]));
    }

    public
        void 
        interface_item_selection_changed (self, GtkTreeSelection *selection)
        {
            GtkTreeModel *model;
            GtkWidget *container,*tree,*event;
            GList *list;
            GtkWidget *event2 = NULL;
            /** Remove all old widgets */
            container = self->_priv->item_vbox; ///glade_xml_get_widget(xml, "item_vbox");

            event =  self->_priv->item_event_box;//glade_xml_get_widget(xml, "item_event_box");
            gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &(container->style->base[GTK_STATE_NORMAL]));

            list = gtk_container_get_children(GTK_CONTAINER(container));
            if(list)
            {
                GList *node;
                for(node = g_list_first(list); node; node = g_list_next(node))
                {
                    gtk_widget_destroy(GTK_WIDGET(node->data));
                }
                g_list_free(list);
            }
            /**/
            tree = self->_priv->treeview2;//glade_xml_get_widget(xml, "treeview2");



            model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    /* The title */
                    GtkWidget *vbox;
                    GtkWidget *label1;
                    event2 = gtk_event_box_new();
                    vbox = gtk_hbox_new(FALSE, 6);
                    /* Title */
                    label1 = gtk_label_new("");
                    gtk_label_set_markup(GTK_LABEL(label1), "<b>Title:</b>");
                    gtk_misc_set_alignment(GTK_MISC(label1), 1,0.5);
                    gtk_box_pack_start(GTK_BOX(vbox),label1, FALSE,TRUE, 0);
                    self_interface_header_changed(self->_priv->treeview1, NULL, label1);
                    g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_interface_header_changed),label1);            

                    label1 = stuffkeeper_data_entry_new(item,NULL);
                    gtk_box_pack_start(GTK_BOX(vbox),label1, TRUE,TRUE, 0);

                    /* type */
                    StuffKeeperDataSchema *schema = stuffkeeper_data_item_get_schema(item);
                    label1 =gtk_label_new("");
                    gtk_label_set_markup(GTK_LABEL(label1), "<b>Type:</b>");
                    gtk_box_pack_start(GTK_BOX(vbox),label1, FALSE,TRUE, 0);
                    self_interface_header_changed(self->_priv->treeview1, NULL, label1);
                    g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_interface_header_changed),label1);            

                    if(schema) {
                        label1 = stuffkeeper_data_label_new_schema(schema);
                    } else {
                        label1 = gtk_label_new("N/A");
                    }


                    gtk_box_pack_start(GTK_BOX(vbox),label1, FALSE,TRUE, 0);
                   
                    gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);

                    self_interface_header_changed(self->_priv->treeview1, NULL, event2);
                    g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_interface_header_changed),event2);            
                    self_interface_header_changed(self->_priv->treeview1, NULL, label1);
                    g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_interface_header_changed),label1);            

                    gtk_container_add(GTK_CONTAINER(event2), vbox);
                    gtk_box_pack_start(GTK_BOX(container),event2, FALSE,TRUE, 0);
                    label1 = gtk_label_new("");
                    gtk_label_set_markup(GTK_LABEL(label1),"<span weight='bold' size='x-large'>Fields:</span>");
                    gtk_misc_set_alignment(GTK_MISC(label1), 0,0.5);
                    gtk_misc_set_padding(GTK_MISC(label1), 0,8);
                    gtk_box_pack_start(GTK_BOX(container),label1, FALSE,TRUE, 0);

                    /**
                     * Get the attached schema and fill in the rest from there
                     */
                    if(schema)
                    {
                        gsize length;
                        gchar **retv = stuffkeeper_data_schema_get_fields(schema, &length);
                        /* num fields + one for the tags */
                        vbox = stuffkeeper_show_item_new(item);
                        gtk_table_set_row_spacings(GTK_TABLE(vbox), 6);
                        gtk_table_set_col_spacings(GTK_TABLE(vbox), 6);


                        gtk_box_pack_start(GTK_BOX(container),vbox, TRUE,TRUE, 0);
                        /**
                         * Fill in the Tag list 
                         */
                        /* Title */
                        vbox = gtk_hbox_new(FALSE,6);
                        label1 = gtk_label_new("");
                        gchar *val = g_markup_printf_escaped("<b>%s</b>", "Tags");
                        gtk_label_set_markup(GTK_LABEL(label1), val);
                        g_free(val);
                        gtk_misc_set_alignment(GTK_MISC(label1), 1,0);
                        gtk_box_pack_start(GTK_BOX(vbox), label1, FALSE, TRUE, 0);

                        label1 = stuffkeeper_data_taglist_new(self->_priv->skdbg,item);

                        gtk_table_set_row_spacings(GTK_TABLE(label1), 6);
                        gtk_table_set_col_spacings(GTK_TABLE(label1), 18);

                        gtk_box_pack_start(GTK_BOX(vbox), label1, FALSE, FALSE, 0);
                        

                        gtk_box_pack_start(GTK_BOX(container),vbox, FALSE,TRUE, 6);
                        g_strfreev(retv);
                    }

                }
            }
            gtk_widget_show_all(container);

        }

    public
        void 
        interface_remove_tag(self)
        {
            GtkWidget *tree = self->_priv->treeview1;
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));


            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
            GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(sel, &model, &iter))
            {
                if(type == 0) // tag
                {
                    StuffKeeperDataTag *tag;
                    gtk_tree_model_get(model, &iter, 3, &tag, -1);
                    if(tag)
                    {
                        if(stuffkeeper_data_tag_num_items(tag) > 0)
                        {
                            printf("This tag is not empty\n");
                        }
                        else
                        {
                            gint id = stuffkeeper_data_tag_get_id(tag); 
                            printf("removing item: %i\n", id);
                            stuffkeeper_data_backend_remove_tag(self->_priv->skdbg,id);
                        }
                    }
                }
                else if(type == 1) // schema
                {
                    StuffKeeperDataSchema *schema;
                    gtk_tree_model_get(model, &iter, 3, &schema, -1);
                    if(schema)
                    {
                        if(stuffkeeper_data_schema_num_items(schema) > 0)
                        {
                            printf("This schema is not empty\n");
                        }
                        else
                        {
                            gint id = stuffkeeper_data_schema_get_id(schema); 
                            printf("removing scema: %i\n", id);
                            stuffkeeper_data_backend_remove_schema(self->_priv->skdbg,id);
                        }
                    }
                }
            }
        }

    public
        StuffKeeperInterface * 
        new(void)
        {
            Self *self = GET_NEW;

            self->_priv->xml = glade_xml_new(PACKAGE_DATADIR"/stuffkeeper.glade","win",NULL);
            if(self->_priv->xml == NULL)
            {
                g_object_unref(self);
                printf("Failed top open xml file\n");
                return NULL;
            }
            self->_priv->LeftPaneCB  = glade_xml_get_widget(self->_priv->xml, "LeftPaneCB");
            self->_priv->treeview1 = glade_xml_get_widget(self->_priv->xml, "treeview1");
            self->_priv->treeview2 = glade_xml_get_widget(self->_priv->xml, "treeview2");
            self->_priv->item_vbox = glade_xml_get_widget(self->_priv->xml, "item_vbox");
            self->_priv->item_event_box = glade_xml_get_widget(self->_priv->xml, "item_event_box");

            self->_priv->LeftPane_edit = glade_xml_get_widget(self->_priv->xml, "LeftPane_edit");
            self->_priv->AddMenuButton = glade_xml_get_widget(self->_priv->xml, "AddMenuButton");
            self->_priv->search_entry = glade_xml_get_widget(self->_priv->xml, "search_entry");
            self->_priv->item_label = glade_xml_get_widget(self->_priv->xml, "item_label");
            
            self->_priv->win = glade_xml_get_widget(self->_priv->xml, "win");

            glade_xml_signal_autoconnect_full(self->_priv->xml, (GladeXMLConnectFunc)self____glade_xml_connect_foreach, (gpointer)self);
            return self;
        }

    public
    void
    left_pane_changed(self, GtkComboBox *box)
    {
        int i = gtk_combo_box_get_active(box);
        if(i==0){
            gtk_widget_set_sensitive(self->_priv->LeftPane_edit, FALSE);
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_tags));
        }else{
            gtk_widget_set_sensitive(self->_priv->LeftPane_edit,TRUE);
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_schemas));
        }
        /* refilter the items list */
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
    }

    public
    void
    interface_edit(self,GtkWidget *button)
    {
        GtkWidget *tree = self->_priv->treeview1;
        int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));


        GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
        GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree));
        GtkTreeIter iter;

        if(type == 1) // schema
        {
            if(gtk_tree_selection_get_selected(sel, &model, &iter))
            {
                StuffKeeperDataSchema *schema;
                gtk_tree_model_get(model, &iter, 3, &schema, -1);
                if(schema)
                {
                    StuffKeeperEditSchema *skes = stuffkeeper_edit_schema_new();
                    stuffkeeper_edit_schema_set_schema(skes, schema);
                }
            }

        }
    }
    /* Add item menu */

    public
    void
    interface_item_add_menu(self, GtkWidget *but)
    {
        printf("show menu\n");

    }

    public
    void
    style_changed(GtkWidget *tree,GtkStyle *old, GtkCellRenderer *renderer)
    {
            printf("style changed\n");
            g_object_set(G_OBJECT(renderer), 
                    "background-set", TRUE, "background-gdk",&(GTK_WIDGET(tree)->style->bg[GTK_STATE_SELECTED]), 
                    "foreground-set", TRUE, "foreground-gdk",&(GTK_WIDGET(tree)->style->fg[GTK_STATE_SELECTED]), 
                    NULL);
    }
    /**
     * Initialize the main gui
     */
    public
        void 
        initialize_interface(self, StuffKeeperDataBackend *skdb)
        {
            GList *iter, *node;
            GtkTreeViewColumn *column;
            GtkCellRenderer *renderer;
            GtkTreeSelection *sel;
            /**
             * StuffKeeperDataBackend
             */
            self->_priv->skdbg = skdb;



            self->_priv->menu = gtk_menu_new();
            gtk_menu_tool_button_set_menu(GTK_MENU_TOOL_BUTTON(self->_priv->AddMenuButton), (self->_priv->menu));




            /* Setting up backends */
            self->_priv->model_schemas = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER,G_TYPE_INT);
            /** Load the schemas*/
            node = stuffkeeper_data_backend_get_schemas(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_schema_added(self, STUFFKEEPER_DATA_SCHEMA(iter->data), self->_priv->skdbg);
            }
            if(node) g_list_free(node);

            self->_priv->signal_schema_added = g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), "schema-added",   G_CALLBACK(self_schema_added),self); 
            self->_priv->signal_schema_removed =g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), "schema-removed", G_CALLBACK(self_schema_removed),self);
            self->_priv->signal_schema_changed=g_signal_connect_swapped(G_OBJECT(self->_priv->skdbg), "schema-changed", G_CALLBACK(self_schema_changed),self);





            /* Tags */
            self->_priv->model_tags = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER,G_TYPE_INT);
            /** Load the tags */
            node = stuffkeeper_data_backend_get_tags(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_tag_added(self->_priv->skdbg, iter->data,self->_priv->model_tags);
            }
            if(node) g_list_free(node);
            /* handle an added tag */
            self->_priv->signal_tag_added = g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-added",G_CALLBACK(self_tag_added),self->_priv->model_tags);
             self->_priv->signal_tag_changed = g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-changed",G_CALLBACK(self_tag_changed),self->_priv->model_tags);
              self->_priv->signal_tag_removed = g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-removed",G_CALLBACK(self_tag_removed),self->_priv->model_tags);

            self->_priv->model_items = (GtkTreeModel *)gtk_list_store_new(3, G_TYPE_INT,G_TYPE_STRING,G_TYPE_POINTER);
            /** Load the items*/
            node = stuffkeeper_data_backend_get_items(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_item_added(self->_priv->skdbg, STUFFKEEPER_DATA_ITEM(iter->data),self->_priv->model_items);
            }
            if(node) g_list_free(node);
            self->_priv->signal_item_added = g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-added",   G_CALLBACK(self_item_added),self); 
            self->_priv->signal_item_removed = g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-removed", G_CALLBACK(self_item_removed),self);
            self->_priv->signal_item_changed = g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-changed", G_CALLBACK(self_item_changed),self);





            /**
             * Items
             */
            /* A filtered items */
            self->_priv->model_items_filter = gtk_tree_model_filter_new(GTK_TREE_MODEL(self->_priv->model_items), NULL);
            renderer = gtk_cell_renderer_pixbuf_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->treeview2), -1, "test", renderer, NULL);
            g_object_set(renderer, "icon-name", "gtk-new", NULL);
            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->treeview2), -1, "items", renderer, "text", 1, NULL);
            g_object_set(renderer, "editable", TRUE,NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_item_title_edited), self);

            /* Look at the tree */
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview2), GTK_TREE_MODEL(self->_priv->model_items_filter));

            /* get changed selection */
            sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            g_signal_connect_swapped(G_OBJECT(sel), "changed", G_CALLBACK(self_interface_item_selection_changed), self);

            /* Tag list */
            gtk_tree_model_filter_set_visible_func(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter), 
                    (GtkTreeModelFilterVisibleFunc)self_interface_visible_func, self, NULL);



            /* TAGS */
            column = gtk_tree_view_column_new();

            /* Toggle button  */

            renderer = gtk_cell_renderer_toggle_new();
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE);
            gtk_tree_view_column_set_attributes(column, renderer, "active", 2, NULL);
            /* handle toggled */
            g_signal_connect_swapped(G_OBJECT(renderer), "toggled", G_CALLBACK(self_interface_left_pane_toggled), self);

            /* Tag name */
            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, TRUE);
            gtk_tree_view_column_set_attributes(column, renderer, "text", 1, NULL);
            g_object_set(renderer, "editable", TRUE,NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_left_pane_edited), self);

            /* Number of items */
            renderer = gtk_cell_renderer_text_new();
            g_object_set(G_OBJECT(renderer), 
                    "background-set", TRUE, "background-gdk",&(GTK_WIDGET(self->_priv->treeview1)->style->bg[GTK_STATE_SELECTED]), 
                    "foreground-set", TRUE, "foreground-gdk",&(GTK_WIDGET(self->_priv->treeview1)->style->fg[GTK_STATE_SELECTED]), 
                    NULL);
            g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_style_changed), renderer);            


            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE);
            gtk_tree_view_column_set_attributes(column, renderer, "text", 4, NULL);

            gtk_tree_view_append_column(GTK_TREE_VIEW(self->_priv->treeview1), column);

            gtk_combo_box_set_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB), 0);


            /** initial setup the list */
            gchar *data = g_strdup_printf("%i", stuffkeeper_data_backend_get_num_items(skdb));
            gtk_label_set_text(GTK_LABEL(self->_priv->item_label), data);
            g_free(data);





            //glade_xml_signal_autoconnect(xml);
            /*gtk_window_resize(GTK_WINDOW(self), 800,600);
            gtk_widget_show(GTK_WIDGET(self));
            */
            gtk_widget_show(self->_priv->win);
        }

        override (G:Object)
        void
        finalize(G:Object *obj)
        {
            Self *self = SELF(obj);
            printf("** Finalize stuffkeeper interface\n");
            if(self->_priv->signal_schema_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_schema_added);
                self->_priv->signal_schema_added = 0;
            }
            if(self->_priv->signal_schema_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_schema_changed);
                self->_priv->signal_schema_changed = 0;
            }
            if(self->_priv->signal_schema_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_schema_removed);
                self->_priv->signal_schema_removed = 0;
            }

            if(self->_priv->signal_item_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_item_added);
                self->_priv->signal_item_added = 0;
            }
            if(self->_priv->signal_item_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_item_changed);
                self->_priv->signal_item_changed = 0;
            }
            if(self->_priv->signal_item_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_item_removed);
                self->_priv->signal_item_removed = 0;
            }

            if(self->_priv->signal_tag_added) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_tag_added);
                self->_priv->signal_tag_added = 0;
            }
            if(self->_priv->signal_tag_changed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_tag_changed);
                self->_priv->signal_tag_changed = 0;
            }
            if(self->_priv->signal_tag_removed) { 
                g_signal_handler_disconnect(G_OBJECT(self->_priv->skdbg), self->_priv->signal_tag_removed);
                self->_priv->signal_tag_removed = 0;
            }
        }
        /**
         * Item popup
         */
        public 
        void
        item_row_activated(self, GtkTreePath *path, GtkTreeViewColumn *column, GtkTreeView *view)
        {

            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            printf("item row activated\n");
            if(gtk_tree_model_get_iter(model,&iter, path)) 
            {
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    self_popup_item(self, item);
                }
            }
        }

        /**
         * Popup an item list
         * TODO: Check it item is destroyed, and if it is remove the window
         */
        public
        void 
        popup_item(self, StuffKeeper:Data:Item *item)
        {
            stuffkeeper_item_window_new(self->_priv->skdbg, item);

        }

    private
    void
        ___glade_xml_connect_foreach(const gchar *handler_name,
                GObject *object,
                const gchar *signal_name,
                const gchar *signal_data,
                GObject *connect_object,
                gboolean after,
                gpointer user_data)
        {
            static GModule * allsymbols = NULL;

            if (!allsymbols) allsymbols = g_module_open(NULL, 0);
            if (allsymbols) {
                gchar * func_name = g_strdup_printf("stuffkeeper_interface_%s", handler_name);
                GCallback func;

                if (!g_module_symbol(allsymbols, func_name, (gpointer)&func)){
                    if (!g_module_symbol(allsymbols, handler_name, (gpointer)&func)) {
                        g_warning("could not find signal handler '%s'.", func_name);
                        g_free(func_name);
                        return;
                    }
                }
                if (after)
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_AFTER | G_CONNECT_SWAPPED);
                else
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_SWAPPED);
                g_free(func_name);
            }
        }
}
