requires 2.0.10

%h{
/* Include gtk */
#include <gtk/gtk.h>
#include <glade/glade.h>
/* Include the database */

#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-data-schema.h"
#include "stuffkeeper-data-label.h"
#include "stuffkeeper-data-entry.h"
#include "stuffkeeper-data-boolean.h"
#include "stuffkeeper-data-spinbutton.h"
#include "stuffkeeper-data-rating.h"
#include "stuffkeeper-data-taglist.h"
#include "stuffkeeper-edit-schema.h"
#include "stuffkeeper-show-item.h"

extern GList *interface_list;
%}


class StuffKeeper:Interface from Gtk:Window (GladeXML "stuffkeeper.glade" "win")
{
    private GtkTreeModel *model_tags = {NULL};
    private GtkTreeModel *model_items= {NULL};
    private GtkTreeModel *model_schemas = {NULL};

    private GtkTreeModel *model_items_filter = {NULL};
    /**
     * Treeview 1 & 2
     */
    private GtkWidget *LeftPaneCB GladeXML;
    private GtkWidget *treeview1 GladeXML;
    private GtkWidget *treeview2 GladeXML;
    private GtkWidget *item_vbox GladeXML;
    private GtkWidget *item_event_box GladeXML;
    private StuffKeeperDataBackend *skdbg = {NULL};
    private GtkWidget *LeftPane_edit GladeXML;
    /**
     * Keep Schema's GtkListStore up2date
     */
    public
    void 
    schema_added(StuffKeeperDataBackend *skdb, StuffKeeperDataSchema *schema, GtkTreeModel *store)
    {
        GtkTreeIter iter;
        gtk_list_store_append(GTK_LIST_STORE(store), &iter);
        gchar *title = stuffkeeper_data_schema_get_title(schema);
        gtk_list_store_set(GTK_LIST_STORE(store), &iter, 0, stuffkeeper_data_schema_get_id(schema),1,title,3,schema, 4, stuffkeeper_data_schema_num_items(schema),-1);
        g_free(title);
    }
    public
    void 
    schema_changed(StuffKeeperDataBackend *skdb, StuffKeeperDataSchema *schema, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_schema_get_id(schema);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_schema_get_title(schema);
                    gtk_list_store_set(GTK_LIST_STORE(store), &iter, 1,title, 4, stuffkeeper_data_schema_num_items(schema),-1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void 
    schema_removed(StuffKeeperDataBackend *skdb, gint id, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    /**
     * Keep Tag's GtkListStore up2date
     */
    public
    void 
    tag_added(StuffKeeperDataBackend *skdb, StuffKeeperDataTag *tag, GtkTreeModel *store)
    {
        GtkTreeIter iter;
        gtk_list_store_append(GTK_LIST_STORE(store), &iter);
        gchar *title = stuffkeeper_data_tag_get_title(tag);
        gtk_list_store_set(GTK_LIST_STORE(store), &iter, 0, stuffkeeper_data_tag_get_id(tag),1,title,3,tag, 4, stuffkeeper_data_tag_num_items(tag),-1);
        g_free(title);
    }
    public
    void 
    tag_changed(StuffKeeperDataBackend *skdb, StuffKeeperDataTag *tag, GtkTreeModel *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_tag_get_id(tag);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_tag_get_title(tag);
                    gtk_list_store_set(GTK_LIST_STORE(store), &iter, 1,title, 4, stuffkeeper_data_tag_num_items(tag),-1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void 
    tag_removed(StuffKeeperDataBackend *skdb, gint id, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    /**
     * Item GtkListStore
     * Update the gtk-list-store with signals from the backend
     */
    public
    void
    item_removed(StuffKeeperDataBackend *skdb, gint id, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gtk_list_store_remove(store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    public
    void
    item_added(StuffKeeperDataBackend *skdb, StuffKeeperDataItem *item, GtkTreeModel *store)
    {
        GtkTreeIter iter;
        gtk_list_store_append(GTK_LIST_STORE(store), &iter);
        gchar *title = stuffkeeper_data_item_get_title(item);
        gtk_list_store_set(GTK_LIST_STORE(store), &iter, 0, stuffkeeper_data_item_get_id(item),1,title, 2,item,-1);
        g_free(title);


    }
    public
    void
    item_changed(StuffKeeperDataBackend *skdb, StuffKeeperDataItem *item, GtkListStore *store)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(store);
        gint id = stuffkeeper_data_item_get_id(item);
        if(gtk_tree_model_get_iter_first(model, &iter))
        {
            do{
                gint oid;
                gtk_tree_model_get(model, &iter, 0, &oid, -1);
                if(oid == id)
                {
                    gchar *title = stuffkeeper_data_item_get_title(item);
                    printf("Item items: %i\n", id);
                    gtk_list_store_set(store, &iter, 1,title, -1);
                    g_free(title);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }


    /**
     * Add item button clicked 
     */
    public
        void 
        interface_item_add(self)
        {


            /** TODO, set schema */
            GList *list = stuffkeeper_data_backend_get_schemas(self->_priv->skdbg);
            if(list)
            {
                StuffKeeperDataItem *item = stuffkeeper_data_backend_new_item(self->_priv->skdbg,list->data);
                stuffkeeper_data_item_set_title(item,"New Item");
                g_list_free(list);
            }

        }
    /**
     * Remove selected item
     */
    public
        void interface_item_remove(self)
        {
            GtkWidget *tree = self->_priv->treeview2;//glade_xml_get_widget(xml, "treeview2");
            GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree));
            GtkTreeModel *model = GTK_TREE_MODEL(gtk_tree_view_get_model(GTK_TREE_VIEW(tree)));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {
                gint id;
                gtk_tree_model_get(model, &iter ,0,&id, -1);
                printf("requesting removal of: %i\n", id);
                stuffkeeper_data_backend_remove_item(self->_priv->skdbg, id);

            }
        }

    /**
     * Tag is enabled/disabled
     */
    public
        void 
        interface_left_pane_toggled(self, gchar *path, GtkCellRendererToggle *renderer)
        {
            GtkTreeIter iter;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gboolean value = !gtk_cell_renderer_toggle_get_active(renderer);
                gtk_list_store_set(GTK_LIST_STORE(model), &iter, 2,value,-1);

                /* refilter the items list */
                gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
            }
        }

    public
        void interface_item_title_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview2));
            GtkTreeIter iter;
            printf("edited: %s\n", new_text);
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gint id;
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter ,0,&id, -1);
                printf("get item: %i\n",id);
                item = stuffkeeper_data_backend_get_item(self->_priv->skdbg, id);
                if(item)
                {
                    stuffkeeper_data_item_set_title(item, new_text);
                }

            }
        }

    public
        void interface_left_pane_edited 
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )

        {
            GtkTreeIter iter;
            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                GObject *item;

                gtk_tree_model_get(model, &iter ,3,&item, -1);

                if(STUFFKEEPER_IS_DATA_TAG(item))
                {
                    stuffkeeper_data_tag_set_title(STUFFKEEPER_DATA_TAG(item), new_text);
                }else if (STUFFKEEPER_IS_DATA_SCHEMA(item)){
                    stuffkeeper_data_schema_set_title(STUFFKEEPER_DATA_SCHEMA(item), new_text);
                }
                

            }
        }
    /**
     * Quit the program
     */
    public
        void quit_program(void)
        {
            gtk_main_quit();
        }

    public 
    void
    close_window(self)
    {
        int n;
        interface_list = g_list_remove(interface_list, self);
        n = g_list_length(interface_list);
        printf("%i interfaces left\n", n);
        gtk_widget_destroy(GTK_WIDGET(self));
        if(n == 0)
        {
            gtk_main_quit();
        }
    }
    public
    void
    new_window(self)
    {
        Self *ski;
        ski= stuffkeeper_interface_new();
        interface_list = g_list_append(interface_list, ski);
        stuffkeeper_interface_initialize_interface(ski,self->_priv->skdbg);
    }

    /**
     * Filtering the item list
     */
    public
        gboolean 
        interface_visible_func(GtkTreeModel *model, GtkTreeIter *iter, StuffKeeperInterface *self) 
        {
            GtkTreeModel *model2 = gtk_tree_view_get_model(GTK_TREE_VIEW(self->_priv->treeview1));
            StuffKeeperDataItem *item;
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));

            /* Get the item */
            gtk_tree_model_get(model, iter, 2,&item, -1);

            if(!item) {
                return FALSE;
            }

            GtkTreeIter piter;
            if(gtk_tree_model_get_iter_first(model2, &piter))
            {
                do{
                    GObject *tag;
                    gboolean sel;
                    /* get the tag, and if it is selected */
                    gtk_tree_model_get(model2, &piter,2,&sel, 3,&tag, -1);

                    if(sel && tag)
                    {
                        if(type == 0 && !stuffkeeper_data_item_has_tag(item, STUFFKEEPER_DATA_TAG(tag)))
                        {
                            return FALSE;
                        }
                        else if (type == 1 && 
                        stuffkeeper_data_schema_get_id(stuffkeeper_data_item_get_schema(item)) != stuffkeeper_data_schema_get_id(STUFFKEEPER_DATA_SCHEMA(tag)))
                        {
                            return FALSE;
                        }
                    }

                }while(gtk_tree_model_iter_next(model2, &piter));
            }

            return TRUE; 
        }

    public
        void 
        interface_entry_add(self,GtkWidget *button)
        {
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));
            if(type == 0) /* Add an tag */
            {
                StuffKeeperDataTag *tag;
                tag = stuffkeeper_data_backend_add_tag(self->_priv->skdbg,NULL,g_random_int());
                stuffkeeper_data_tag_set_title(tag, "New Tag");
            }
            else if(type == 1) /* Add new schema */
            {
                StuffKeeperDataSchema *schema;
                schema = stuffkeeper_data_backend_new_schema(self->_priv->skdbg);
                stuffkeeper_data_schema_set_title(schema, "New Schema");
            }
        }
    public
    void
    interface_header_changed(GtkWidget *widget, GtkStyle *old, GtkWidget *wid)
    {
        printf("style changed\n");
        gtk_widget_modify_bg(GTK_WIDGET(wid), GTK_STATE_NORMAL, &(widget->style->bg[GTK_STATE_SELECTED]));
        gtk_widget_modify_fg(GTK_WIDGET(wid), GTK_STATE_NORMAL, &(widget->style->fg[GTK_STATE_SELECTED]));
        gtk_widget_modify_text(GTK_WIDGET(wid), GTK_STATE_NORMAL, &(widget->style->text[GTK_STATE_SELECTED]));
    }

    public
        void 
        interface_item_selection_changed (self, GtkTreeSelection *selection)
        {
            GtkTreeModel *model;
            GtkWidget *container,*tree,*event;
            GList *list;
            GtkWidget *event2 = NULL;
            /** Remove all old widgets */
            container = self->_priv->item_vbox; ///glade_xml_get_widget(xml, "item_vbox");

            event =  self->_priv->item_event_box;//glade_xml_get_widget(xml, "item_event_box");
            gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &(container->style->white));

            list = gtk_container_get_children(GTK_CONTAINER(container));
            if(list)
            {
                GList *node;
                for(node = g_list_first(list); node; node = g_list_next(node))
                {
                    gtk_widget_destroy(GTK_WIDGET(node->data));
                }
                g_list_free(list);
            }
            /**/
            tree = self->_priv->treeview2;//glade_xml_get_widget(xml, "treeview2");



            model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(selection, &model, &iter))
            {
                StuffKeeperDataItem *item;
                gtk_tree_model_get(model, &iter, 2, &item, -1);
                if(item)
                {
                    /* The title */
                    GtkWidget *vbox;
                    GtkWidget *label1;
                    event2 = gtk_event_box_new();
                    vbox = gtk_hbox_new(FALSE, 6);
                    /* Title */
                    label1 = gtk_label_new("");
                    gtk_label_set_markup(GTK_LABEL(label1), "<b>Title:</b>");
                    gtk_misc_set_alignment(GTK_MISC(label1), 1,0.5);
                    gtk_box_pack_start(GTK_BOX(vbox),label1, FALSE,TRUE, 0);
                    self_interface_header_changed(self->_priv->treeview1, NULL, label1);
                    g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_interface_header_changed),label1);            

                    label1 = stuffkeeper_data_entry_new(item,NULL);
                    gtk_box_pack_start(GTK_BOX(vbox),label1, TRUE,TRUE, 0);

                    /* type */
                    StuffKeeperDataSchema *schema = stuffkeeper_data_item_get_schema(item);
                    label1 =gtk_label_new("");
                    gtk_label_set_markup(GTK_LABEL(label1), "<b>Type:</b>");
                    gtk_box_pack_start(GTK_BOX(vbox),label1, FALSE,TRUE, 0);
                    self_interface_header_changed(self->_priv->treeview1, NULL, label1);
                    g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_interface_header_changed),label1);            

                    if(schema) {
                        label1 = stuffkeeper_data_label_new_schema(schema);
                    } else {
                        label1 = gtk_label_new("N/A");
                    }


                    gtk_box_pack_start(GTK_BOX(vbox),label1, FALSE,TRUE, 0);
                   
                    gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);

                    self_interface_header_changed(self->_priv->treeview1, NULL, event2);
                    g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_interface_header_changed),event2);            
                    self_interface_header_changed(self->_priv->treeview1, NULL, label1);
                    g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_interface_header_changed),label1);            

                    gtk_container_add(GTK_CONTAINER(event2), vbox);
                    gtk_box_pack_start(GTK_BOX(container),event2, FALSE,TRUE, 0);
                    label1 = gtk_label_new("");
                    gtk_label_set_markup(GTK_LABEL(label1),"<span weight='bold' size='x-large'>Fields:</span>");
                    gtk_misc_set_alignment(GTK_MISC(label1), 0,0.5);
                    gtk_misc_set_padding(GTK_MISC(label1), 0,8);
                    gtk_box_pack_start(GTK_BOX(container),label1, FALSE,TRUE, 0);

                    /**
                     * Get the attached schema and fill in the rest from there
                     */
                    if(schema)
                    {
                        gsize length;
                        gchar **retv = stuffkeeper_data_schema_get_fields(schema, &length);
                        /* num fields + one for the tags */
                        vbox = stuffkeeper_show_item_new(item);
                        gtk_table_set_row_spacings(GTK_TABLE(vbox), 6);
                        gtk_table_set_col_spacings(GTK_TABLE(vbox), 6);


                        gtk_box_pack_start(GTK_BOX(container),vbox, FALSE,TRUE, 0);
                        /**
                         * Fill in the Tag list 
                         */
                        /* Title */
                        vbox = gtk_hbox_new(FALSE,6);
                        label1 = gtk_label_new("");
                        gchar *val = g_markup_printf_escaped("<b>%s</b>", "Tags");
                        gtk_label_set_markup(GTK_LABEL(label1), val);
                        g_free(val);
                        gtk_misc_set_alignment(GTK_MISC(label1), 1,0.5);
                        gtk_box_pack_start(GTK_BOX(vbox), label1, FALSE, TRUE, 0);

                        label1 = stuffkeeper_data_taglist_new(self->_priv->skdbg,item);
                        gtk_box_pack_start(GTK_BOX(vbox), label1, TRUE, TRUE, 0);

                        gtk_box_pack_start(GTK_BOX(container),vbox, FALSE,TRUE, 0);
                        g_strfreev(retv);
                    }

                }
            }
            gtk_widget_show_all(container);

        }

    public
        void 
        interface_remove_tag(self)
        {
            GtkWidget *tree = self->_priv->treeview1;
            int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));


            GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
            GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree));
            GtkTreeIter iter;
            if(gtk_tree_selection_get_selected(sel, &model, &iter))
            {
                if(type == 0) // tag
                {
                    StuffKeeperDataTag *tag;
                    gtk_tree_model_get(model, &iter, 3, &tag, -1);
                    if(tag)
                    {
                        if(stuffkeeper_data_tag_num_items(tag) > 0)
                        {
                            printf("This tag is not empty\n");
                        }
                        else
                        {
                            gint id = stuffkeeper_data_tag_get_id(tag); 
                            printf("removing item: %i\n", id);
                            stuffkeeper_data_backend_remove_tag(self->_priv->skdbg,id);
                        }
                    }
                }
                else if(type == 1) // schema
                {
                    StuffKeeperDataSchema *schema;
                    gtk_tree_model_get(model, &iter, 3, &schema, -1);
                    if(schema)
                    {
                        if(stuffkeeper_data_schema_num_items(schema) > 0)
                        {
                            printf("This schema is not empty\n");
                        }
                        else
                        {
                            gint id = stuffkeeper_data_schema_get_id(schema); 
                            printf("removing scema: %i\n", id);
                            stuffkeeper_data_backend_remove_schema(self->_priv->skdbg,id);
                        }
                    }
                }
            }
        }

    public
        StuffKeeperInterface * 
        new(void)
        {
            return GET_NEW;
        }

    public
    void
    left_pane_changed(self, GtkComboBox *box)
    {
        int i = gtk_combo_box_get_active(box);
        if(i==0){
            gtk_widget_set_sensitive(self->_priv->LeftPane_edit, FALSE);
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_tags));
        }else{
            gtk_widget_set_sensitive(self->_priv->LeftPane_edit,TRUE);
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview1), GTK_TREE_MODEL(self->_priv->model_schemas));
        }
        /* refilter the items list */
        gtk_tree_model_filter_refilter(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter));
    }

    public
    void
    interface_edit(self,GtkWidget *button)
    {
        GtkWidget *tree = self->_priv->treeview1;
        int type = gtk_combo_box_get_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB));


        GtkTreeModel *model = gtk_tree_view_get_model(GTK_TREE_VIEW(tree));
        GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(tree));
        GtkTreeIter iter;

        if(type == 1) // schema
        {
            if(gtk_tree_selection_get_selected(sel, &model, &iter))
            {
                StuffKeeperDataSchema *schema;
                gtk_tree_model_get(model, &iter, 3, &schema, -1);
                if(schema)
                {
                    StuffKeeperEditSchema *skes = stuffkeeper_edit_schema_new();
                    stuffkeeper_edit_schema_set_schema(skes, schema);
                }
            }

        }
    }

    public
    void
    style_changed(GtkWidget *tree,GtkStyle *old, GtkCellRenderer *renderer)
    {
            printf("style changed\n");
            g_object_set(G_OBJECT(renderer), 
                    "background-set", TRUE, "background-gdk",&(GTK_WIDGET(tree)->style->bg[GTK_STATE_SELECTED]), 
                    "foreground-set", TRUE, "foreground-gdk",&(GTK_WIDGET(tree)->style->fg[GTK_STATE_SELECTED]), 
                    NULL);
    }
    /**
     * Initialize the main gui
     */
    public
        void 
        initialize_interface(self, StuffKeeperDataBackend *skdb)
        {
            GList *iter, *node;
            GtkTreeViewColumn *column;
            GtkCellRenderer *renderer;
            GtkTreeSelection *sel;
            /**
             * StuffKeeperDataBackend
             */
            self->_priv->skdbg = skdb;

            /* Setting up backends */
            self->_priv->model_schemas = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER,G_TYPE_INT);
            /** Load the schemas*/
            node = stuffkeeper_data_backend_get_schemas(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_schema_added(self->_priv->skdbg, iter->data,self->_priv->model_schemas);
            }
            if(node) g_list_free(node);

            g_signal_connect(G_OBJECT(self->_priv->skdbg), "schema-added",   G_CALLBACK(self_schema_added), self->_priv->model_schemas);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "schema-removed", G_CALLBACK(self_schema_removed),self->_priv->model_schemas);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "schema-changed", G_CALLBACK(self_schema_changed),self->_priv->model_schemas);





            /* Tags */
            self->_priv->model_tags = (GtkTreeModel *)gtk_list_store_new(5, G_TYPE_INT,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_POINTER,G_TYPE_INT);
            /** Load the tags */
            node = stuffkeeper_data_backend_get_tags(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_tag_added(self->_priv->skdbg, iter->data,self->_priv->model_tags);
            }
            if(node) g_list_free(node);
            /* handle an added tag */
            g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-added",G_CALLBACK(self_tag_added),self->_priv->model_tags);
            g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-changed",G_CALLBACK(self_tag_changed),self->_priv->model_tags);
            g_signal_connect(G_OBJECT(self->_priv->skdbg),"tag-removed",G_CALLBACK(self_tag_removed),self->_priv->model_tags);

            self->_priv->model_items = (GtkTreeModel *)gtk_list_store_new(3, G_TYPE_INT,G_TYPE_STRING,G_TYPE_POINTER);
            /** Load the items*/
            node = stuffkeeper_data_backend_get_items(self->_priv->skdbg);
            for(iter = node;iter;iter = g_list_next(iter))
            {
                self_item_added(self->_priv->skdbg, STUFFKEEPER_DATA_ITEM(iter->data),self->_priv->model_items);
            }
            if(node) g_list_free(node);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-added",   G_CALLBACK(self_item_added), self->_priv->model_items);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-removed", G_CALLBACK(self_item_removed),self->_priv->model_items);
            g_signal_connect(G_OBJECT(self->_priv->skdbg), "item-changed", G_CALLBACK(self_item_changed),self->_priv->model_items);





            /**
             * Items
             */
            /* A filtered items */
            self->_priv->model_items_filter = gtk_tree_model_filter_new(GTK_TREE_MODEL(self->_priv->model_items), NULL);

            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->treeview2), -1, "test", renderer, "text", 1, NULL);
            g_object_set(renderer, "editable", TRUE,NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_item_title_edited), self);

            /* Look at the tree */
            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->treeview2), GTK_TREE_MODEL(self->_priv->model_items_filter));

            /* get changed selection */
            sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->treeview2));
            g_signal_connect_swapped(G_OBJECT(sel), "changed", G_CALLBACK(self_interface_item_selection_changed), self);

            /* Tag list */
            gtk_tree_model_filter_set_visible_func(GTK_TREE_MODEL_FILTER(self->_priv->model_items_filter), 
                    (GtkTreeModelFilterVisibleFunc)self_interface_visible_func, self, NULL);



            /* TAGS */
            column = gtk_tree_view_column_new();

            /* Toggle button  */

            renderer = gtk_cell_renderer_toggle_new();
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE);
            gtk_tree_view_column_set_attributes(column, renderer, "active", 2, NULL);
            /* handle toggled */
            g_signal_connect_swapped(G_OBJECT(renderer), "toggled", G_CALLBACK(self_interface_left_pane_toggled), self);

            /* Tag name */
            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, TRUE);
            gtk_tree_view_column_set_attributes(column, renderer, "text", 1, NULL);
            g_object_set(renderer, "editable", TRUE,NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_left_pane_edited), self);

            /* Number of items */
            renderer = gtk_cell_renderer_text_new();
            g_object_set(G_OBJECT(renderer), 
                    "background-set", TRUE, "background-gdk",&(GTK_WIDGET(self->_priv->treeview1)->style->bg[GTK_STATE_SELECTED]), 
                    "foreground-set", TRUE, "foreground-gdk",&(GTK_WIDGET(self->_priv->treeview1)->style->fg[GTK_STATE_SELECTED]), 
                    NULL);
            g_signal_connect(self->_priv->treeview1, "style-set", G_CALLBACK(self_style_changed), renderer);            


            gtk_tree_view_column_pack_start(GTK_TREE_VIEW_COLUMN(column), renderer, FALSE);
            gtk_tree_view_column_set_attributes(column, renderer, "text", 4, NULL);

            gtk_tree_view_append_column(GTK_TREE_VIEW(self->_priv->treeview1), column);

            gtk_combo_box_set_active(GTK_COMBO_BOX(self->_priv->LeftPaneCB), 0);



            //glade_xml_signal_autoconnect(xml);
        }
}
