requires 2.0.10

%h{
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gtk/gtk.h>
#include <sqlite3.h>

%}

%ph{
#include <stdio.h>
#include "debug.h"
#include <glib/gstdio.h>
#include "stuffkeeper-data-backend.h"


#include "stuffkeeper-data-item.h"
#define ICON_SIZE 16
%}
%h{
    typedef enum _FieldType{
        FIELD_TYPE_STRING = 0,
        FIELD_TYPE_INTEGER = 1,
        FIELD_TYPE_BOOLEAN = 2,
        FIELD_TYPE_RATING = 3,
        FIELD_TYPE_LIST = 4,
        FIELD_TYPE_TEXT = 5,
        FIELD_TYPE_IMAGE = 6,
        FIELD_TYPE_LINK = 7,
        FIELD_TYPE_DATE = 8,
        FIELD_TYPE_NUM_FIELDS
    } FieldType;
    extern char *FieldNames[FIELD_TYPE_NUM_FIELDS];
%}
%ph{
        char *FieldNames[FIELD_TYPE_NUM_FIELDS] = {
        "String",   // FIELD_TYPE_STRING
        "Integer",  // FIELD_TYPE_INTEGER
        "Boolean",  // FIELD_TYPE_BOOLEAN
        "Slider",   // FIELD_TYPE_RATING
        "List",     // FIELD_TYPE_LIST
        "Text",     // FIELD_TYPE_TEXT
        "Image",     // FIELD_TYPE_IMAGE
        "Link",     // FIELD_TYPE_LINK
        "Date & Time",     // FIELD_TYPE_DATE
    };

    typedef struct _a { char *id; int pos; }a;
%}
%h{
    typedef enum _DbSchemaType {
        DB_SCHEMAS_TYPE_ID = 1,
        DB_SCHEMAS_TYPE_MTIME = 2,
        DB_SCHEMAS_TYPE_CTIME = 3,
        DB_SCHEMAS_TYPE_ICON = 4,
        DB_SCHEMAS_TYPE_NAME = 5

    }DbSchemaType;
    typedef enum _DbSchemaFieldType {
        DB_SCHEMAS_FIELD_TYPE_ID = 1,
        DB_SCHEMAS_FIELD_TYPE_ORDER = 2,
        DB_SCHEMAS_FIELD_TYPE_TYPE = 3,
        DB_SCHEMAS_FIELD_TYPE_NAME = 4

    }DbSchemaFieldType;
%}
class StuffKeeper:Data:Schema from G:Object 
{
    /* Image matching */
    private GdkPixbuf *pb = {NULL} destroywith g_object_unref;
    private StuffKeeperDataBackend *skdb = {NULL};


    private GList *items = {NULL} destroywith g_list_free;

    private sqlite3 *sqlHandle = {NULL};
    private gint id = {0};
    /**
     * Signals 
     */
    signal last NONE (NONE)
        void
        schema_changed(self)
        {

        }
    signal last NONE (STRING)
        void
        schema_field_changed(self,const gchar *field)
        {
        }
   signal last NONE (STRING)
        void
        schema_field_added(self,const gchar *field)
        {
        }
   signal last NONE (STRING,STRING)
        void
        schema_field_swapped(self,const gchar *field, const gchar *field2)
        {
        }

   signal last NONE (STRING)
        void
        schema_field_removed(self,const gchar *field)
        {
        }


    /**
     * Update mtime
     */


    private 
    void
    update_mtime(self)
    {
        char *query,*error;
        int result;
        /* modification time */
        query = sqlite3_mprintf
            ("UPDATE Schemas SET value='%i' WHERE SchemaId=%i and Type=%i",
             (int)time(NULL),self->_priv->id,DB_SCHEMAS_TYPE_MTIME);

        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            printf("failed to update mtime: %s\n", error);
        }
        sqlite3_free(query);
   }

    /**
     * Constructors
     */

   public
       StuffKeeperDataSchema *
        open_from_id (GObject *skdb, sqlite3 *sqlHandle, gint id) 
        {
            Self *obj = GET_NEW;
            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->id = id;
            obj->_priv->sqlHandle = sqlHandle;
            return obj;
        }

    public
        StuffKeeperDataSchema*
        new(GObject *skdb,sqlite3 *sqlHandle)
        {
            Self *obj = GET_NEW;
            int result = 0;
            char *error = NULL;
            char *query  = NULL;


            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->sqlHandle = sqlHandle;
            /**
             * Insert the first item in the list
             */
            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('type','value')"
                 "values (%i,'%i');",
                 DB_SCHEMAS_TYPE_ID, -1);

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* Get the id of the insert, this is now the unique id for this field*/
            obj->_priv->id = sqlite3_last_insert_rowid(obj->_priv->sqlHandle);

            /* update the last inserted row */
            query = sqlite3_mprintf
                ("UPDATE Schemas SET SchemaId='%i' WHERE id=%i and type=%i",
                 obj->_priv->id,obj->_priv->id, DB_SCHEMAS_TYPE_ID);
            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* creation time */
            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                 "values (%i,%i,'%i');",
                 obj->_priv->id,DB_SCHEMAS_TYPE_CTIME, (int)time(NULL));

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* update mtime */
            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
             "values (%i,%i,'%i');",
             obj->_priv->id,DB_SCHEMAS_TYPE_MTIME, (int)time(NULL));

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed to update mtime: %s\n", error);
            }
            sqlite3_free(query);

            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                 "values (%i,%i,%Q);",
                 obj->_priv->id,DB_SCHEMAS_TYPE_NAME, "New Schema");

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            return obj;
        }
   public
        StuffKeeperDataSchema*
        new_with_id(GObject *skdb,sqlite3 *sqlHandle,gint id)
        {
            Self *obj = GET_NEW;
            int result = 0;
            char *error = NULL;
            char *query  = NULL;


            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->id = id;
            obj->_priv->sqlHandle = sqlHandle;

            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                 "values (%i,%i,'%i');",
                 obj->_priv->id,DB_SCHEMAS_TYPE_ID, -1);

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);
            /* creation time */
            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                 "values (%i,%i,'%i');",
                 obj->_priv->id,DB_SCHEMAS_TYPE_CTIME, (int)time(NULL));

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* modification time */

            /* update mtime */
            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
             "values (%i,%i,'%i');",
             obj->_priv->id,DB_SCHEMAS_TYPE_MTIME, (int)time(NULL));

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed to update mtime: %s\n", error);
            }
            sqlite3_free(query);

            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                 "values (%i,%i,%Q);",
                 obj->_priv->id,DB_SCHEMAS_TYPE_NAME, "New Schema");

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            return obj;
        }

    /**
     * Functions to manage 
     */
    public
        void
        save_yourself(self)
        {
            printf("Deprecated\n");
        }

    public
        void
        delete_yourself(self)
        {
            int result;
            char *error;
            char *query =  sqlite3_mprintf("DELETE FROM Schemas WHERE SchemaId=%i",self->_priv->id);
            result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);
            query =  sqlite3_mprintf("DELETE FROM SchemasFields WHERE SchemaId=%i",self->_priv->id);
            result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);                                                                  
            }
            sqlite3_free(query);

            self->_priv->id = 0;
        }

    /**
     * ID (ro)
     */
    public
        gint
        get_id(self)
        {
            return self->_priv->id;
        }

    /**
     * Title (rw)
     */
    private 
    gchar *
    schemas_get_field(self, int fieldtype)
    {
        char *retv = NULL;
        char *query = sqlite3_mprintf("SELECT value FROM Schemas WHERE SchemaId=%i and type=%i", self->_priv->id,fieldtype);
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                retv = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
            }
        }
        sqlite3_finalize(stmt);

        sqlite3_free(query);
        return retv; 

    }
    /**
     * Setting getting helper functions 
     */    
    private 
    gchar *
    field_schemas_get_field_string(self, int fieldtype, const char *field)
    {
        char *retv = NULL;
        char *query = sqlite3_mprintf("SELECT value FROM SchemasFields WHERE SchemaId=%i and type=%i and FieldId=%q", 
                    self->_priv->id,
                    fieldtype,
                    field);

        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                retv = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
            }
        }
        sqlite3_finalize(stmt);

        sqlite3_free(query);
        return retv; 

    }
    private 
    gboolean
    field_schemas_get_field_integer(self, int fieldtype, const char *field, int *out)
    {
        int set = FALSE;
        char *query = sqlite3_mprintf("SELECT value FROM SchemasFields WHERE SchemaId=%i and type=%i and FieldId=%q", 
                self->_priv->id,
                fieldtype,
                field);
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                *out =sqlite3_column_int(stmt, 0);
                set = TRUE;
            }
        }
        sqlite3_finalize(stmt);

        sqlite3_free(query);
        return set; 

    }
    public 
    void
    field_schemas_set_field_integer(self,int fieldtype,const gchar *id, const int title)
    {
        int result;
        char *error;
        char *query;
        int val ;
        int set;
        set = self_field_schemas_get_field_integer(self, fieldtype,id,&val);
        /* no field, create it */
        if(!set)
        {
            query = sqlite3_mprintf("INSERT INTO 'SchemasFields' ('SchemaId','FieldId','type','value')"
                                   "values (%i,%q,%i,%i);",
                                    self->_priv->id,
                                    id,
                                    fieldtype,
                                    title);
        }
        else{
            /* if they are identical, do nothing */
            if(title == val)
            {
                printf("not updating\n");
                return;
            }
            /* update the title */
            query = sqlite3_mprintf("UPDATE SchemasFields SET value=%i WHERE SchemaId=%i and type=%i and FieldId=%q", title, self->_priv->id,fieldtype,id);

        }
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        /* update mtime */
        self_update_mtime(self);
        /* signal that we changed */
    //    self_schema_field_changed(self,id);
    }

    public 
    void
    field_schemas_set_field_string(self,int fieldtype,const gchar *id, const gchar *title)
    {
        int result;
        char *error;
        char *query;
        char *val;
        val = self_field_schemas_get_field_string(self, fieldtype,id);
        /* no field, create it */
        if(!val)
        {
            query = sqlite3_mprintf("INSERT INTO 'SchemasFields' ('SchemaId','FieldId','type','value')"
                                   "values (%i,%q,%i,%Q);",
                                    self->_priv->id,
                                    id,
                                    fieldtype,
                                    title);
        }
        else{
            /* if they are identical, do nothing */
            if(strcmp(title, val) == 0)
            {
                g_free(val);
                printf("not updating\n");
                return;
            }
            /* update the title */
            query = sqlite3_mprintf("UPDATE SchemasFields SET value=%Q WHERE SchemaId=%i and type=%i and FieldId=%q", 
                    title, 
                    self->_priv->id,
                    fieldtype,
                    id);
            g_free(val);
        }
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        /* update mtime */
        self_update_mtime(self);
        /* signal that we changed */
//        self_schema_field_changed(self,id);
    }





    public 
    void
    schemas_set_field(self,int fieldtype, const gchar *title)
    {
        int result;
        char *error;
        char *query;
        char *val;
        val = self_schemas_get_field(self, fieldtype);
        /* no field, create it */
        if(!val)
        {
            query = sqlite3_mprintf("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                                   "values (%i,%i,%Q);",
                                    self->_priv->id,
                                    fieldtype,
                                    title);
        }
        else{
            /* if they are identical, do nothing */
            if(strcmp(title, val) == 0)
            {
                g_free(val);
                printf("not updating\n");
                return;
            }
            /* update the title */
            query = sqlite3_mprintf("UPDATE Schemas SET value=%Q WHERE SchemaId=%i and type=%i", title, self->_priv->id,fieldtype);
            g_free(val);
        }
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        /* update mtime */
        self_update_mtime(self);
        /* signal that we changed */
//        self_schema_changed(self);
    }

    /**
     * Title (rw)
     */
    public
    void
    set_title(self, const gchar *title)
    {
        self_schemas_set_field(self, DB_SCHEMAS_TYPE_NAME, title);
        self_schema_changed(self);
    }

    public 
    gchar *
    get_title(self)
    {
        char *retv = self_schemas_get_field(self, DB_SCHEMAS_TYPE_NAME);
        if(!retv)
            retv = g_strdup("Failed to get title\n");
        return retv;
    }

    /**
     * Fields
     */

    public
    gchar **
    get_fields(self, gsize *size)
    {
        int fields =-1;
        char *query;
        gchar **retv = NULL;
        int i=0;
        /* count the number of fields */
        query = sqlite3_mprintf("SELECT COUNT(DISTINCT FieldId) FROM SchemasFields WHERE SchemaId=%i",self->_priv->id);
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                fields = sqlite3_column_int(stmt, 0);
            }
        }
        else
        {
            printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
        }
        sqlite3_finalize(stmt);
        sqlite3_free(query);
        printf("%i fields found\n",fields);
        /* if no rows, return */
        if(fields <= 0)
        {
            *size = 0;
            return NULL;
        }
        /* get the rows, ordered */
        retv = g_malloc0((fields+1)*sizeof(gchar *));
        query = sqlite3_mprintf("SELECT FieldId FROM SchemasFields WHERE SchemaId=%i and type=%i ORDER BY value ASC",
                    self->_priv->id,
                    DB_SCHEMAS_FIELD_TYPE_ORDER);

        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        sqlite3_free(query);
        if (r != SQLITE_OK)
        {
            printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
        }
        else
        {
            printf("stepping through rows\n");
            while((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                retv[i] = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
                printf("adding id: %s\n", retv[i]);
                i++;
            }
        }
        sqlite3_finalize(stmt);

        *size = fields;
        return retv;
    }

    public 
    int 
    get_field_pos(self, const gchar *id)
    {
        int val=0;
        self_field_schemas_get_field_integer(self, DB_SCHEMAS_FIELD_TYPE_ORDER, id,&val);
        return val; 
    }

    public 
        void 
    swap_field_pos(self, const gchar *id, const gchar *id2)
    {
        int pos = self_get_field_pos(self, id);
        int pos2 = self_get_field_pos(self, id2);

        self_field_schemas_set_field_integer(self, DB_SCHEMAS_FIELD_TYPE_ORDER, id,pos2);
        self_field_schemas_set_field_integer(self, DB_SCHEMAS_FIELD_TYPE_ORDER, id2,pos);

        self_schema_field_changed(self, id);
        self_schema_field_changed(self, id2);

        self_schema_field_swapped(self, id, id2);
    }

    public 
    FieldType 
    get_field_type(self, const gchar *id)
    {
        int val=0;
        self_field_schemas_get_field_integer(self, DB_SCHEMAS_FIELD_TYPE_TYPE, id,&val);
        return val; 
    }

    /* Be carefull with this */
    public 
    void 
    set_field_type(self, const gchar *id, FieldType type)
    {
        self_field_schemas_set_field_integer(self, DB_SCHEMAS_FIELD_TYPE_TYPE, id,type);
/*        g_key_file_set_integer(self->_priv->data, KEYFILE_FIELD_TYPES,id,type);
 */        
        self_schema_field_changed(self,id);
  
    }

    public
    gchar *
    get_field_name(self, const gchar *id)
    {
        printf("getting name: %s\n", id);

        char *retv = self_field_schemas_get_field_string(self, DB_SCHEMAS_FIELD_TYPE_NAME, id);
        if(!retv)
            retv = g_strdup("N/A");
        return retv; 
    }

    public
    void
    set_field_name(self, const gchar *id, const gchar *name)
    {
        printf("seting name: %s:%s\n", id,name);
        self_field_schemas_set_field_string(self, DB_SCHEMAS_FIELD_TYPE_NAME, id,name);
/*        
        g_key_file_set_string(self->_priv->data, KEYFILE_FIELD_NAMES,id, name);
        */
        self_schema_field_changed(self,id);

    }
    /* Field editing */
    public
    void
    add_field(self, FieldType field, const gchar *name)
    {
        gchar **retv = NULL; 
        gsize size=0;
        int pos = 0;
        int result = 0;
        char *error = NULL;
        char *query  = NULL;
        gint id;
        gchar *cid = NULL;
        /* find new position */
        retv = self_get_fields(self,&size);
        if(retv && size > 0)
        {
            /* get the position of the last item and put it after that */
            pos = self_get_field_pos(self,retv[size-1])+1;
        }
        g_strfreev(retv);


        /* insert it */
        query = sqlite3_mprintf("INSERT INTO 'SchemasFields' ('SchemaId','type','value')"
                 "values (%i,%i,'%i');",
                 self->_priv->id,
                 DB_SCHEMAS_FIELD_TYPE_ID,
                 -1);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        sqlite3_free(query);
        if(result != SQLITE_OK) {
            printf("failed: %s\n", error);
            return;
        }
        id = sqlite3_last_insert_rowid(self->_priv->sqlHandle);
        query = sqlite3_mprintf("UPDATE SchemasFields SET FieldId='%i' WHERE id=%i",
                        id,
                        id);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        sqlite3_free(query);
        if (result != SQLITE_OK) {
            printf("failed: %s\n", error);
        }
        
       /* Add the field */
        cid = g_strdup_printf("%i", id);

        self_field_schemas_set_field_integer(self, DB_SCHEMAS_FIELD_TYPE_TYPE, cid,FIELD_TYPE_STRING);
        self_field_schemas_set_field_integer(self, DB_SCHEMAS_FIELD_TYPE_ORDER, cid,pos);
        self_field_schemas_set_field_string(self, DB_SCHEMAS_FIELD_TYPE_NAME, cid,name);

        self_schema_field_added(self, cid);
        g_free(cid);
    }
    public
    void
    remove_field(self, const gchar *id)
    {
        int result;
        char *error;
        char *query = sqlite3_mprintf("DELETE FROM SchemasFields WHERE FieldId=%q and SchemaId=%i",
                id,
                self->_priv->id);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        sqlite3_free(query);
        if (result != SQLITE_OK) {
            printf("failed: %s\n", error);
        }
/*
        g_key_file_remove_key(self->_priv->data, KEYFILE_FIELD_TYPES, id, NULL);
        g_key_file_remove_key(self->_priv->data, KEYFILE_FIELD_NAMES, id, NULL);
        g_key_file_remove_key(self->_priv->data, KEYFILE_FIELD_SORT, id, NULL);
*/
        /* Mark it for saving */
        self_schema_field_removed(self, id);
    }

    /* Item handling */
    public
        int
        num_items(self)
        {
            return g_list_length(self->_priv->items);
        }
    public
        void
        add_item(self, GObject *item)
        {
            self->_priv->items = g_list_append(self->_priv->items, STUFFKEEPER_DATA_ITEM(item));
            self_schema_changed(self);
        }
    public 
        void
        remove_item(self, GObject *item)
        {
            self->_priv->items = g_list_remove(self->_priv->items, STUFFKEEPER_DATA_ITEM(item));
            self_schema_changed(self);
        }

        override (G:Object)
        void
        finalize(G:Object *obj)
        {
            debug_printf("destroying schema\n");
        }
        
        /* Icon handling */
        public
        void 
        set_icon(self, const gchar *filename)
        {
            gchar *value = g_strdup_printf("%i",self_get_id(self)); 
            gchar *dest_path = g_build_path(G_DIR_SEPARATOR_S,stuffkeeper_data_backend_get_path(self->_priv->skdb),"images",value,NULL);

            /* clear */
            g_object_unref(self->_priv->pb);
            self->_priv->pb = NULL;

            if(filename)
            {
                self->_priv->pb = gdk_pixbuf_new_from_file_at_scale(filename, ICON_SIZE,ICON_SIZE, TRUE, NULL);
                gdk_pixbuf_save(self->_priv->pb, dest_path, "png", NULL,NULL);
            
                self_schemas_set_field(self, DB_SCHEMAS_TYPE_ICON, value);
            }
            else 
            {
                self_schemas_set_field(self, DB_SCHEMAS_TYPE_ICON, "");
            }
            
            self_schema_changed(self);

            g_free(value);
            g_free(dest_path);
        }

        public
        GdkPixbuf *
        get_pixbuf(self)
        {
            if(self->_priv->pb == NULL) {
                GError *error = NULL;
                gchar *filename = self_schemas_get_field(self, DB_SCHEMAS_TYPE_ICON);
                if(filename && strlen(filename)>0)
                {
                    gchar *path = g_build_path(G_DIR_SEPARATOR_S,stuffkeeper_data_backend_get_path(self->_priv->skdb),"images",filename,NULL);
                    self->_priv->pb = gdk_pixbuf_new_from_file_at_scale(path, 16,16,TRUE,&error);
                    g_free(path);

                }
                else
                    self->_priv->pb = gtk_icon_theme_load_icon(gtk_icon_theme_get_default(), "gtk-new", 16, 0, &error);
                if(filename)
                    g_free(filename);
                if(error)
                {
                    debug_printf("error: %s\n", error->message);

                    g_error_free(error);
                }
            }

            return self->_priv->pb;
        }
}
