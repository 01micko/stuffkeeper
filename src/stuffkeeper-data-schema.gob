requires 2.0.10

%h{
#include <gdk-pixbuf/gdk-pixbuf.h>
#include <gtk/gtk.h>
#include "stuffkeeperglue.h"
%}

%ph{
#include <stdio.h>
#include <sqlite3.h>
#include "debug.h"
#include <glib/gstdio.h>

#include <libxml/tree.h>
#include <libxml/parser.h>
#include "stuffkeeper-data-backend.h"


#include "stuffkeeper-data-item.h"
#define ICON_SIZE 16
%}
%h{
    typedef enum _FieldType{
        FIELD_TYPE_STRING = 0,
        FIELD_TYPE_INTEGER = 1,
        FIELD_TYPE_BOOLEAN = 2,
        FIELD_TYPE_RATING = 3,
        FIELD_TYPE_LIST = 4,
        FIELD_TYPE_TEXT = 5,
        FIELD_TYPE_IMAGE = 6,
        FIELD_TYPE_LINK = 7,
        FIELD_TYPE_DATE = 8,
        FIELD_TYPE_EXPANDER = 9,
        FIELD_TYPE_END_EXPANDER = 10,
        FIELD_TYPE_VPACKING = 11,
        FIELD_TYPE_END= 12,
        FIELD_TYPE_HPACKING = 13,
        FIELD_TYPE_NUM_FIELDS
    } FieldType;
    extern char *FieldNames[FIELD_TYPE_NUM_FIELDS];
%}
%ph{
        char *FieldNames[FIELD_TYPE_NUM_FIELDS] = {
            // FIELD_TYPE_STRING
            N_("String"),   
            // FIELD_TYPE_INTEGER
            N_("Integer"),
            // FIELD_TYPE_BOOLEAN
            N_("Boolean"),
            // FIELD_TYPE_RATING
            N_("Slider"), 
            // FIELD_TYPE_LIST
            N_("List"),  
            // FIELD_TYPE_TEXT
            N_("Text"),
            // FIELD_TYPE_IMAGE
            N_("Image"), 
            // FIELD_TYPE_LINK
            N_("Link"),
            // FIELD_TYPE_DATE
            N_("Date"),  
            //FIELD_TYPE_EXPANDER
            N_("Expander"),
            //FIELD_TYPE_END_EXPANDER
            N_("End"),
            // FIELD_TYPE_VPACKING
            N_("vertical packing"), 
            // FIELD_TYPE_END_PACKING
            N_("End"),              
            // FIELD_TYPE_VPACKING
            N_("horizontal packing") 
    };

    typedef struct _a { char *id; int pos; }a;
%}
%h{
    typedef enum _DbSchemaType {
        DB_SCHEMAS_TYPE_ID = 1,
        DB_SCHEMAS_TYPE_MTIME = 2,
        DB_SCHEMAS_TYPE_CTIME = 3,
        DB_SCHEMAS_TYPE_ICON = 4,
        DB_SCHEMAS_TYPE_NAME = 5

    }DbSchemaType;
    typedef enum _DbSchemaFieldType {
        DB_SCHEMAS_FIELD_TYPE_ID = 1,
        DB_SCHEMAS_FIELD_TYPE_ORDER = 2,
        DB_SCHEMAS_FIELD_TYPE_TYPE = 3,
        DB_SCHEMAS_FIELD_TYPE_NAME = 4,
        DB_SCHEMAS_FIELD_TYPE_IN_TITLE = 5,
	DB_SCHEMAS_FIELD_TYPE_DEFAULT_VALUE = 6,
	/* MASK to add to custom field, this leaves sufficient custom fields */
	DB_SCHEMAS_FIELD_CUSTOM = (1<<30)
		}DbSchemaFieldType;
%}
class Stuffkeeper:Data:Schema from G:Object 
{
    /* Image matching */
    private GdkPixbuf *pb = {NULL} destroywith g_object_unref;
    private StuffkeeperDataBackend *skdb = {NULL};


    private GList *items = {NULL} destroywith g_list_free;

    private sqlite3 *sqlHandle = {NULL};
    private gint id = {0};
    private gint generated_title = {-1};
    /**
     * Signals 
     */
    private
    signal last NONE (NONE)
        void
        schema_changed(self)
        {

        }
    private
    signal last NONE (STRING)
        void
        schema_field_changed(self,const gchar *field)
        {
        }
    private
    signal last NONE (STRING)
        void
        schema_field_added(self,const gchar *field)
        {
        }

    private 
    signal last NONE (STRING, INT)
    void
    schema_custom_field_changed(self, const gchar *id, int field)
    {
    }

    private
    signal last NONE (NONE)
    void
    schema_fields_reordered(self)
    {

    }

    private
   signal last NONE (STRING)
        void
        schema_field_removed(self,const gchar *field)
        {
        }


    /**
     * Update mtime
     */


    private 
    void
    update_mtime(self)
    {
        char *query,*error;
        int result;
        /* modification time */
        query = sqlite3_mprintf
            ("UPDATE Schemas SET value='%i' WHERE SchemaId=%i and Type=%i",
             (int)time(NULL),self->_priv->id,DB_SCHEMAS_TYPE_MTIME);

        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            printf("failed to update mtime: %s\n", error);
        }
        sqlite3_free(query);
   }

    /**
     * Constructors
     */

   public
       StuffkeeperDataSchema *
        open_from_id (StuffkeeperDataBackend *skdb, gint id) 
        {
            Self *obj = GET_NEW;
            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->id = id;
            obj->_priv->sqlHandle = stuffkeeper_data_backend_get_handle(obj->_priv->skdb);;
            return obj;
        }

    public
        StuffkeeperDataSchema*
        new(StuffkeeperDataBackend *skdb)
        {
            Self *obj = GET_NEW;
            int result = 0;
            char *error = NULL;
            char *query  = NULL;


            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->sqlHandle = stuffkeeper_data_backend_get_handle(obj->_priv->skdb);;
            /**
             * Insert the first item in the list
             */
            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('type','value')"
                 "values (%i,'%i');",
                 DB_SCHEMAS_TYPE_ID, -1);

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* Get the id of the insert, this is now the unique id for this field*/
            obj->_priv->id = sqlite3_last_insert_rowid(obj->_priv->sqlHandle);

            /* update the last inserted row */
            query = sqlite3_mprintf
                ("UPDATE Schemas SET SchemaId='%i' WHERE id=%i and type=%i",
                 obj->_priv->id,obj->_priv->id, DB_SCHEMAS_TYPE_ID);
            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* creation time */
            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                 "values (%i,%i,'%i');",
                 obj->_priv->id,DB_SCHEMAS_TYPE_CTIME, (int)time(NULL));

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* update mtime */
            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
             "values (%i,%i,'%i');",
             obj->_priv->id,DB_SCHEMAS_TYPE_MTIME, (int)time(NULL));

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed to update mtime: %s\n", error);
            }
            sqlite3_free(query);

            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                 "values (%i,%i,%Q);",
                 obj->_priv->id,DB_SCHEMAS_TYPE_NAME, "New Schema");

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            return obj;
        }
   public
        StuffkeeperDataSchema*
        new_with_id(StuffkeeperDataBackend *skdb,gint id)
        {
            Self *obj = GET_NEW;
            int result = 0;
            char *error = NULL;
            char *query  = NULL;


            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->id = id;
            obj->_priv->sqlHandle = stuffkeeper_data_backend_get_handle(obj->_priv->skdb);;

            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                 "values (%i,%i,'%i');",
                 obj->_priv->id,DB_SCHEMAS_TYPE_ID, -1);

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);
            /* creation time */
            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                 "values (%i,%i,'%i');",
                 obj->_priv->id,DB_SCHEMAS_TYPE_CTIME, (int)time(NULL));

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* modification time */

            /* update mtime */
            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
             "values (%i,%i,'%i');",
             obj->_priv->id,DB_SCHEMAS_TYPE_MTIME, (int)time(NULL));

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed to update mtime: %s\n", error);
            }
            sqlite3_free(query);

            query = sqlite3_mprintf
                ("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                 "values (%i,%i,%Q);",
                 obj->_priv->id,DB_SCHEMAS_TYPE_NAME, "New Schema");

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            return obj;
        }

    /**
     * Functions to manage 
     */
    public
        void
        save_yourself(self)
        {
            printf("Deprecated\n");
        }

    public
        void
        delete_yourself(self)
        {
            int result;
            char *error;
            char *query =  sqlite3_mprintf("DELETE FROM Schemas WHERE SchemaId=%i",self->_priv->id);
            result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);
            }
            sqlite3_free(query);
            query =  sqlite3_mprintf("DELETE FROM SchemasFields WHERE SchemaId=%i",self->_priv->id);
            result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                printf("failed: %s\n", error);                                                                  
            }
            sqlite3_free(query);

            self->_priv->id = 0;
        }

    /**
     * ID (ro)
     */
    public
        gint
        get_id(self)
        {
            return self->_priv->id;
        }

    /**
     * Title (rw)
     */
    private 
    gchar *
    schemas_get_field(self, int fieldtype)
    {
        char *retv = NULL;
        char *query = sqlite3_mprintf("SELECT value FROM Schemas WHERE SchemaId=%i and type=%i", self->_priv->id,fieldtype);
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                retv = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
            }
        }
        sqlite3_finalize(stmt);

        sqlite3_free(query);
        return retv; 

    }
    /**
     * Setting getting helper functions 
     */    
    private 
    gchar *
    field_schemas_get_field_string(self, int fieldtype, const char *field)
    {
        char *retv = NULL;
        char *query = sqlite3_mprintf("SELECT value FROM SchemasFields WHERE SchemaId=%i and type=%i and FieldId=%q", 
                    self->_priv->id,
                    fieldtype,
                    field);

        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                retv = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
            }
        }
        sqlite3_finalize(stmt);

        sqlite3_free(query);
        return retv; 

    }
    private 
    gboolean
    field_schemas_get_field_integer(self, int fieldtype, const char *field, int *out)
    {
        int set = FALSE;
        char *query = sqlite3_mprintf("SELECT value FROM SchemasFields WHERE SchemaId=%i and type=%i and FieldId=%q", 
                self->_priv->id,
                fieldtype,
                field);
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                *out =sqlite3_column_int(stmt, 0);
                set = TRUE;
            }
        }
        sqlite3_finalize(stmt);

        sqlite3_free(query);
        return set; 

    }
    private 
    int 
    field_schemas_set_field_integer(self,int fieldtype,const gchar *id, const int title)
    {
        int result;
        char *error;
        char *query;
        int val ;
        int set;
        set = self_field_schemas_get_field_integer(self, fieldtype,id,&val);
        /* no field, create it */
        if(!set)
        {
            query = sqlite3_mprintf("INSERT INTO 'SchemasFields' ('SchemaId','FieldId','type','value')"
                                   "values (%i,%q,%i,%i);",
                                    self->_priv->id,
                                    id,
                                    fieldtype,
                                    title);
        }
        else{
            /* if they are identical, do nothing */
            if(title == val)
            {
                return FALSE;
            }
            /* update the title */
            query = sqlite3_mprintf("UPDATE SchemasFields SET value=%i WHERE SchemaId=%i and type=%i and FieldId=%q", title, self->_priv->id,fieldtype,id);

        }
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        /* update mtime */
        self_update_mtime(self);
        /* signal that we changed */
    //    self_schema_field_changed(self,id);
        return TRUE;
    }

    public 
    void
    field_schemas_set_field_string(self,int fieldtype,const gchar *id, const gchar *title)
    {
        int result;
        char *error;
        char *query;
        char *val;
        val = self_field_schemas_get_field_string(self, fieldtype,id);
        /* no field, create it */
        if(!val)
        {
            query = sqlite3_mprintf("INSERT INTO 'SchemasFields' ('SchemaId','FieldId','type','value')"
                                   "values (%i,%q,%i,%Q);",
                                    self->_priv->id,
                                    id,
                                    fieldtype,
                                    title);
        }
        else{
            /* if they are identical, do nothing */
            if(strcmp(title, val) == 0)
            {
                g_free(val);
                return;
            }
            /* update the title */
            query = sqlite3_mprintf("UPDATE SchemasFields SET value=%Q WHERE SchemaId=%i and type=%i and FieldId=%q", 
                    title, 
                    self->_priv->id,
                    fieldtype,
                    id);
            g_free(val);
        }
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        /* update mtime */
        self_update_mtime(self);
        /* signal that we changed */
//        self_schema_field_changed(self,id);
    }





    public 
    void
    schemas_set_field(self,int fieldtype, const gchar *title)
    {
        int result;
        char *error;
        char *query;
        char *val;
        val = self_schemas_get_field(self, fieldtype);
        /* no field, create it */
        if(!val)
        {
            query = sqlite3_mprintf("INSERT INTO 'Schemas' ('SchemaId','type','value')"
                                   "values (%i,%i,%Q);",
                                    self->_priv->id,
                                    fieldtype,
                                    title);
        }
        else{
            /* if they are identical, do nothing */
            if(strcmp(title, val) == 0)
            {
                g_free(val);
                return;
            }
            /* update the title */
            query = sqlite3_mprintf("UPDATE Schemas SET value=%Q WHERE SchemaId=%i and type=%i", title, self->_priv->id,fieldtype);
            g_free(val);
        }
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        /* update mtime */
        self_update_mtime(self);
        /* signal that we changed */
//        self_schema_changed(self);
    }

    /**
     * Title (rw)
     */
    public
    void
    set_title(self, const gchar *title)
    {
        self_schemas_set_field(self, DB_SCHEMAS_TYPE_NAME, title);
        self_schema_changed(self);
    }

    public 
    gchar *
    get_title(self)
    {
        char *retv = self_schemas_get_field(self, DB_SCHEMAS_TYPE_NAME);
        if(!retv)
            retv = g_strdup("Failed to get title\n");
        return retv;
    }
	
    /**
     * Fields
     */

    public
    gchar **
    get_fields(self, gsize *size)
    {
        int fields =-1;
        char *query;
        gchar **retv = NULL;
        int i=0;
        /* count the number of fields */
        query = sqlite3_mprintf("SELECT COUNT(DISTINCT FieldId) FROM SchemasFields WHERE SchemaId=%i",self->_priv->id);
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                fields = sqlite3_column_int(stmt, 0);
            }
        }
        else
        {
            printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
        }
        sqlite3_finalize(stmt);
        sqlite3_free(query);
        /* if no rows, return */
        if(fields <= 0)
        {
            *size = 0;
            return NULL;
        }
        /* get the rows, ordered */
        retv = g_malloc0((fields+1)*sizeof(gchar *));
        query = sqlite3_mprintf("SELECT FieldId FROM SchemasFields WHERE SchemaId=%i and type=%i ORDER BY CAST (value AS INTEGER) ASC",
                    self->_priv->id,
                    DB_SCHEMAS_FIELD_TYPE_ORDER);

        r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        sqlite3_free(query);
        if (r != SQLITE_OK)
        {
            printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
        }
        else
        {
            while((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                retv[i] = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
                i++;
            }
        }
        sqlite3_finalize(stmt);

        *size = fields;
        return retv;
    }

    public 
    int 
    get_field_pos(self, const gchar *id)
    {
        int val=0;
        self_field_schemas_get_field_integer(self, DB_SCHEMAS_FIELD_TYPE_ORDER, id,&val);
        return val; 
    }

    public 
    FieldType 
    get_field_type(self, const gchar *id)
    {
        int val=0;
        self_field_schemas_get_field_integer(self, DB_SCHEMAS_FIELD_TYPE_TYPE, id,&val);
        return val; 
    }

    /* Be carefull with this */
    public 
    void 
    set_field_type(self, const gchar *id, FieldType type)
    {
        self_field_schemas_set_field_integer(self, DB_SCHEMAS_FIELD_TYPE_TYPE, id,type);
        self_schema_field_changed(self,id);
  
    }

    public
    gchar *
    get_field_name(self, const gchar *id)
    {
        char *retv = self_field_schemas_get_field_string(self, DB_SCHEMAS_FIELD_TYPE_NAME, id);
        if(!retv)
            retv = g_strdup("N/A");
        return retv; 
    }

    public
    void
    set_field_name(self, const gchar *id, const gchar *name)
    {
        printf("seting name: %s:%s\n", id,name);
        self_field_schemas_set_field_string(self, DB_SCHEMAS_FIELD_TYPE_NAME, id,name);
        self_schema_field_changed(self,id);

    }

    public
    int
    has_generated_title(self)
    {
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        int fields =0;
        char *query;
        /*buffer */
        if(self->_priv->generated_title >= 0)
            return self->_priv->generated_title;

        /* count the number of fields */
        query = sqlite3_mprintf("SELECT COUNT(DISTINCT FieldId) FROM SchemasFields WHERE SchemaId=%i and type=%i and value=1",
                self->_priv->id,
                DB_SCHEMAS_FIELD_TYPE_IN_TITLE);



        r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                fields = sqlite3_column_int(stmt, 0);
            }
        }
        else
        {
            printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
        }
        sqlite3_finalize(stmt);
        sqlite3_free(query);

        self->_priv->generated_title = fields;
        return fields;
    }

    public
    void
    set_field_in_title(self,  const gchar *id, const int in_title)
    {
        int changed = self_field_schemas_set_field_integer(self, DB_SCHEMAS_FIELD_TYPE_IN_TITLE, id,in_title);
        if(changed)
        {
            self->_priv->generated_title = -1;

            stuffkeeper_data_backend_begin_transaction(self->_priv->skdb);
            self_schema_field_changed(self,id);
            stuffkeeper_data_backend_end_transaction(self->_priv->skdb);
        }
    }
    public 
    int 
    get_field_in_title(self, const gchar *id)
    {
        int val=0;
        self_field_schemas_get_field_integer(self, DB_SCHEMAS_FIELD_TYPE_IN_TITLE, id,&val);
        return val; 
    }
    /* Field editing */
    public
    void
    add_field(self, FieldType field, const gchar *name, int in_title)
    {
/*        gchar **retv = NULL; 
        gsize size=0;
*/        int pos = 0;
        int result = 0;
        char *error = NULL;
        char *query  = NULL;
        gint id;
        gchar *cid = NULL;
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        /* find new position */
/*        retv = self_get_fields(self,&size);

        if(retv && size > 0)
        {
*/            /* get the position of the last item and put it after that */
/*            pos = self_get_field_pos(self,retv[size-1])+1;
        }
        g_strfreev(retv);
        int fields =-1;
        char *query;
        gchar **retv = NULL;
        int i=0;
        */
        /* count the number of fields */
        query = sqlite3_mprintf("SELECT MAX(CAST (value AS INTEGER))+1 FROM SchemasFields WHERE SchemaId=%i and type=%i",
                    self->_priv->id,
                    DB_SCHEMAS_FIELD_TYPE_ORDER );

        r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                pos = sqlite3_column_int(stmt, 0);
            }
        }
        else
        {
            printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
        }
        sqlite3_finalize(stmt);
        sqlite3_free(query);

        /* insert it */
        query = sqlite3_mprintf("INSERT INTO 'SchemasFields' ('SchemaId','type','value')"
                 "values (%i,%i,'%i');",
                 self->_priv->id,
                 DB_SCHEMAS_FIELD_TYPE_ID,
                 -1);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        sqlite3_free(query);
        if(result != SQLITE_OK) {
            printf("failed: %s\n", error);
            return;
        }
        id = sqlite3_last_insert_rowid(self->_priv->sqlHandle);
        query = sqlite3_mprintf("UPDATE SchemasFields SET FieldId='%i' WHERE id=%i",
                        id,
                        id);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        sqlite3_free(query);
        if (result != SQLITE_OK) {
            printf("failed: %s\n", error);
        }
        
       /* Add the field */
        cid = g_strdup_printf("%i", id);

        self_field_schemas_set_field_integer(self, DB_SCHEMAS_FIELD_TYPE_TYPE, cid,field);
        self_field_schemas_set_field_integer(self, DB_SCHEMAS_FIELD_TYPE_ORDER, cid,pos);
        self_field_schemas_set_field_string(self, DB_SCHEMAS_FIELD_TYPE_NAME, cid,name);
        self_set_field_in_title(self, cid, in_title);

        self_schema_field_added(self, cid);
        g_free(cid);
    }
    public
    void
    remove_field(self, const gchar *id)
    {
        int result;
        char *error;
        char *query = sqlite3_mprintf("DELETE FROM SchemasFields WHERE FieldId=%q and SchemaId=%i",
                id,
                self->_priv->id);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        sqlite3_free(query);
        if (result != SQLITE_OK) {
            printf("failed: %s\n", error);
        }

        /* Mark it for saving */
        stuffkeeper_data_backend_begin_transaction(self->_priv->skdb);
        self_schema_field_removed(self, id);
        stuffkeeper_data_backend_end_transaction(self->_priv->skdb);
    }

    /*** 
     * CUSTOM FIELDS
     */
    public
	gchar *
	get_custom_field_string(self, const gchar *id,int field (check < DB_SCHEMAS_FIELD_CUSTOM))
	{
		char *retv = self_field_schemas_get_field_string(self, field&DB_SCHEMAS_FIELD_CUSTOM,id);
		return retv;
	}
	public
	void
	set_custom_field_string(self,const gchar *id, int field (check < DB_SCHEMAS_FIELD_CUSTOM), const gchar *value)
	{
		self_field_schemas_set_field_string(self, field&DB_SCHEMAS_FIELD_CUSTOM,id,value);
		self_schema_custom_field_changed(self,id,field);
	}
	public
	gint
	get_custom_field_integer(self, const gchar *id,int field (check < DB_SCHEMAS_FIELD_CUSTOM))
	{
		gint retv = 0;
		self_field_schemas_get_field_integer(self,field&DB_SCHEMAS_FIELD_CUSTOM, id,&retv);
		return retv;
	}
	public
	void
	set_custom_field_integer(self, const gchar *id,int field (check < DB_SCHEMAS_FIELD_CUSTOM), const gint value)
	{
		self_field_schemas_set_field_integer(self,field&DB_SCHEMAS_FIELD_CUSTOM,id,value);
		self_schema_custom_field_changed(self,id,field);
	}


    /* Item handling */
    public
        int
        num_items(self)
        {
            return g_list_length(self->_priv->items);
        }
    public
        void
        add_item(self, StuffkeeperDataItem *item)
        {
            self->_priv->items = g_list_prepend(self->_priv->items, STUFFKEEPER_DATA_ITEM(item));
            self_schema_changed(self);
        }
    public 
        void
        remove_item(self, StuffkeeperDataItem *item)
        {
            self->_priv->items = g_list_remove(self->_priv->items, STUFFKEEPER_DATA_ITEM(item));
            self_schema_changed(self);
        }

        override (G:Object)
        void
        finalize(G:Object *obj)
        {
            debug_printf("destroying schema\n");
            PARENT_HANDLER(obj);
        }
        
        /* Icon handling */
        public
        void 
        set_icon(self, const gchar *filename)
        {
            gchar *value = g_strdup_printf("%i",self_get_id(self)); 
            gchar *dest_path = g_build_path(G_DIR_SEPARATOR_S,stuffkeeper_data_backend_get_path(self->_priv->skdb),"images",value,NULL);

            /* clear */
            g_object_unref(self->_priv->pb);
            self->_priv->pb = NULL;

            if(filename)
            {
                self->_priv->pb = gdk_pixbuf_new_from_file_at_scale(filename, ICON_SIZE,ICON_SIZE, TRUE, NULL);
                gdk_pixbuf_save(self->_priv->pb, dest_path, "png", NULL,NULL);
            
                self_schemas_set_field(self, DB_SCHEMAS_TYPE_ICON, value);
            }
            else 
            {
                self_schemas_set_field(self, DB_SCHEMAS_TYPE_ICON, "");
            }
            
            self_schema_changed(self);
            {
                GList *node = g_list_first(self->_priv->items);
                /*
                 * make the items update, this should make the main 
                 * tree update it's icon.
                 * bit hacky.
                 */
                for(;node;node = g_list_next(node))
                {
                    StuffkeeperDataItem *item = node->data;
                    stuffkeeper_data_item_item_changed(item, NULL);
                }

            }

            g_free(value);
            g_free(dest_path);
        }

        public
        GdkPixbuf *
        get_pixbuf(self)
        {
            if(self->_priv->pb == NULL) {
                GError *error = NULL;
                gchar *filename = self_schemas_get_field(self, DB_SCHEMAS_TYPE_ICON);
                if(filename && strlen(filename)>0)
                {
                    gchar *path = g_build_path(G_DIR_SEPARATOR_S,stuffkeeper_data_backend_get_path(self->_priv->skdb),"images",filename,NULL);
                    self->_priv->pb = gdk_pixbuf_new_from_file_at_scale(path, 16,16,TRUE,&error);
                    g_free(path);

                }
                else
                    self->_priv->pb = gtk_icon_theme_load_icon(gtk_icon_theme_get_default(), "gtk-new", 16, 0, &error);
                if(filename)
                    g_free(filename);
                if(error)
                {
                    debug_printf("error: %s\n", error->message);

                    g_error_free(error);
                }
            }

            return self->_priv->pb;
        }

        public
        GList *
        get_items(self)
        {
            return g_list_copy(self->_priv->items);
        }

        /***
         * Saving and loading 
         */
         public
         StuffkeeperDataSchema *
         load_from_xml(StuffkeeperDataBackend *skdb, const char *path)
         {
             Self *self;
             xmlDocPtr doc;
             xmlNodePtr root,new,fields;

             doc = xmlReadFile(path, NULL, 0);
             if(doc == NULL)
             {
                 printf("Failed to open xml file\n");
                 return NULL;
             }
             printf("set transaction, can cause large amount of updates\n");
             stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(skdb));
             self = self_new(skdb);
             root =  xmlDocGetRootElement(doc);
             if(root)
             {
                 xmlChar *temp, *type;
                 for(new = root->xmlChildrenNode;new;new = new->next)
                 {
                     if (xmlStrEqual(new->name, (const xmlChar *) "title")) {
                         temp = xmlNodeGetContent(new);
                         if(temp)
                         {
                             self_set_title(self, (char *)temp);
                             xmlFree(temp);
                         }
                     }
                     else if (xmlStrEqual(new->name, (const xmlChar *) "fields")) {
                         for(fields = new->xmlChildrenNode;fields;fields = fields->next)
                         {
                             if(xmlStrEqual(fields->name, (const xmlChar *) "row"))
                             {
                                 xmlChar *in_title = xmlGetProp(fields, (const xmlChar *)"in_title");
                                 type = xmlGetProp(fields, (const xmlChar *)"type");
                                 
                                 temp = xmlNodeGetContent(fields);
                                 if(temp)
                                 {
                                     int iin_title = (in_title)? (int)g_ascii_strtoll ((char *)in_title, NULL, 0):0;
                                     FieldType itype = (int)g_ascii_strtoll ((char *)type, NULL, 0);
                                     printf("type: %i\n", itype);
                                     self_add_field(self, itype,(char *)temp,iin_title); 
                                     if(type)
                                         xmlFree(type);
                                     xmlFree(temp);
                                 }
                             }
                         }
                     }
                 }
             }
             stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(skdb));
             xmlFreeDoc(doc);
             return self;
         }

         public
         gboolean
         save_to_xml(self,const char *path)
         {
             int i=0;
             gsize length=0;
             gchar **retv;
             xmlDocPtr doc;
             xmlNodePtr root,new,fields;
             gchar *field = NULL;
             /* open file */
             doc = xmlNewDoc((xmlChar *)"1.0"); 
             if(!doc)
             {
                 printf("Failed to open xml file\n");
                 return FALSE;
             }
             /* create root node */
             root = xmlNewDocNode (doc, NULL, (xmlChar *) "StuffkeeperSchema", NULL);
             /* Set root node */
             xmlDocSetRootElement(doc, root);

             /* Save title */
             field = self_get_title(self);
             new = xmlNewTextChild(root, NULL, (xmlChar *)"title", (xmlChar *)field);
             g_free(field);

             /* Save fields */
             /* create root node */
             fields = xmlNewTextChild(root, NULL, (xmlChar *)"fields", NULL);
             /* get fields */
             retv = self_get_fields(self, &length);
             for(i=0;i<length;i++)
             {
                 char *type;
                 FieldType ft= self_get_field_type(self, retv[i]);
                 /*int order = self_get_field_pos(self, retv[i]);*/
                 char *name = self_get_field_name(self, retv[i]);
                 int in_title= self_get_field_in_title(self, retv[i]);

                 new = xmlNewTextChild(fields, NULL, (xmlChar *)"row",(xmlChar *)name);

                 /* Order */
                /* 
                 type = g_strdup_printf("%i",order);
                 xmlNewProp(new, (xmlChar *) "order", (xmlChar *)type);
                 g_free(type);
                 */

                 /* Type */
                 type = g_strdup_printf("%i",ft);
                 xmlNewProp(new, (xmlChar *) "type", (xmlChar *)type);
                 g_free(type);

                 /* in_title*/
                 type = g_strdup_printf("%i",in_title);
                 xmlNewProp(new, (xmlChar *) "in_title", (xmlChar *)type);
                 g_free(type);

                 g_free(name);
             }
             if(xmlSaveFormatFile(path, doc, 1) < 0)
             {
                 xmlFreeDoc(doc);
                 return FALSE;
             }
             xmlFreeDoc(doc);
             return TRUE;
         }
         public
         StuffkeeperDataBackend *
         get_backend(self)
         {
            return self->_priv->skdb;
         }

        public
        void
        field_reorder(self, const char **fields)
        {
            sqlite3_stmt *stmt;
            const char *tail;
            int r,i;
            int changed = 0;
            int num_fields =0;
            int input_num_fields;

            char *query;
            if(!fields)
            {
                printf("Nothing todo\n");
                return;
            }
            /* count the number of fields */
            query = sqlite3_mprintf("SELECT COUNT(DISTINCT FieldId) FROM SchemasFields WHERE SchemaId=%i",self->_priv->id);



            r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            if (r == SQLITE_OK)
            {
                if((r = sqlite3_step(stmt)) == SQLITE_ROW)
                {
                    num_fields = sqlite3_column_int(stmt, 0);
                }
            }
            else
            {
                printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
            }
            sqlite3_finalize(stmt);
            sqlite3_free(query);

           for(input_num_fields=0;fields[input_num_fields];input_num_fields++); 

            if(input_num_fields != num_fields)
            {
                printf("number of fields reorder does not match total number of fields\n");
                printf("%i - %i\n", input_num_fields,num_fields);
                return;
            }
            for(i=0;i<num_fields;i++)
            {
                changed += self_field_schemas_set_field_integer(self, DB_SCHEMAS_FIELD_TYPE_ORDER,fields[i],i);
            }
            if(changed>0)
            {
                self_update_mtime(self);
                self_schema_fields_reordered(self);
            }
        }
}
