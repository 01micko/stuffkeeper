requires 2.0.10

%ph{
#include <glib/gstdio.h>
#include <stdio.h>
#define KEYFILE_GENERAL "general"
#define KEYFILE_FIELD_TYPES "field-types" 
#define KEYFILE_FIELD_NAMES "field-names" 
#define KEYFILE_FIELD_SORT  "field-sort"
#include "stuffkeeper-data-item.h"
#define SAVE_TIMEOUT 30000 
%}
%h{
    typedef enum _FieldType{
        FIELD_TYPE_STRING = 0,
        FIELD_TYPE_INTEGER = 1,
        FIELD_TYPE_BOOLEAN = 2,
        FIELD_TYPE_RATING = 3,
        FIELD_TYPE_LIST = 4,
        FIELD_TYPE_TEXT = 5,
        FIELD_TYPE_IMAGE = 6,
        FIELD_TYPE_NUM_FIELDS
    } FieldType;
    extern char *FieldNames[FIELD_TYPE_NUM_FIELDS];
%}
%ph{
        char *FieldNames[FIELD_TYPE_NUM_FIELDS] = {
        "String",   // FIELD_TYPE_STRING
        "Integer",  // FIELD_TYPE_INTEGER
        "Boolean",  // FIELD_TYPE_BOOLEAN
        "Slider",   // FIELD_TYPE_RATING
        "List",     // FIELD_TYPE_LIST
        "Text",     // FIELD_TYPE_TEXT
        "Image"     // FIELD_TYPE_IMAGE
    };

    typedef struct _a { char *id; int pos; }a;


%}
class StuffKeeper:Data:Schema from G:Object 
{
    private gboolean changed = {FALSE};
    private GKeyFile *data = {NULL};
    private char * path = {NULL} destroywith g_free;



    private GList *items = {NULL} destroywith g_list_free;



    private guint save_timeout = {0};
    /**
     * Signals 
     */
    signal last NONE (NONE)
        void
        schema_changed(self)
        {

        }
    signal last NONE (STRING)
        void
        schema_field_changed(self,const gchar *field)
        {
        }
   signal last NONE (STRING)
        void
        schema_field_added(self,const gchar *field)
        {
        }
   signal last NONE (STRING,STRING)
        void
        schema_field_swapped(self,const gchar *field, const gchar *field2)
        {
        }

   signal last NONE (STRING)
        void
        schema_field_removed(self,const gchar *field)
        {
        }
   private
       void
    mark_changed(self)
    {
        if(self->_priv->save_timeout)
        {
            g_source_remove(self->_priv->save_timeout);
            self->_priv->save_timeout = 0;
        }
        self->_priv->changed = TRUE;

        self->_priv->save_timeout = g_timeout_add(SAVE_TIMEOUT, (GSourceFunc)self_save_yourself, self);
    }

    /**
     * Constructors
     */
    public
    StuffKeeperDataSchema *
        new_from_file (const gchar *file)
        {
            Self *obj = GET_NEW;
            obj->_priv->data = g_key_file_new();
            obj->_priv->path = g_strdup(file);
            g_key_file_load_from_file(obj->_priv->data, obj->_priv->path, G_KEY_FILE_KEEP_COMMENTS, NULL);
            return obj;
        }

    public
     StuffKeeperDataSchema *
        new_with_id (const gchar *path,gint id)
        {
            Self *obj = GET_NEW;
            obj->_priv->path = g_strdup_printf("%s%c%i", path, G_DIR_SEPARATOR,id);
            obj->_priv->data = g_key_file_new();
            g_key_file_set_integer(obj->_priv->data, KEYFILE_GENERAL,"id", id);
            self_save_yourself(obj);
            return obj;
        }
    public 
        StuffKeeperDataSchema *
        new (const gchar *path)
        {

            Self *obj = GET_NEW;
            gint id = g_random_int();
            obj->_priv->path = g_strdup_printf("%s%c%i", path, G_DIR_SEPARATOR,id);
            obj->_priv->data = g_key_file_new();
            g_key_file_set_integer(obj->_priv->data, KEYFILE_GENERAL,"id", id);
            self_save_yourself(obj);
            return obj;
        }                                                                          
                
    /**
     * Functions to manage 
     */
    public
        void
        save_yourself(self)
        {
            if(self->_priv->data && self->_priv->changed == TRUE)
            {
                char *content;
                gsize size=0;
                printf("Saving my schema self\n");
                content = g_key_file_to_data(self->_priv->data,&size, NULL);
                g_file_set_contents(self->_priv->path, content, size, NULL);
                g_free(content);
                /* reset changed */
                self->_priv->changed = FALSE;
            }
            if(self->_priv->save_timeout)
            {
                g_source_remove(self->_priv->save_timeout);
                self->_priv->save_timeout = 0;
            }
        }

    public
        void
        delete_yourself(self)
        {
            g_key_file_set_integer(self->_priv->data, KEYFILE_GENERAL,"id", -1);
            g_unlink(self->_priv->path);
            g_free(self->_priv->path);
            self->_priv->path = NULL;
        }

    /**
     * ID (ro)
     */
    public
        gint
        get_id(self)
        {
            gint id = g_key_file_get_integer(self->_priv->data, KEYFILE_GENERAL, "id",NULL);
            return id;
        }

    /**
     * Title (rw)
     */
    public 
    gchar *
    get_title(self)
    {
        return g_key_file_get_string(self->_priv->data, KEYFILE_GENERAL, "title", NULL); 
    }


    public 
    void
    set_title(self, const gchar *title)
    {
        g_key_file_set_string(self->_priv->data, KEYFILE_GENERAL, "title", title);
        self_schema_changed(self);
        /* mark changed */
        self_mark_changed(self);
    }
    /**
     * Some nasty hacking to return a ordered list.
     */
     private 
     int
     sort_a_list(a *aa, a *ab)
     {
        return aa->pos - ab->pos;
     }
    public
    gchar **
    get_fields(self, gsize *size)
    {
        gchar **retv = NULL;
        a *l = NULL;
        GList *iter,*list = NULL;
        *size = 0;
        int i =0;
        retv = g_key_file_get_keys(self->_priv->data, KEYFILE_FIELD_TYPES,size, NULL);
        if(!retv)
            return retv;
        /* fix "old" schema's */
        if(!g_key_file_has_group(self->_priv->data, KEYFILE_FIELD_SORT))
        {
            for(i=0;i<*size;i++)
            {
                g_key_file_set_integer(self->_priv->data, KEYFILE_FIELD_SORT,retv[i],i);
            }
            self_mark_changed(self);
        }

        for( i=0;i<*size;i++)
        {
            l = g_malloc0(sizeof(*l));
            l->id = retv[i];
            l->pos = self_get_field_pos(self, retv[i]);
            list = g_list_prepend(list, l);
        }
        list = g_list_sort(list, (GCompareFunc)self_sort_a_list);
        i =0;
        for(iter = g_list_first(list);iter;iter = g_list_next(iter))
        {
            l = iter->data;
            retv[i] = l->id;
            i++;
        }

        g_list_foreach(list, (GFunc)g_free, NULL);
        g_list_free(list);
        return retv;
    }

    public 
    int 
    get_field_pos(self, const gchar *id)
    {
        return g_key_file_get_integer(self->_priv->data, KEYFILE_FIELD_SORT,id, NULL);
    }
    public 
        void 
    swap_field_pos(self, const gchar *id, const gchar *id2)
    {
        int pos = self_get_field_pos(self, id);
        int pos2 = self_get_field_pos(self, id2);
        g_key_file_set_integer(self->_priv->data, KEYFILE_FIELD_SORT,id,pos2);
        g_key_file_set_integer(self->_priv->data, KEYFILE_FIELD_SORT,id2,pos);


        self_schema_field_changed(self,id);
        self_schema_field_changed(self,id2);
        self_schema_field_swapped(self, id, id2);
        self_mark_changed(self);
    }

    public 
    FieldType 
    get_field_type(self, const gchar *id)
    {
        return g_key_file_get_integer(self->_priv->data, KEYFILE_FIELD_TYPES,id, NULL);
    }
    /* Be carefull with this */
    public 
    void 
    set_field_type(self, const gchar *id, FieldType type)
    {
        g_key_file_set_integer(self->_priv->data, KEYFILE_FIELD_TYPES,id,type);
        self_schema_field_changed(self,id);
        self_mark_changed(self);
    }






    public
    gchar *
    get_field_name(self, const gchar *id)
    {
        return g_key_file_get_string(self->_priv->data, KEYFILE_FIELD_NAMES,id, NULL);
    }

    public
    void
    set_field_name(self, const gchar *id, const gchar *name)
    {
        g_key_file_set_string(self->_priv->data, KEYFILE_FIELD_NAMES,id, name);
        self_schema_field_changed(self,id);
        self_mark_changed(self);
    }
    /* Field editing */
    public
    void
    add_field(self, FieldType field, const gchar *name)
    {
        gchar **retv = NULL; 
        gsize size=0;
        int pos = 0;
        gchar *id = g_strdup_printf("%u", (guint)g_random_int());
        while(g_key_file_has_key(self->_priv->data, KEYFILE_FIELD_TYPES, id, NULL))
        {
            g_free(id);
            id = g_strdup_printf("%u", (guint)g_random_int());
        }
        /* find new position */
        retv = self_get_fields(self,&size);
        if(retv)
        {
            /* get the position of the last item and put it after that */
            pos = self_get_field_pos(self,retv[size-1])+1;
            g_strfreev(retv);
        }

        /* Add the field */
        g_key_file_set_integer(self->_priv->data, KEYFILE_FIELD_TYPES,id, field); 
        g_key_file_set_string(self->_priv->data, KEYFILE_FIELD_NAMES,id, name); 
        g_key_file_set_integer(self->_priv->data, KEYFILE_FIELD_SORT,id, pos); 

        /* Mark it for saving */
        self_mark_changed(self);

        self_schema_field_added(self, id);
        g_free(id);
    }
    public
    void
    remove_field(self, const gchar *id)
    {
        /* Remove the type field */
        g_key_file_remove_key(self->_priv->data, KEYFILE_FIELD_TYPES, id, NULL);
        /* Remove the Name field */
        g_key_file_remove_key(self->_priv->data, KEYFILE_FIELD_NAMES, id, NULL);
        /* Remove sort field */
        g_key_file_remove_key(self->_priv->data, KEYFILE_FIELD_SORT, id, NULL);

        /* Mark it for saving */
        self_mark_changed(self);
        self_schema_field_removed(self, id);
    }

    /* Item handling */
    public
        int
        num_items(self)
        {
            return g_list_length(self->_priv->items);
        }
    public
        void
        add_item(self, GObject *item)
        {
            self->_priv->items = g_list_append(self->_priv->items, STUFFKEEPER_DATA_ITEM(item));
            self_schema_changed(self);
        }
    public 
        void
        remove_item(self, GObject *item)
        {
            self->_priv->items = g_list_remove(self->_priv->items, STUFFKEEPER_DATA_ITEM(item));
            self_schema_changed(self);
        }

        override (G:Object)
        void
        finalize(G:Object *obj)
        {
            Self *self = SELF(obj);
            printf("destroying schema\n");
            if(self->_priv->save_timeout)
            {
                g_source_remove(self->_priv->save_timeout);
                self->_priv->save_timeout = 0;
            }
        }
}
