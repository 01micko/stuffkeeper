requires 2.0.10

%h{
#include <glib.h>
#include <sqlite3.h>
#include <glib/gstdio.h>
#include "debug.h"
#include "stuffkeeper-data-tag.h"
#include "stuffkeeper-data-item.h"
#include "stuffkeeper-data-schema.h"



typedef enum _SearchType {
    SEARCH_TYPE_NONE = 0,
    SEARCH_TYPE_IS = 1,
    SEARCH_TYPE_IS_NOT = 2,
    SEARCH_TYPE_CONTAINS = 3
}SearchType;


typedef enum _SearchFieldType {
    SEARCH_TITLE            = 0,
    SEARCH_FIELD_SCHEMA     = 1,
    SEARCH_FIELD_TAG        = 2,
    SEARCH_FIELD_TITLE      = 3,
    SEARCH_FIELD_VALUE      = 4,
    NUM_SEARCH_FIELD        = 5
}SearchFieldType;

%}
%ph{
#include "stuffkeeper-data-backend.h"
%}

class StuffKeeper:Data:Item:Search from G:Object 
{
    private int is_dummy = {FALSE};
    private int id = {-1};
    private StuffKeeperDataBackend *skdb = {NULL};
    private sqlite3 *sqlHandle = {NULL};

    private 
    gchar *
    items_get_field_string(self, int searchtype, int fieldtype)
    {
        char *retv = NULL;
        char *query = sqlite3_mprintf("SELECT value FROM 'SearchFields' WHERE SearchId=%i and SearchType=%i and FieldType=%i", self->_priv->id,searchtype, fieldtype);
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        printf("query: %s\n", query);
        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK) {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW) {
                retv = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
            }
        }
        sqlite3_finalize(stmt);

        sqlite3_free(query);
        return retv; 
    }

    public
    GObject *
    new_dummy(void)
    {
        Self *self = GET_NEW;
        self->_priv->is_dummy = TRUE;
        return G_OBJECT(self);
    }

    public
    GObject *
    open_from_id(G:Object *skdb, sqlite3 *sqlHandle,gint id)
    {
        Self *self = GET_NEW;
        self->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
        self->_priv->id = id;
        self->_priv->sqlHandle = sqlHandle;
        printf("new item: %i\n", id);
        return G_OBJECT(self);
    }

    public
    int 
    match(self, StuffKeeperDataItem *item)
    {
        if(self->_priv->is_dummy == TRUE)
        {
            return TRUE;
        }
        char *query = sqlite3_mprintf("SELECT FieldType,SearchType,value FROM 'SearchFields' WHERE SearchId=%i and SearchType!=%i", 
                        self->_priv->id, SEARCH_TYPE_NONE);
        sqlite3_stmt *stmt;
        const char *tail;
        int found = FALSE;
        int r;
        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK && found == FALSE) {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW) {
                int SearchFieldType = sqlite3_column_int(stmt, 0);
                int SearchType = sqlite3_column_int(stmt, 1);
                char *value = sqlite3_column_text(stmt, 2);
                gchar *comp = NULL;
                printf("%i:%i:%s\n", SearchType,SearchFieldType, value);



                if(SearchFieldType == SEARCH_FIELD_TITLE)
                {
                    comp = stuffkeeper_data_item_get_title(item);

                }
                if(comp)
                {
                    if(SearchType == SEARCH_TYPE_IS)                   
                    {
                        found = (g_utf8_collate(value,comp) == 0); 
                    }
                    if(SearchType == SEARCH_TYPE_CONTAINS)
                    {
                        gchar *sb1 = g_utf8_casefold(value, -1);
                        gchar *sb = g_utf8_normalize(sb1,-1,G_NORMALIZE_ALL_COMPOSE);
                        gchar *sa1 = g_utf8_casefold(comp, -1);
                        gchar *sa = g_utf8_normalize(sa1,-1,G_NORMALIZE_ALL_COMPOSE);
                        if(strstr(sa,sb) != NULL)
                        {
                            found = TRUE;
                        }
                        g_free(sa1);g_free(sb1);
                        g_free(sa);g_free(sb);

                    }
                    g_free(comp);
                }
            }
        }
        sqlite3_finalize(stmt);



        return found; 
    }

    public
    char *
    get_title(self)
    {
        char *retv;
        if(self->_priv->is_dummy == TRUE)
        {
            return g_strdup(("All the entries"));
        }
        retv = self_items_get_field_string(self,SEARCH_TYPE_NONE, SEARCH_TITLE);
        if(!retv)
            retv = g_strdup("Failed to get title");
        return retv;
    }

    public
    int
    get_id(self)
    {
        return self->_priv->id;
    }
}
