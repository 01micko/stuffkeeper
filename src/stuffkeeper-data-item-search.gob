requires 2.0.10

%h{
#include <glib.h>
#include <sqlite3.h>
#include <glib/gstdio.h>
#include "debug.h"
#include "stuffkeeper-data-tag.h"
#include "stuffkeeper-data-item.h"
#include "stuffkeeper-data-schema.h"



typedef enum _SearchType {
    SEARCH_TYPE_NONE = 0,
    SEARCH_TYPE_IS = 1,
    SEARCH_TYPE_IS_NOT = 2,
    SEARCH_TYPE_CONTAINS = 3,
    SEARCH_TYPE_NOT_CONTAINS = 4
}SearchType;


typedef enum _SearchFieldType {
    SEARCH_TITLE            = 0,
    SEARCH_FIELD_SCHEMA     = 1,
    SEARCH_FIELD_TAG        = 2,
    SEARCH_FIELD_TITLE      = 3,
    SEARCH_FIELD_VALUE      = 4,
    NUM_SEARCH_FIELD        = 5
}SearchFieldType;

%}
%ph{
#include "stuffkeeper-data-backend.h"
%}

class StuffKeeper:Data:Item:Search from G:Object 
{
    private int is_dummy = {FALSE};
    private int id = {-1};
    private StuffKeeperDataBackend *skdb = {NULL};
    private sqlite3 *sqlHandle = {NULL};

    /**
     * Utility
     */
    private 
    gchar *
    items_get_field_string(self, int searchtype, int fieldtype)
    {
        char *retv = NULL;
        char *query = sqlite3_mprintf("SELECT value FROM 'SearchFields' WHERE SearchId=%i and SearchType=%i and FieldType=%i", self->_priv->id,searchtype, fieldtype);
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK) {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW) {
                retv = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
            }
        }
        sqlite3_finalize(stmt);

        sqlite3_free(query);
        return retv; 
    }
    /**
     * Constructions
     */
    public
    GObject *
    new_dummy(void)
    {
        Self *self = GET_NEW;
        self->_priv->is_dummy = TRUE;
        return G_OBJECT(self);
    }

    public
    GObject *
    open_from_id(G:Object *skdb, sqlite3 *sqlHandle,gint id)
    {
        Self *self = GET_NEW;
        self->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
        self->_priv->id = id;
        self->_priv->sqlHandle = sqlHandle;
        printf("new item: %i\n", id);
        return G_OBJECT(self);
    }
    /* Create new StuffKeeperDataBackend */
    public 
        StuffKeeperDataItemSearch *
        new (G:Object *skdb, sqlite3 *sqlHandle)
        {

            Self *obj = GET_NEW;
            int result = 0;
            char *error = NULL;
            char *query  = NULL;
            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->sqlHandle = sqlHandle;
            /**
             * Insert the first item in the list
             */
            query = sqlite3_mprintf
                ("INSERT INTO 'SearchFields' ('SearchType','FieldType','value')"
                 "values (%i,%i,%Q);",
                 SEARCH_TYPE_NONE, SEARCH_TITLE, "New Search");

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* Get the id of the insert, this is now the unique id for this field*/
            obj->_priv->id = sqlite3_last_insert_rowid(obj->_priv->sqlHandle);

            /* update the last inserted row */
            query = sqlite3_mprintf
                ("UPDATE 'SearchFields' SET SearchId=%i WHERE id=%i",
                 obj->_priv->id,obj->_priv->id);
            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            
            return obj;
        }



    public
    int 
    match(self, StuffKeeperDataItem *item)
    {
        if(self->_priv->is_dummy == TRUE)
        {
            return TRUE;
        }
        char *query = sqlite3_mprintf("SELECT FieldType,SearchType,value FROM 'SearchFields' WHERE SearchId=%i and SearchType!=%i", 
                        self->_priv->id, SEARCH_TYPE_NONE);
        sqlite3_stmt *stmt;
        const char *tail;
        int found = TRUE;
        int r;
        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if(r == SQLITE_OK ) {
            while((r = sqlite3_step(stmt)) == SQLITE_ROW && found) {
                int SearchFieldType = sqlite3_column_int(stmt, 0);
                int SearchType = sqlite3_column_int(stmt, 1);
                char *value = sqlite3_column_text(stmt, 2);
                gchar *comp = NULL;

                found = FALSE;

                if(SearchFieldType == SEARCH_FIELD_TITLE)
                {
                    comp = stuffkeeper_data_item_get_title(item);

                }
                else if (SearchFieldType == SEARCH_FIELD_SCHEMA)
                {
                    comp = stuffkeeper_data_schema_get_title(stuffkeeper_data_item_get_schema(item));
                }

                if(comp)
                {
                    if(SearchType == SEARCH_TYPE_IS)                   
                    {
                        int v= (g_utf8_collate(value,comp) == 0); 
                        if((v &&SearchType == SEARCH_TYPE_IS) || (SearchType == SEARCH_TYPE_IS_NOT && !v))
                        {
                            found = TRUE;
                        }
                    }
                    if(SearchType == SEARCH_TYPE_CONTAINS || SearchType == SEARCH_TYPE_NOT_CONTAINS )
                    {
                        int v =  0;
                        gchar *sb1 = g_utf8_casefold(value, -1);
                        gchar *sb = g_utf8_normalize(sb1,-1,G_NORMALIZE_ALL_COMPOSE);
                        gchar *sa1 = g_utf8_casefold(comp, -1);
                        gchar *sa = g_utf8_normalize(sa1,-1,G_NORMALIZE_ALL_COMPOSE);
                        v =(strstr(sa,sb) != NULL);
                        if((SearchType == SEARCH_TYPE_CONTAINS && v) || (SearchType == SEARCH_TYPE_NOT_CONTAINS && !v)) {
                            found = TRUE;
                        }
                        g_free(sa1);g_free(sb1);
                        g_free(sa);g_free(sb);

                    }
                    g_free(comp);
                }
            }
        }
        sqlite3_finalize(stmt);



        return found; 
    }

    public
    char *
    get_title(self)
    {
        char *retv;
        if(self->_priv->is_dummy == TRUE)
        {
            return g_strdup(("All the entries"));
        }
        retv = self_items_get_field_string(self,SEARCH_TYPE_NONE, SEARCH_TITLE);
        if(!retv)
            retv = g_strdup("Failed to get title");
        return retv;
    }

    public
    int
    get_id(self)
    {
        return self->_priv->id;
    }

    public
    void
    delete_yourself(self)
    {
        int result;
        char *error;
        char *query = NULL; 

        query = sqlite3_mprintf("DELETE FROM 'SearchFields' WHERE SearchId=%i",self->_priv->id);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            debug_printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        
        self->_priv->id = 0;
    }

}
