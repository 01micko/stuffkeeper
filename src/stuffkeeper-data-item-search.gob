requires 2.0.10

%h{
#include <glib.h>
#include <sqlite3.h>
#include <glib/gstdio.h>
#include "debug.h"
#include "stuffkeeper-data-tag.h"
#include "stuffkeeper-data-item.h"
#include "stuffkeeper-data-schema.h"



typedef enum _SearchType {
    SEARCH_TYPE_NONE = 0,
    SEARCH_TYPE_IS = 1,
    SEARCH_TYPE_IS_NOT = 2,
    SEARCH_TYPE_CONTAINS = 3,
    SEARCH_TYPE_NOT_CONTAINS = 4
}SearchType;


typedef enum _SearchFieldType {
    SEARCH_TITLE            = 0,
    SEARCH_FIELD_SCHEMA     = 1,
    SEARCH_FIELD_TAG        = 2,
    SEARCH_FIELD_TITLE      = 3,
    SEARCH_FIELD_VALUE      = 4,
    NUM_SEARCH_FIELD        = 5
}SearchFieldType;

typedef struct _SearchField
{
    int id;
    int field_id;
    SearchFieldType field_type;
    SearchType type;
    char *value;
}SearchField;

%}
%ph{
#include "stuffkeeper-data-backend.h"
%}

class StuffKeeper:Data:Item:Search from G:Object 
{
    private int is_dummy = {FALSE};
    private int id = {-1};
    private StuffKeeperDataBackend *skdb = {NULL};
    private sqlite3 *sqlHandle = {NULL};

    /**
     * Signals
     */

    signal last NONE (POINTER)
    void
    search_changed(self, const gchar *id)
    {


    }


    /**
     * Utility
     */
    private 
    gchar *
    get_string(self, int searchtype, int fieldtype)
    {
        char *retv = NULL;
        char *query = sqlite3_mprintf("SELECT value FROM 'SearchFields' WHERE SearchId=%i and SearchType=%i and FieldType=%i", 
                self->_priv->id,
                searchtype,
                fieldtype);
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK) {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW) {
                retv = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
            }
        }
        sqlite3_finalize(stmt);

        sqlite3_free(query);
        return retv; 
    }
    public 
    void
    set_string(self,int searchtype, int fieldtype, const gchar *title)
    {
        int result;
        char *error;
        char *query;
        char *val;
        val = self_get_string(self, searchtype,fieldtype);
        /* no field, create it */
        if(!val)
        {
            query = sqlite3_mprintf("INSERT INTO 'SearchFields' ('SearchId','FieldType','SearchType','value')"
                    "values (%i,%i,%i,%Q);",
                    self->_priv->id,
                    fieldtype,
                    searchtype,
                    title);
        }
        else{
            /* if they are identical, do nothing */
            if(strcmp(title, val) == 0)
            {
                g_free(val);
                debug_printf("not updating\n");
                return;
            }
            /* update the title */
            query = sqlite3_mprintf("UPDATE 'SearchFields' SET value=%Q WHERE SearchId=%i and Fieldtype=%i and SearchType=%i", 
                    title, 
                    self->_priv->id,
                    fieldtype,
                    searchtype);
            g_free(val);
        }
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            debug_printf("failed: %s\n", error);
        }
        sqlite3_free(query);
    }


    /**
     * Constructions
     */
    public
    GObject *
    new_dummy(void)
    {
        Self *self = GET_NEW;
        self->_priv->is_dummy = TRUE;
        return G_OBJECT(self);
    }

    public
    GObject *
    open_from_id(G:Object *skdb, sqlite3 *sqlHandle,gint id)
    {
        Self *self = GET_NEW;
        self->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
        self->_priv->id = id;
        self->_priv->sqlHandle = sqlHandle;
        printf("new item: %i\n", id);
        return G_OBJECT(self);
    }
    /* Create new StuffKeeperDataBackend */
    public 
        StuffKeeperDataItemSearch *
        new (G:Object *skdb, sqlite3 *sqlHandle)
        {

            Self *obj = GET_NEW;
            int result = 0;
            char *error = NULL;
            char *query  = NULL;
            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->sqlHandle = sqlHandle;
            /**
             * Insert the first item in the list
             */
            query = sqlite3_mprintf
                ("INSERT INTO 'SearchFields' ('SearchType','FieldType','value')"
                 "values (%i,%i,%Q);",
                 SEARCH_TYPE_NONE, SEARCH_TITLE, "New Search");

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* Get the id of the insert, this is now the unique id for this field*/
            obj->_priv->id = sqlite3_last_insert_rowid(obj->_priv->sqlHandle);

            /* update the last inserted row */
            query = sqlite3_mprintf
                ("UPDATE 'SearchFields' SET SearchId=%i WHERE id=%i",
                 obj->_priv->id,obj->_priv->id);
            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            
            return obj;
        }
    public
    void
    free_search_field(SearchField*field)
    {
        if(field->value)
        {
            g_free(field->value);
        }
        g_free(field);
    }
    public
    GList *
    get_search_fields(self)
    {
        GList *list = NULL;
        char *query = sqlite3_mprintf("SELECT Id,SearchId,FieldType,SearchType,value FROM 'SearchFields' WHERE SearchId=%i and SearchType!=%i", 
                self->_priv->id, SEARCH_TYPE_NONE);
        sqlite3_stmt *stmt;
        const char *tail;
        int found = TRUE;
        int r;
        r = sqlite3_prepare(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if(r == SQLITE_OK ) {
            while((r = sqlite3_step(stmt)) == SQLITE_ROW && found) {
                SearchField *field  = g_malloc0(sizeof(*field));
                field->id           = sqlite3_column_int(stmt, 0);
                field->field_id     = sqlite3_column_int(stmt, 1);
                field->field_type   = sqlite3_column_int(stmt, 2); 
                field->type         = sqlite3_column_int(stmt, 3);
                field->value        = g_strdup(sqlite3_column_text(stmt, 4));
                list = g_list_append(list, field);
            }
        }

        sqlite3_finalize(stmt);
        return list;
    }

    public
    int 
    match(self, StuffKeeperDataItem *item)
    {
        GList *node,*list = NULL;
        int found = TRUE;
        if(self->_priv->is_dummy == TRUE)
        {
            return TRUE;
        }

        list = self_get_search_fields(self);
        for(node = g_list_first(list);node && found;node = g_list_next(node))
        {
            SearchField *field = node->data;
            gchar *comp = NULL;
            found = FALSE;
            if(field->field_type== SEARCH_FIELD_TITLE)
            {
                comp = stuffkeeper_data_item_get_title(item);

            }
            else if (field->field_type== SEARCH_FIELD_SCHEMA)
            {
                comp = stuffkeeper_data_schema_get_title(stuffkeeper_data_item_get_schema(item));
            }

            if(comp)
            {
                if(field->type == SEARCH_TYPE_IS)                   
                {
                    int v= (g_utf8_collate(field->value,comp) == 0); 
                    if((v && field->type == SEARCH_TYPE_IS) || (field->type == SEARCH_TYPE_IS_NOT && !v))
                    {
                        found = TRUE;
                    }
                }
                if(field->type == SEARCH_TYPE_CONTAINS || field->type == SEARCH_TYPE_NOT_CONTAINS )
                {
                    int v =  0;
                    gchar *sb1 = g_utf8_casefold(field->value, -1);
                    gchar *sb = g_utf8_normalize(sb1,-1,G_NORMALIZE_ALL_COMPOSE);
                    gchar *sa1 = g_utf8_casefold(comp, -1);
                    gchar *sa = g_utf8_normalize(sa1,-1,G_NORMALIZE_ALL_COMPOSE);
                    v =(strstr(sa,sb) != NULL);
                    if((field->type == SEARCH_TYPE_CONTAINS && v) || (field->type == SEARCH_TYPE_NOT_CONTAINS && !v)) {
                        found = TRUE;
                    }
                    g_free(sa1);g_free(sb1);
                    g_free(sa);g_free(sb);

                }
                g_free(comp);
            }

        }
        if(list)
        {
            g_list_foreach(list, self_free_search_field,NULL);
            g_list_free(list);
        }


        return found; 
    }

    public
    char *
    get_title(self)
    {
        char *retv;
        if(self->_priv->is_dummy == TRUE)
        {
            return g_strdup(("All the entries"));
        }
        retv = self_get_string(self,SEARCH_TYPE_NONE, SEARCH_TITLE);
        if(!retv)
            retv = g_strdup("Failed to get title");
        return retv;
    }
    public
    void 
    set_title(self, const char *title)
    {
        if(self->_priv->is_dummy == TRUE)
        {
            return;
        }
        self_set_string(self, SEARCH_TYPE_NONE, SEARCH_TITLE, title);
        self_search_changed(self, NULL);
    }

    public
    int
    get_id(self)
    {
        return self->_priv->id;
    }

    public
    void
    delete_yourself(self)
    {
        int result;
        char *error;
        char *query = NULL; 

        query = sqlite3_mprintf("DELETE FROM 'SearchFields' WHERE SearchId=%i",self->_priv->id);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            debug_printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        
        self->_priv->id = 0;
    }

}
