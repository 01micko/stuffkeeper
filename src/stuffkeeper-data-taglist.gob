requires 2.0.10

%h{
#include <gtk/gtk.h>
#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-data-item.h"
#include "stuffkeeper-data-tag.h"
#include "stuffkeeper-data-label.h"
#include <math.h>
%}

class StuffKeeper:Data:TagList from Gtk:Table
{
    private StuffKeeperDataItem *item = {NULL};
    private gchar *field = {NULL} destroywith g_free;
    private StuffKeeperDataBackend *skdb = {NULL};

    private gulong uid_tag_changed = {0};
    private gulong uid_tag_added = {0};
    private gulong uid_tag_removed = {0};


    private GList *tags = {NULL} destroywith g_list_free;
    private
        void
        reload_data(self)
        {
            GList *node, *list = gtk_container_get_children(GTK_CONTAINER(self));
            for(node =list; node; node = g_list_next(node))
            {
                g_object_ref(node->data);
                gtk_container_remove(GTK_CONTAINER(self), GTK_WIDGET(node->data));
            }
            g_list_free(list);


           
            /** now fill it again */
            gsize length = g_list_length(self->_priv->tags); 
            if(length)
            {
                node = g_list_first(self->_priv->tags);
                gint cols = sqrt(length/2)+1;
                gint rows = (int)((length)/((double)cols))+1;
                gtk_table_resize(GTK_TABLE(self),rows,cols); 
                int item=0;
                for(;node;node = g_list_next(node))
                {
                    GtkWidget *label1 = node->data;
                    gtk_table_attach(GTK_TABLE(self), label1, 
                                (item%cols),(item%cols)+1,
                                (int)(item/((double)cols)),(int)(item/((double)cols))+1,
                                GTK_SHRINK|GTK_FILL,GTK_SHRINK|GTK_FILL, 0,0);
                    item++;
                }
            }
            gtk_widget_show_all(GTK_WIDGET(self));
        }


    private
    void
    tag_changed(self, StuffKeeperDataTag *tag)
    {
        int id = stuffkeeper_data_tag_get_id(tag);
        /* unused */
        GList *node ,*list = self->_priv->tags; 
        for(node = list;node;node= g_list_next(node))
        {
            gpointer data = g_object_get_data(G_OBJECT(node->data), "tag-id");
            if(data && GPOINTER_TO_INT(data) == id)
            {
                GtkWidget *label = gtk_bin_get_child(GTK_BIN(node->data));
                if(!stuffkeeper_data_item_has_tag(self->_priv->item,tag))
                {
                    gtk_widget_set_sensitive(label, FALSE);
                }
                else {
                    gtk_widget_set_sensitive(label, TRUE);
                }

                return;
            }
        }

        self_reload_data(self);
    }

    private
    void
    event_button_press_event(self, GdkEventButton *button, GtkEventBox *event)
    {
        if(button->button == 1)
        {
            gpointer data = g_object_get_data(G_OBJECT(event), "tag-id");
            if(data)
            {       
                StuffKeeperDataTag *tag = stuffkeeper_data_backend_get_tag(self->_priv->skdb, GPOINTER_TO_INT(data));
                if(tag)
                {
                    if(!stuffkeeper_data_item_has_tag(self->_priv->item,tag))
                    {
                        stuffkeeper_data_item_add_tag(self->_priv->item, tag);
                    }else{
                        stuffkeeper_data_item_remove_tag(self->_priv->item, tag);
                    }
                }
            }
        }

    }
    private
    void
    tag_added(self, StuffKeeperDataTag *tag)
    {
        GtkWidget *label = stuffkeeper_data_label_new_tag(STUFFKEEPER_DATA_TAG(tag)); 
        GtkWidget *event = gtk_event_box_new();
        gtk_event_box_set_visible_window(GTK_EVENT_BOX(event), FALSE);
        g_signal_connect_swapped(G_OBJECT(event), "button-press-event", G_CALLBACK(self_event_button_press_event), self);
        g_object_set_data(G_OBJECT(event), "tag-id", GINT_TO_POINTER(stuffkeeper_data_tag_get_id(tag)));
        gtk_container_add(GTK_CONTAINER(event), label);

        if(!stuffkeeper_data_item_has_tag(self->_priv->item,tag))
        {
            gtk_widget_set_sensitive(label, FALSE);
        }

        self->_priv->tags = g_list_append(self->_priv->tags, event);
        self_reload_data(self);
    }
    private
    void
    tag_removed(self, const int id)
    {
        GList *node;
        for(node = g_list_first(self->_priv->tags);node;node= g_list_next(node))
        {
            gpointer data = g_object_get_data(G_OBJECT(node->data), "tag-id");
            if(data && GPOINTER_TO_INT(data) == id)
            {
                GtkWidget *data = GTK_WIDGET(node->data);

                self->_priv->tags = g_list_remove(self->_priv->tags, data);
                gtk_widget_destroy(data);
                return;
            }
        }
        self_reload_data(self);
    }

    private 
    int 
    tag_sort_func(StuffKeeperDataTag *ta, StuffKeeperDataTag *tb, StuffKeeperDataBackend *skdb)
    {
        int retv = 0;
        
        gchar *aa, *bb;
        gchar *ca,*cb;

        aa = stuffkeeper_data_tag_get_title(ta);
        bb = stuffkeeper_data_tag_get_title(tb);

        ca = g_utf8_casefold(aa, -1);
        cb = g_utf8_casefold(bb,-1);
        retv = g_utf8_collate(ca,cb);

        g_free(ca);
        g_free(cb);

        g_free(aa);
        g_free(bb);

        return retv;
    }

    public
    GtkWidget *
    new(StuffKeeperDataBackend *skdb, StuffKeeperDataItem *item)
    {
        Self *obj = GET_NEW;

        /* store item */
        obj->_priv->skdb = skdb;
        obj->_priv->item = item; 
        obj->_priv->uid_tag_changed = g_signal_connect_swapped(G_OBJECT(obj->_priv->skdb), "tag-changed",G_CALLBACK(self_tag_changed), obj);
        obj->_priv->uid_tag_added = g_signal_connect_swapped(G_OBJECT(obj->_priv->skdb), "tag-added",G_CALLBACK(self_tag_added), obj);
        obj->_priv->uid_tag_removed = g_signal_connect_swapped(G_OBJECT(obj->_priv->skdb), "tag-removed",G_CALLBACK(self_tag_removed), obj);

        GList *node,*list =  stuffkeeper_data_backend_get_tags(skdb);
        /* Sort the tag list */
        list = g_list_sort_with_data(list, (GCompareDataFunc)self_tag_sort_func,skdb);
        for(node=g_list_first(list);node;node = g_list_next(node))
        {
            self_tag_added(obj, node->data);
        }
        return GTK_WIDGET(obj);
    }

    override (G:Object)
        void
        finalize (G:Object *obj)
        {
            Self *self = SELF(obj);
            if(self->_priv->uid_tag_changed)
            {
                g_signal_handler_disconnect(self->_priv->skdb,self->_priv->uid_tag_changed);
                self->_priv->uid_tag_changed= 0;
            }
            if(self->_priv->uid_tag_added)
            {
                g_signal_handler_disconnect(self->_priv->skdb,self->_priv->uid_tag_added);
                self->_priv->uid_tag_added= 0;
            }
            if(self->_priv->uid_tag_removed)
            {
                g_signal_handler_disconnect(self->_priv->skdb,self->_priv->uid_tag_removed);
                self->_priv->uid_tag_removed= 0;
            }

            PARENT_HANDLER(obj);
        }

}
