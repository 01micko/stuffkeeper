requires 2.0.10

%h{
    #include "stuffkeeper-data-schema.h"
    #include "stuffkeeper-data-item.h"
    #include "stuffkeeper-data-tag.h"
%}
%header{
    #include <glib/gstdio.h>
    #include <stdio.h>
    #include <string.h>
%}


class StuffKeeper:Data:Backend from G:Object 
{
    /**
     * Private values 
     */
    /* A hash list used to store the items, the item id is the hash key */
    private GHashTable *schemas = {g_hash_table_new_full(g_int_hash, g_int_equal,g_free, g_object_unref)} ;

    /* A hash list used to store the tags, the tags id is the hash key */
    private GHashTable *tags = {g_hash_table_new_full(g_int_hash, g_int_equal,g_free, g_object_unref)} ;

    /* A hash list used to store the items, the item id is the hash key */
    private GHashTable *items = {g_hash_table_new_full(g_int_hash, g_int_equal,g_free, g_object_unref)} ;

    /* The path this "db" resides */
    private gchar *path = {NULL} destroywith g_free;

    /**
     * Signal 
     */
    /* item */
    signal last NONE (STRING,POINTER)
    void
    item_changed(self, const gchar *field,StuffKeeperDataItem *item)
    {
    }

    signal last NONE (POINTER)
    void
    item_added(self, StuffKeeperDataItem *item)
    {
        g_signal_connect_swapped(G_OBJECT(item), "item-changed", G_CALLBACK(self_item_changed), self);

    }
    signal last NONE (INT)
        void
    item_removed(self, gint id)
    {
    }
    /* schema */
    signal last NONE (POINTER)
    void
    schema_changed(self, StuffKeeperDataSchema *schema)
    {
    }

    signal last NONE (POINTER)
    void
    schema_added(self, StuffKeeperDataSchema *schema)
    {
        g_signal_connect_swapped(G_OBJECT(schema), "schema-changed", G_CALLBACK(self_schema_changed), self);
    }
    signal last NONE (INT)
        void
    schema_removed(self, gint id)
    {
    }

    /**
     * Public functions 
     */
    public
        GList *
        get_items(self)
        {
            return g_hash_table_get_values(self->_priv->items);
        }

    public
    guint
    get_num_items(self)
    {
        return g_hash_table_size(self->_priv->items);
    }


    public 
    StuffKeeperDataItem *
    get_item(self, gint id)
    {
        StuffKeeperDataItem *item;
        item = g_hash_table_lookup(self->_priv->items, &id);
        return item;
    }

    public 
    StuffKeeperDataItem *
    new_item(self,StuffKeeperDataSchema *schema)
    {
        gint *id;
        StuffKeeperDataItem *item;
        gchar *path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path, "items", NULL);
        /* create a new item */
        item = stuffkeeper_data_item_new(G_OBJECT(self),path,schema);
        g_free(path);
        /* want to copy the key, even if it is an integer */
        id = g_malloc0(sizeof(gint));
        *id = stuffkeeper_data_item_get_id(item);
        /* insert it into my hash-list */
        g_hash_table_insert(self->_priv->items,id, item);
        self_item_added(self, item);

        return item;
    }

    public 
    void
    remove_item(self, gint id)
    {
        StuffKeeperDataItem *item = g_hash_table_lookup(self->_priv->items, &id);
        self_item_removed(self, id);
        if(item)
        {
            stuffkeeper_data_item_delete_yourself(item); 
        }
        if(g_hash_table_remove(self->_priv->items, &id) == FALSE)
        {
            return;
        }

    }

    /* Load the data */
    public
    void
    load(self, const gchar *db_path)
    {
        int iter;
        /* item */
        gchar *path;
        GDir *dir;


        /**
         * Store the path in the backend.
         */
        self->_priv->path = g_strdup(db_path);




        /** image dir */
        path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path,"images",NULL);
        if(!g_file_test(path, G_FILE_TEST_IS_DIR))
        {
            g_mkdir(path, 0755);
        }
        g_free(path);




        /**
         * Read Schemas 
         */

        path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path,"schemas",NULL);
        if(!g_file_test(path, G_FILE_TEST_IS_DIR))
        {
            g_mkdir(path, 0755);
        }

        /* Load item's */
        dir = g_dir_open(path, 0, NULL);

        /* cleanup path pointer */
        g_free(path);
        if(dir)
        {
            const gchar *filename;
            iter =0;
            while((filename = g_dir_read_name(dir))!= NULL)
            {
                gchar *full_path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path,"schemas", filename,NULL);
                StuffKeeperDataSchema *schema;
                gint *id;
                /* create a new item */
                schema = stuffkeeper_data_schema_new_from_file(full_path);
                /* want to copy the key, even if it is an integer */
                id = g_malloc0(sizeof(gint));
                *id = stuffkeeper_data_schema_get_id(schema);
                /* insert it into my hash-list */
                g_hash_table_insert(self->_priv->schemas,id, schema);
                self_schema_added(self, schema);
                g_free(full_path);

/*                while(iter%10 == 0 && gtk_events_pending())
                    gtk_main_iteration();
                    */
                iter++;
            }
            g_dir_close(dir);
        }

        /**
         * Read tags 
         */
        path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path,"tags",NULL);
        if(!g_file_test(path, G_FILE_TEST_IS_DIR))
        {
            g_mkdir(path, 0755);
        }

        /* Load item's */
        dir = g_dir_open(path, 0, NULL);

        /* cleanup path pointer */
        g_free(path);
        if(dir)
        {
            const gchar *filename;
            iter = 0;
            while((filename = g_dir_read_name(dir))!= NULL)
            {
                gchar *full_path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path,"tags", filename,NULL);
                StuffKeeperDataTag *tag;
                gint *id;
                /* create a new item */
                tag = stuffkeeper_data_tag_new_from_file(full_path);
                /* want to copy the key, even if it is an integer */
                id = g_malloc0(sizeof(gint));
                *id = stuffkeeper_data_tag_get_id(tag);
                /* insert it into my hash-list */
                g_hash_table_insert(self->_priv->tags,id, tag);
                self_tag_added(self, tag);
                g_free(full_path);
/*
                while(iter%10 == 0 && gtk_events_pending())
                    gtk_main_iteration();
*/                    
                iter++;
            }
            g_dir_close(dir);
        }

        /* test the items directory */
        path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path,"items",NULL);
        if(!g_file_test(path, G_FILE_TEST_IS_DIR))
        {
            g_mkdir(path, 0755);
        }

        /* Load item's */
        dir = g_dir_open(path, 0, NULL);

        /* cleanup path pointer */
        g_free(path);
        if(dir)
        {
            const gchar *filename;
            iter = 0;
            while((filename = g_dir_read_name(dir))!= NULL)
            {
                gchar *full_path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path,"items", filename,NULL);
                StuffKeeperDataItem *item;
                gint *id;
                /* create a new item */
                item = stuffkeeper_data_item_load_from_file(G_OBJECT(self),full_path);
                /* want to copy the key, even if it is an integer */
                id = g_malloc0(sizeof(gint));
                *id = stuffkeeper_data_item_get_id(item);
                /* insert it into my hash-list */
                g_hash_table_insert(self->_priv->items,id, item);
                self_item_added(self, item);

                g_free(full_path);
/*
                while(iter%10 == 0 && gtk_events_pending())
                    gtk_main_iteration();
*/                    
                iter++;
            }
            g_dir_close(dir);
        }
    }
    
    /**
     * Handle destroying of the object
     */
    private
    void
    finalize_schema(gint *key, StuffKeeperDataSchema *schema, gpointer user_data)
    {
        stuffkeeper_data_schema_save_yourself(schema);
    }
    private
    void
    finalize_item(gint *key, StuffKeeperDataItem *item, gpointer user_data)
    {
        stuffkeeper_data_item_save_yourself(item);
    }
    private
    void
    finalize_tag(gint *key, StuffKeeperDataTag *tag, gpointer user_data)
    {
        stuffkeeper_data_tag_save_yourself(tag);
    }



    override (G:Object)
    void
    finalize (G:Object *obj)
    {
        Self *self = SELF(obj);

        if(self->_priv->items)
        {
            g_hash_table_foreach(self->_priv->items, (GHFunc)self_finalize_item, NULL);
            g_hash_table_destroy(self->_priv->items);

            self->_priv->items = NULL;
        }
        if(self->_priv->tags)
        {
            g_hash_table_foreach(self->_priv->tags, (GHFunc)self_finalize_tag, NULL);
            g_hash_table_destroy(self->_priv->tags);

            self->_priv->tags = NULL;
        }
        if(self->_priv->schemas)
        {
            g_hash_table_foreach(self->_priv->schemas, (GHFunc)self_finalize_schema, NULL);
            g_hash_table_destroy(self->_priv->schemas);

            self->_priv->schemas = NULL;
        }

        PARENT_HANDLER(obj);
    }


    /**
     * Create new StuffKeeperDataBackend 
     * destroy with g_object_unref();
     */
    public 
    StuffKeeperDataBackend *
    new (void)
    {
        Self *self = GET_NEW;
        return self;
    }


    /**
     * Tags
     */
    /* signals  */
    signal last NONE (POINTER)
    void
    tag_changed(self, StuffKeeperDataTag *tag)
    {
    }

    signal last NONE (POINTER)
        void
        tag_added(self, StuffKeeperDataTag *tag)
        {

            g_signal_connect_swapped(G_OBJECT(tag), "tag-changed", G_CALLBACK(self_tag_changed), self);
        }

    signal last NONE (INT)
    void
    tag_removed(self,const int id)
    {
    }
    
    /**
     * Schema's
     */
    public
    StuffKeeperDataSchema*
    get_schema(self, const int id)
    {
        gint *ide;
        StuffKeeperDataSchema *schema;
        /* Look for existing tag */
        schema = g_hash_table_lookup(self->_priv->schemas, &id);
        if(schema)
        {
            return schema;
        }
        /* No tag, lets make one. */
        gchar *path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path, "schemas", NULL);
        schema = stuffkeeper_data_schema_new_with_id(path,id);
        g_free(path);

        /* Add to the list */
        ide = g_malloc0(sizeof(gint));
        *ide = id;
        g_hash_table_insert(self->_priv->schemas,ide, schema);

        self_schema_added(self, schema);
        return schema;
    }
    public
        GList *
        get_schemas(self)
        {
            return g_hash_table_get_values(self->_priv->schemas);
        }

    public
        StuffKeeperDataSchema *
        new_schema(self)
    {
        gint *ide;
        gint id = g_random_int();
        StuffKeeperDataSchema *schema;

        while((schema = g_hash_table_lookup(self->_priv->schemas, &id)) != NULL)
        {
            id = g_random_int();
        }

        /* No schema, lets make one. */
        gchar *path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path, "schemas", NULL);
        schema = stuffkeeper_data_schema_new_with_id(path,id);
        g_free(path);

        /* Add to the list */
        ide = g_malloc0(sizeof(gint));
        *ide = id;
        g_hash_table_insert(self->_priv->schemas,ide, schema);

        self_schema_added(self, schema);
        return schema;
    }
    public
        void
        remove_schema(self, gint id)
        {
            StuffKeeperDataSchema *schema = self_get_schema(self, id);
            if(!schema) return;
            if(stuffkeeper_data_schema_num_items(schema) >0)
            {
                return;
            }
            self_schema_removed(self,id);
            if(schema)
            {
                stuffkeeper_data_schema_delete_yourself(schema); 
            }

            if(g_hash_table_remove(self->_priv->schemas, &id) == FALSE)
            {
                return;
            }
        }

    /**
     * TAGS
     */

   /**
     * Add tag
     * Call this from the item when adding a tag, it will return the tag.
     * Existing tag if it allready exists
     */
    public
    StuffKeeperDataTag *
    add_tag(self, const int id)
    {
        gint *ide;
        StuffKeeperDataTag *tag;
        /* Look for existing tag */
        tag = g_hash_table_lookup(self->_priv->tags, &id);
        if(tag)
        {
            return tag;
        }
        /* No tag, lets make one. */
        gchar *path = g_build_path(G_DIR_SEPARATOR_S, self->_priv->path, "tags", NULL);
        tag = stuffkeeper_data_tag_new_with_id(path,id);
        g_free(path);

        /* Add to the list */
        ide = g_malloc0(sizeof(gint));
        *ide = id;
        g_hash_table_insert(self->_priv->tags,ide, tag);

        self_tag_added(self, tag);
        return tag;
    }

    public
        StuffKeeperDataTag *
    get_tag(self, const int id)
    {
        StuffKeeperDataTag *tag;
        /* Look for existing tag */
        tag = g_hash_table_lookup(self->_priv->tags, &id);
        return tag;
    }
    public
    StuffKeeperDataTag *
    new_tag(self)
    {
         gint id = g_random_int();
         /* Check if the random id is allready available */
         while(self_get_tag(self, id) != NULL)
         {
             id = g_random_int();
         }
        /* We have a valid id now, so add it */
        return self_add_tag(self, id);
    }

    public
    GList *
    get_tags(self)
    {
        return g_hash_table_get_values(self->_priv->tags);
    }

    public
    void
    remove_tag(self, gint id)
    {
        StuffKeeperDataTag *tag = self_get_tag(self, id);
        if(!tag) return;
        if(stuffkeeper_data_tag_num_items(tag) >0)
        {
            return;
        }
        self_tag_removed(self,id);
        if(tag)
        {
            stuffkeeper_data_tag_delete_yourself(tag); 
        }

        if(g_hash_table_remove(self->_priv->tags, &id) == FALSE)
        {
            return;
        }

    }

    public
    gchar *
    get_path(self)
    {
        return self->_priv->path;
    }
}
