requires 2.0.10

%h{
    #include "stuffkeeper-data-item.h"
%}
%header{
    #include <stdio.h>
%}


class StuffKeeper:Data:Backend from G:Object 
{
    private GHashTable *items = {g_hash_table_new_full(g_int_hash, g_int_equal,g_free, g_object_unref)} ;

    /**
     * Signal 
     */
    signal last NONE (POINTER)
    void
    item_changed(self, StuffKeeperDataItem *item)
    {
        printf("Item changed\n");
    }

    signal last NONE (POINTER)
    void
    item_added(self, StuffKeeperDataItem *item)
    {
        printf("Item added signal: '%i'\n", stuffkeeper_data_item_get_id(item));
        g_signal_connect_swapped(G_OBJECT(item), "item-changed", G_CALLBACK(self_item_changed), self);

    }
    signal last NONE (INT)
        void
    item_removed(self, gint id)
    {
        printf("Item removed signal: '%i'\n",id); 
    }

    /**
     * Public functions 
     */
    public 
    StuffKeeperDataItem *
    get_item(self, gint id)
    {
        StuffKeeperDataItem *item;
        item = g_hash_table_lookup(self->_priv->items, &id);
        return item;
    }

    public 
    StuffKeeperDataItem *
    new_item(self)
    {
        gint *id;
        StuffKeeperDataItem *item;
        /* create a new item */
        item = stuffkeeper_data_item_new("/home/qball/.stuffkeeper/items/");
        /* want to copy the key, even if it is an integer */
        id = g_malloc0(sizeof(gint));
        *id = stuffkeeper_data_item_get_id(item);
        /* insert it into my hash-list */
        g_hash_table_insert(self->_priv->items,id, item);
        self_item_added(self, item);

        return item;
    }

    public 
    void
    remove_item(self, gint id)
    {
        StuffKeeperDataItem *item = g_hash_table_lookup(self->_priv->items, &id);
        if(item)
        {
            stuffkeeper_data_item_delete_yourself(item); 
        }
        if(g_hash_table_remove(self->_priv->items, &id) == FALSE)
        {
            printf("failed to remove: %i\n", id);
            return;
        }
        self_item_removed(self, id);
    }

    /* Load the data */
    public
    void
    load(self)
    {
        StuffKeeperDataItem *item;
        printf("Loading content\n");

        /* Load schema's */
        GDir *dir = g_dir_open("/home/qball/.stuffkeeper/items", 0, NULL);
        if(dir)
        {
            gchar *filename;
            while((filename = g_dir_read_name(dir))!= NULL)
            {
                gchar *full_path = g_strdup_printf("/home/qball/.stuffkeeper/items/%s", filename);
                StuffKeeperDataItem *item;
                gint *id;
                /* create a new item */
                item = stuffkeeper_data_item_new_from_file(full_path);
                /* want to copy the key, even if it is an integer */
                id = g_malloc0(sizeof(gint));
                *id = stuffkeeper_data_item_get_id(item);
                /* insert it into my hash-list */
                g_hash_table_insert(self->_priv->items,id, item);
                self_item_added(self, item);

                g_free(full_path);
            }
            g_dir_close(dir);
        }
        /* Load items */
    }

    private
    void
    finalize_item(gint *key, StuffKeeperDataItem *item, gpointer user_data)
    {
        stuffkeeper_data_item_save_yourself(item);
    }


    override (G:Object)
    void
    finalize (G:Object *obj)
    {
        Self *self = SELF(obj);
        printf("destroying\n");

        if(self->_priv->items)
        {
            g_hash_table_foreach(self->_priv->items, (GHFunc)self_finalize_item, NULL);
            g_hash_table_destroy(self->_priv->items);

            self->_priv->items = NULL;
        }

            PARENT_HANDLER(obj);
    }


    /* Create new StuffKeeperDataBackend */
    public 
        StuffKeeperDataBackend *
        new (void)
        {
            printf("Creating backend\n");
            return GET_NEW;
        }
}
