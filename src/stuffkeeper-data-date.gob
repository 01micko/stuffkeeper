requires 2.0.10

%h{
#include <gtk/gtk.h>
#include "egg-datetime.h"
#include "stuffkeeper-data-item.h"
%}

%ph{
#include "stuffkeeper-data-backend.h"
%}

class StuffKeeper:Data:Date from Egg:DateTime 
{
    private StuffKeeperDataItem *item = {NULL};
    private gchar *field = {NULL} destroywith g_free;
    private gulong changed_item_entry = {0};
    private gulong changed_date = {0};
    private gulong changed_time= {0};

    /* lock signal */
    private gulong signal_backend_locked = {0};

    public
    void
    changed(self, gpointer data)
    {
        time_t old_value = 0;
        egg_datetime_get_as_time_t(EGG_DATETIME(self),&old_value);
        if(self->_priv->field)
        {
           stuffkeeper_data_item_set_integer(self->_priv->item, self->_priv->field, old_value);
        }
    }

    public
    void
    item_changed(self,const gchar *field, StuffKeeperDataItem *item)
    {
        time_t old_value =0;
        time_t value = 0; 
        egg_datetime_get_as_time_t(EGG_DATETIME(self),&old_value);
        if(self->_priv->field)
        {
            if(field && strcmp(field, self->_priv->field) == 0)
            {
                value = stuffkeeper_data_item_get_integer(item, self->_priv->field);
            }
            if(value)
            {

                if(value != old_value)
                {
                    g_signal_handler_block(self,self->_priv->changed_date);
                    g_signal_handler_block(self,self->_priv->changed_time);
                    egg_datetime_set_from_time_t(EGG_DATETIME(self), value);
                    g_signal_handler_unblock(self,self->_priv->changed_date);
                    g_signal_handler_unblock(self,self->_priv->changed_time);
                }
            }
        }
    }
    private
        void
    backend_locked(self, GParamSpec *arg1, StuffKeeperDataBackend *backend)
    {
        gboolean locked = stuffkeeper_data_backend_get_locked(backend);
        gtk_widget_set_sensitive(GTK_WIDGET(self), !locked);
    }
    public
    GtkWidget *
    new(StuffKeeperDataItem *item, const gchar *field)
    {
        Self *obj = GET_NEW;
        time_t value = 0; 

        /* store item */
        obj->_priv->item = item; 
        /* field */
        obj->_priv->field = g_strdup(field);
           
        egg_datetime_set_lazy(EGG_DATETIME(obj), TRUE);

        /* update the entry */
        if(obj->_priv->field)
        {
            value = (time_t) stuffkeeper_data_item_get_integer(item, obj->_priv->field);
        }
        if(value)
        {
                egg_datetime_set_from_time_t(EGG_DATETIME(obj), value);
        }
        else 
        {
            value = time(NULL);
            stuffkeeper_data_item_set_integer(obj->_priv->item, obj->_priv->field, value);
            egg_datetime_set_from_time_t(EGG_DATETIME(obj), value);
        }

        obj->_priv->changed_item_entry = g_signal_connect_swapped(G_OBJECT(item), "item-changed", G_CALLBACK(self_item_changed), obj);
        /* this is destroyed when self is destroyed, so no need to disconnect myself */
        obj->_priv->changed_date = g_signal_connect(G_OBJECT(obj), "date-changed", G_CALLBACK(self_changed), NULL);
        obj->_priv->changed_time = g_signal_connect(G_OBJECT(obj), "time-changed", G_CALLBACK(self_changed), NULL);

        obj->_priv->signal_backend_locked = g_signal_connect_swapped(G_OBJECT(stuffkeeper_data_item_get_backend(item)), 
                                                                     "notify::locked", G_CALLBACK(self_backend_locked), obj);
        self_backend_locked(obj,NULL, stuffkeeper_data_item_get_backend(item));



        return GTK_WIDGET(obj);
    }

    override (G:Object)
        void
        finalize (G:Object *obj)
        {
            Self *self = SELF(obj);
            if(self->_priv->changed_item_entry)
            {
                g_signal_handler_disconnect(self->_priv->item,self->_priv->changed_item_entry);
                self->_priv->changed_item_entry = 0;
            }
            if(self->_priv->signal_backend_locked) {                                                                     
                g_signal_handler_disconnect(G_OBJECT(stuffkeeper_data_item_get_backend(self->_priv->item)), self->_priv->signal_backend_locked);
                self->_priv->signal_backend_locked = 0;
            }

            PARENT_HANDLER(obj);
        }

}
