requires 2.0.10

%h{
/* Include gtk */
#include <gtk/gtk.h>
#include <glib/gi18n.h>
#include <glade/glade.h>
#include "config.h"
#include "debug.h"
/* Include the database */

#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-data-schema.h"
#include "stuffkeeper-data-label.h"
#include "stuffkeeper-data-entry.h"
#include "stuffkeeper-data-boolean.h"
#include "stuffkeeper-data-spinbutton.h"
#include "stuffkeeper-data-rating.h"
extern GList *interface_list;
%}
%ph{
    typedef enum _StoreFields
    {  
        COL_ID,
        COL_TYPE,
        COL_NAME,
        COL_TYPE_NAME,
        COL_IN_TITLE,
        COL_NAME_EDITABLE,
        COL_TYPE_EDITABLE,
        NUM_ROWS
    }StoreFields;
%}

class StuffKeeper:Edit:Schema from G:Object 
{
    private StuffKeeper:Data:Schema *schema = {NULL};
    private GtkListStore *store = {gtk_list_store_new(NUM_ROWS,G_TYPE_STRING, G_TYPE_INT,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_BOOLEAN,G_TYPE_BOOLEAN)}  destroywith g_object_unref;

    private GladeXML *xml;
    private GtkWidget *tree;
    private GtkWidget *win;
    private GtkWidget *preview_box;

    private guint changed_signal = 0;
    private guint field_changed_signal = 0;
    private guint field_added_signal = 0;
    private guint field_removed_signal = 0;
    private guint fields_reordered_signal = 0;

    private guint model_changed_signal = 0;
    private guint model_added_signal = 0;
    private guint model_removed_signal = 0;

    private
    void
    schema_changed(self, StuffKeeperDataSchema *schema)
    {
        GtkWidget *label = glade_xml_get_widget(self->_priv->xml, "title_label");
        GtkWidget *image = glade_xml_get_widget(self->_priv->xml, "type_image");
        GdkPixbuf *pixbuf = stuffkeeper_data_schema_get_pixbuf(schema);
        /**
         * update title
         */
        gchar *temp;
        temp = stuffkeeper_data_schema_get_title(schema);
        if(temp)
        {
            gchar *str = g_markup_printf_escaped("<span size='large' weight='bold'>%s: '%s'</span>",_("Edit type"), temp);
            gtk_label_set_markup(GTK_LABEL(label),str);
            g_free(str);
            g_free(temp);
        }

        if(pixbuf)
        {
            gtk_image_set_from_pixbuf(GTK_IMAGE(image), pixbuf);
        }
    }

    private
    void
    schema_field_changed(self, const gchar *field, StuffKeeperDataSchema *schema)
    {
        GtkTreeIter iter;

        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
        if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
        {
            do{
                gchar *id;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                if(strcmp(id, field) ==0)
                {

                    int type = stuffkeeper_data_schema_get_field_type(schema, id);
                    gchar *name = stuffkeeper_data_schema_get_field_name(schema, id);
                    gboolean in_title = (gboolean)  stuffkeeper_data_schema_get_field_in_title(schema, id);
                    gboolean editable = TRUE;
                    gboolean type_editable = TRUE;
                    if(type == FIELD_TYPE_END_EXPANDER ||  type == FIELD_TYPE_VPACKING || type == FIELD_TYPE_HPACKING || type == FIELD_TYPE_END_PACKING)
                    {
                        editable = FALSE;
                        type_editable = FALSE;
                    }
                    if (type == FIELD_TYPE_EXPANDER) type_editable = FALSE;




                    gtk_list_store_set(self->_priv->store, &iter, 
                            COL_NAME, name,
                            COL_TYPE, type,
                            COL_TYPE_NAME, FieldNames[type],
                            COL_NAME_EDITABLE, editable,
                            COL_IN_TITLE, in_title,
                            COL_TYPE_EDITABLE, type_editable,
                            -1);
                    g_free(name);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    private
    void
    schema_field_removed(self, const gchar *removed_id, StuffKeeper:Data:Schema *schema)
    {
        GtkTreeIter iter;
        
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
        debug_printf("removing field from list\n");
        if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
        {
            do{
                gchar *id;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                if(strcmp(id, removed_id) ==0)
                {
                    gtk_list_store_remove(self->_priv->store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    private
        void
        schema_field_added(self, const gchar *id, StuffKeeperDataSchema *schema)
        {

            GtkTreeIter iter;
            gchar *name;
            int type = stuffkeeper_data_schema_get_field_type(schema, id);
            gboolean editable = TRUE, type_editable =TRUE;
            gboolean in_title = (gboolean)  stuffkeeper_data_schema_get_field_in_title(schema, id);
            gtk_list_store_append(self->_priv->store, &iter);
            name = stuffkeeper_data_schema_get_field_name(schema, id);
            if(type == FIELD_TYPE_END_EXPANDER ||  type == FIELD_TYPE_VPACKING || type == FIELD_TYPE_HPACKING || type == FIELD_TYPE_END_PACKING)
            {
                editable = FALSE;
                type_editable = FALSE;
            }
            if (type == FIELD_TYPE_EXPANDER) type_editable = FALSE;

            gtk_list_store_set(self->_priv->store, &iter, 
                    COL_ID, id, 
                    COL_TYPE, type ,
                    COL_NAME, name,
                    COL_TYPE_NAME, FieldNames[type],
                    COL_IN_TITLE, in_title,
                    COL_NAME_EDITABLE, editable,
                    COL_TYPE_EDITABLE, type_editable,
                    -1);
            g_free(name);
        }
        private
        void
        schema_fields_reordered(self, StuffKeeperDataSchema *schema)
        {
            gsize length;
            int i =0;
            char **ids  = stuffkeeper_data_schema_get_fields(schema, &length);
            gtk_list_store_clear(self->_priv->store);
            for(i=0;i<length;i++)
            {
                self_schema_field_added(self, ids[i], schema); 

            }
        }

        private
        void interface_field_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeIter iter;
            GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
            debug_printf("new: %s\n", new_text);
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gchar *id;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
                stuffkeeper_data_schema_set_field_name(self->_priv->schema, id,new_text);
                stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
                g_free(id);


            }
        }
    private
        void interface_type_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeIter iter;
            GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
            debug_printf("new: %s\n", new_text);
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                int type;
                gchar *id = NULL;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                for(type=0;strcmp(new_text,FieldNames[type]) && type < FIELD_TYPE_NUM_FIELDS;type++);
                /* somehow type is not found default to string */
                if(type == FIELD_TYPE_NUM_FIELDS) type = FIELD_TYPE_STRING; 
                stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
                stuffkeeper_data_schema_set_field_type(self->_priv->schema,id, type);
                stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
                g_free(id);
            }
        }
    private
    void
    interface_in_title_toggled(self, gchar *path, GtkCellRendererToggle *renderer)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
        if(gtk_tree_model_get_iter_from_string(model, &iter, path))
        {
            int active = !gtk_cell_renderer_toggle_get_active(renderer);
            gchar *id = NULL;
            gtk_tree_model_get(model, &iter, COL_ID, &id, -1);

            /* somehow type is not found default to string */
            stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
            stuffkeeper_data_schema_set_field_in_title(self->_priv->schema,id, active);
            stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
            g_free(id);
        }
    }

    private
    void
    style_set(self, GtkStyle *style, GtkWidget *win)
    {
      gtk_widget_modify_bg(glade_xml_get_widget(self->_priv->xml, "eventbox"), 
            GTK_STATE_NORMAL, 
            &((self->_priv->win)->style->bg[GTK_STATE_SELECTED]));
      gtk_widget_modify_text(glade_xml_get_widget(self->_priv->xml, "title_label"), 
            GTK_STATE_NORMAL, 
            &((self->_priv->win)->style->text[GTK_STATE_SELECTED]));
      gtk_widget_modify_fg(glade_xml_get_widget(self->_priv->xml, "title_label"), 
            GTK_STATE_NORMAL, 
            &((self->_priv->win)->style->fg[GTK_STATE_SELECTED]));

    }
    public
    gboolean
    type_image_clicked(self, GdkEventButton *button, GtkWidget *event)
    {
        if(self->_priv->schema)
        {
            GtkWidget *dialog = gtk_file_chooser_dialog_new(_("Pick an icon"), 
                    NULL, 
                    GTK_FILE_CHOOSER_ACTION_OPEN,
                    GTK_STOCK_CLEAR, GTK_RESPONSE_NO,
                    GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                    GTK_STOCK_OPEN, GTK_RESPONSE_OK, 
                    NULL);
            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case GTK_RESPONSE_NO:
                    stuffkeeper_data_schema_set_icon(self->_priv->schema,NULL);
                    break;
                case GTK_RESPONSE_OK:
                    {
                        gchar *file = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
                        if(file)
                        {
                            stuffkeeper_data_schema_set_icon(self->_priv->schema,file);
                            g_free(file);
                        }
                    }
                default:
                    break;
            }
            gtk_widget_destroy(dialog);




        }
        debug_printf("clicked\n");
        return FALSE;
    }

    private
    void
    reload_preview_del(self,  GtkTreePath *path, GtkTreeModel *model)
    {
        self_reload_preview(self);
    }

    private
    void
    reload_preview_ins(self,  GtkTreePath *path,GtkTreeIter *iter, GtkTreeModel *model)
    {
        self_reload_preview(self);
    }
    private
    void
    reload_preview(self)
    {
        GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
        GList *node, *list = gtk_container_get_children(GTK_CONTAINER(self->_priv->preview_box));
        GQueue *queue = g_queue_new();
        GtkTreeIter iter;
        GtkWidget *label;
        gint depth = 0;
        /* removing old widgets */
        for(node =list; node; node = g_list_next(node)) {
            gtk_widget_destroy(GTK_WIDGET(node->data));
        }
        g_list_free(list);

        gtk_container_add(GTK_CONTAINER(self->_priv->preview_box), vbox);
        label = gtk_label_new("");
        gtk_label_set_markup(GTK_LABEL(label), "<span size='x-large'>Preview layout</span>");
        gtk_misc_set_alignment(GTK_MISC(label), 0,0.0);
        gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, TRUE, 0);
        gtk_misc_set_padding(GTK_MISC(label), 0,6);

        g_queue_push_head(queue, vbox);
        if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
        {
            do{
                GtkWidget *vbox = g_queue_peek_head(queue);
                FieldType type;
                gchar *name;
                GdkColor color;
                gtk_tree_model_get(GTK_TREE_MODEL(self->_priv->store), &iter,COL_TYPE ,&type, COL_NAME, &name, -1);


                if (type == FIELD_TYPE_VPACKING) {

                    GtkWidget *box = gtk_vbox_new(FALSE, 6);
                    GtkWidget *event = gtk_event_box_new();
                    gtk_container_add(GTK_CONTAINER(event), box);
                    gtk_container_set_border_width(GTK_CONTAINER(event), 6);
                    g_queue_push_head(queue, box);
                    gtk_box_pack_start(GTK_BOX(vbox), event, FALSE, TRUE, 0);
                    vbox = box;

                    color.red   = ((depth%3) == 0)?65535:256*128;
                    color.blue  = ((depth%3) == 1)?65535:256*128;
                    color.green = ((depth%3) == 2)?65535:256*128;
                    gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &color);
                    depth++;
                } else if (type == FIELD_TYPE_HPACKING) {
                    GtkWidget *event = gtk_event_box_new();
                    GtkWidget *box = gtk_hbox_new(TRUE, 6);
                    gtk_container_add(GTK_CONTAINER(event), box);
                    gtk_container_set_border_width(GTK_CONTAINER(event), 6);
                    g_queue_push_head(queue, box);
                    gtk_box_pack_start(GTK_BOX(vbox), event, FALSE, TRUE, 0);
                    vbox = box;
                    color.red   = ((depth%3) == 0)?65535:256*128;
                    color.blue  = ((depth%3) == 1)?65535:256*128;
                    color.green = ((depth%3) == 2)?65535:256*128;
                    gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &color);

                    depth++;
                } else if (type == FIELD_TYPE_EXPANDER) {
                    GtkWidget *expander = gtk_expander_new(name);
                    GtkWidget *event = gtk_event_box_new(); 
                    GtkWidget *box = gtk_vbox_new(TRUE, 6);
                    gtk_container_add(GTK_CONTAINER(event), box);
                    gtk_container_set_border_width(GTK_CONTAINER(event), 6);
                    g_queue_push_head(queue, box);
                    gtk_container_add(GTK_CONTAINER(expander), event);
                    gtk_box_pack_start(GTK_BOX(vbox), expander, FALSE, TRUE, 0);
                    vbox = box;
                    color.red   = ((depth%3) == 0)?65535:256*128;
                    color.blue  = ((depth%3) == 1)?65535:256*128;
                    color.green = ((depth%3) == 2)?65535:256*128;
                    gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &color);
                    gtk_expander_set_expanded(GTK_EXPANDER(expander), TRUE);
                    depth++;
                } else if (type == FIELD_TYPE_END_PACKING || type == FIELD_TYPE_END_EXPANDER) {
                    if(g_queue_get_length(queue) > 1)
                        g_queue_pop_head(queue);
                    else
                        printf("Popped one to many\n");
                    depth--;
                }
                else
                {
                    GtkWidget *event = gtk_event_box_new(); 
                    GtkWidget *label = gtk_label_new(name);
                    gtk_misc_set_alignment(GTK_MISC(label), 0,0.0);
                    gtk_misc_set_padding(GTK_MISC(label), 6,6);
                    gtk_label_set_ellipsize(GTK_LABEL(label), PANGO_ELLIPSIZE_END);
                    color.red   = ((depth%3) == 0)?65535:256*128;
                    color.blue  = ((depth%3) == 1)?65535:256*128;
                    color.green = ((depth%3) == 2)?65535:256*128;
                    gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &color);
                    gtk_container_add(GTK_CONTAINER(event), label);
                    gtk_container_set_border_width(GTK_CONTAINER(event), 6);
                    gtk_box_pack_start(GTK_BOX(vbox), event, FALSE, TRUE, 0);
                }
                g_free(name);
            }while(gtk_tree_model_iter_next(GTK_TREE_MODEL(self->_priv->store), &iter));
        }
        if(depth)
        {
            label = gtk_label_new("");
            gtk_label_set_markup(GTK_LABEL(label), "<span size='large'>Missing ending padding/expander</span>");
            gtk_misc_set_alignment(GTK_MISC(label), 0,0.0);
            gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, TRUE, 0);
            gtk_misc_set_padding(GTK_MISC(label), 0,6);
        }
        g_queue_free(queue);
        gtk_widget_show_all(self->_priv->preview_box);
    }

    /** Create the interface */
    public
        StuffKeeper:Edit:Schema * 
        new(void)
        {
            int i,width,height;
            GtkCellRenderer *renderer;
            Self *self = GET_NEW;
            GError *error = NULL;
            GtkListStore *store = gtk_list_store_new(2, G_TYPE_INT, G_TYPE_STRING);
            self->_priv->xml = glade_xml_new(PACKAGE_DATADIR"/stuffkeeper.glade","edit_schema_dialog",NULL);
            if(self->_priv->xml == NULL)
            {
                g_object_unref(self);
                debug_printf("Failed top open xml file\n");
                return NULL;
            }
            self->_priv->tree = glade_xml_get_widget(self->_priv->xml, "tree");
            self->_priv->win = glade_xml_get_widget(self->_priv->xml, "edit_schema_dialog");

            self->_priv->preview_box = gtk_frame_new(NULL);
           gtk_paned_add2(GTK_PANED(glade_xml_get_widget(self->_priv->xml, "hpaned2")),
                    self->_priv->preview_box);




            for(i=0; i <FIELD_TYPE_EXPANDER;i++)
            {
                GtkTreeIter iter;
                gtk_list_store_append(store,&iter);
                gtk_list_store_set(store, &iter, 0, i, 1,FieldNames[i], -1); 
            }

            g_signal_connect_swapped(G_OBJECT(self->_priv->win), "style-set", G_CALLBACK(self_style_set), self);
      


            /* fill tree with columns */
            renderer = gtk_cell_renderer_combo_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->tree),-1,"Type", renderer, "text", COL_TYPE_NAME, "editable", COL_TYPE_EDITABLE,NULL);
            g_object_set(G_OBJECT(renderer), "model", GTK_TREE_MODEL(store), NULL);
            g_object_set(G_OBJECT(renderer), "text-column", 1,"has-entry", FALSE, NULL);
//            g_object_set(G_OBJECT(renderer), "editable", TRUE, NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_type_edited), self);
            gtk_tree_view_column_set_expand(gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->tree), 0), TRUE);



            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->tree),-1,"Name", renderer, "text", COL_NAME,"editable", COL_NAME_EDITABLE, NULL);
            g_object_set(G_OBJECT(renderer), "editable", TRUE, NULL);
//            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_field_edited), self);
            gtk_tree_view_column_set_expand(gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->tree), 1), TRUE);

            renderer = gtk_cell_renderer_toggle_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->tree),-1,"In title", renderer, "active", COL_IN_TITLE, NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "toggled", G_CALLBACK(self_interface_in_title_toggled), self);
            gtk_tree_view_column_set_expand(gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->tree), 2), FALSE);

            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->tree), GTK_TREE_MODEL(self->_priv->store));


            width = g_key_file_get_integer(config_file, "EDIT_SCHEMA_WINDOW", "width", &error);
            if(error) {
                g_error_free(error);
                error = NULL;
            } else {
                height = g_key_file_get_integer(config_file, "EDIT_SCHEMA_WINDOW", "height", &error);
                if(error) {
                    g_error_free(error);
                    error = NULL;
                } else {
                    gtk_window_resize(GTK_WINDOW(self->_priv->win), width, height);
                }
            }

            glade_xml_signal_autoconnect_full(self->_priv->xml, (GladeXMLConnectFunc)self____glade_xml_connect_foreach, (gpointer)self);
            gtk_widget_show_all(GTK_WIDGET(self->_priv->win));

            return self;
        }

    private
    void
        ___glade_xml_connect_foreach(const gchar *handler_name,
                GObject *object,
                const gchar *signal_name,
                const gchar *signal_data,
                GObject *connect_object,
                gboolean after,
                gpointer user_data)
        {
            static GModule * allsymbols = NULL;

            if (!allsymbols) allsymbols = g_module_open(NULL, 0);
            if (allsymbols) {
                gchar * func_name = g_strdup_printf("stuffkeeper_edit_schema_%s", handler_name);
                GCallback func;

                if (!g_module_symbol(allsymbols, func_name, (gpointer)&func)){
                    if (!g_module_symbol(allsymbols, handler_name, (gpointer)&func)) {
                        g_warning("could not find signal handler '%s'.", func_name);
                        g_free(func_name);
                        return;
                    }
                }
                if (after)
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_AFTER | G_CONNECT_SWAPPED);
                else
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_SWAPPED);
                g_free(func_name);
            }
        }

    private
    void
    apply_order(self)
    {
        int length = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(self->_priv->store), NULL);
        if(length)
        {
            int i=0;
            GtkTreeIter iter;
            char **retv = g_malloc0((length+1)*sizeof(char *));
            if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
            {
                do{
                    gchar *id;
                    gtk_tree_model_get(GTK_TREE_MODEL(self->_priv->store), &iter, COL_ID, &id, -1);
                    retv[i] = id;
                    i++;
                }while(gtk_tree_model_iter_next(GTK_TREE_MODEL(self->_priv->store), &iter));
            }
            stuffkeeper_data_schema_field_reorder(self->_priv->schema, retv);
            g_strfreev(retv);
        }
    }
    public
    void
    reorder_apply(self)
    {
        if(self->_priv->fields_reordered_signal)
            g_signal_handler_block(self->_priv->schema,self->_priv->fields_reordered_signal);
        self_apply_order(self);
        if(self->_priv->fields_reordered_signal)
            g_signal_handler_unblock(self->_priv->schema,self->_priv->fields_reordered_signal);
        self_reload_preview(self);
    }

    public
        void
        close(self)
        {
            int value;
            gtk_window_get_size(GTK_WINDOW(self->_priv->win), &value, NULL);
            g_key_file_set_integer(config_file, "EDIT_SCHEMA_WINDOW", "width", value);
            gtk_window_get_size(GTK_WINDOW(self->_priv->win), NULL, &value);
            g_key_file_set_integer(config_file, "EDIT_SCHEMA_WINDOW", "height", value);

            self_apply_order(self);
            gtk_widget_destroy(GTK_WIDGET(self->_priv->win));
            g_object_unref(self->_priv->xml);
            g_object_unref(self);
        }
    public
    void
    add_expander(self)
    {
        stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_EXPANDER, "New Field",FALSE);
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_END_EXPANDER, "",FALSE);
        stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
    }
    public
    void
    add_vpadding(self)
    {
        stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_VPACKING, "",FALSE);
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_END_PACKING, "",FALSE);
        stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
    }
    public
    void
    add_hpadding(self)
    {
        stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_HPACKING, "",FALSE);
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_END_PACKING, "",FALSE);
        stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
    }
    public
        void
        add_field(self)
        {
            stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
            stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_STRING, "New Field",FALSE);
            stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
        }

   public
   void
   remove_field(self)
   {
       GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(self->_priv->win),
                        GTK_DIALOG_DESTROY_WITH_PARENT|GTK_DIALOG_MODAL,
                        GTK_MESSAGE_WARNING,GTK_BUTTONS_YES_NO,
                        "This will delete the field, and all data it contains in the related items.\nAre you sure you want to continue?"); 
       switch(gtk_dialog_run(GTK_DIALOG(dialog)))
       {
            case GTK_RESPONSE_YES:
                gtk_widget_destroy(dialog);
                break;
            default:
                gtk_widget_destroy(dialog);
                return;
       }
       GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
       GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->tree));
        GtkTreeIter iter;
        if(gtk_tree_selection_get_selected(sel, &model, &iter))
        {
            gchar *id;
            int type;
            gtk_tree_model_get(model, &iter,COL_TYPE, &type, COL_ID, &id, -1);

            if(type == FIELD_TYPE_EXPANDER || type == FIELD_TYPE_VPACKING || type == FIELD_TYPE_HPACKING)
            {
                int type_expect = (type == FIELD_TYPE_EXPANDER)? FIELD_TYPE_END_EXPANDER:FIELD_TYPE_END_PACKING;
                do{
                    int type2;
                    gchar *id2;
                    gtk_tree_model_get(model, &iter,COL_ID, &id2,COL_TYPE, &type2,  -1);
                    if(type2 == type_expect) 
                    {
                        stuffkeeper_data_schema_remove_field(self->_priv->schema, id);
                        stuffkeeper_data_schema_remove_field(self->_priv->schema, id2);
                        g_free(id);
                        g_free(id2);
                        return;
                    }

                    g_free(id2);
                }while(gtk_tree_model_iter_next(model, &iter));

            }
            stuffkeeper_data_schema_remove_field(self->_priv->schema, id);
            g_free(id);
        }
   }
    
    public
    void
    set_schema(self, StuffKeeper:Data:Schema *schema)
    {
        if(self->_priv->schema != NULL)
        {
            debug_printf("Allready have a schema attaches\n");
            return;
        }
        self->_priv->schema = schema;
       
        gsize length;
        int i =0;
        char **ids  = stuffkeeper_data_schema_get_fields(schema, &length);
        for(i=0;i<length;i++)
        {
            self_schema_field_added(self, ids[i], schema); 

        }

        self->_priv->changed_signal = g_signal_connect_swapped(G_OBJECT(schema),  
                            "schema-changed",
                            G_CALLBACK(self_schema_changed),
                            self);
        self->_priv->field_changed_signal = g_signal_connect_swapped(G_OBJECT(schema),  
                            "schema-field-changed",
                            G_CALLBACK(self_schema_field_changed),
                            self);
        self->_priv->field_added_signal =   g_signal_connect_swapped(G_OBJECT(schema),  
                            "schema-field-added",
                            G_CALLBACK(self_schema_field_added),
                            self);
        self->_priv->field_removed_signal = g_signal_connect_swapped(G_OBJECT(schema),
                            "schema-field-removed",
                            G_CALLBACK(self_schema_field_removed),
                            self);
        self->_priv->fields_reordered_signal = g_signal_connect_swapped(G_OBJECT(schema),
                            "schema-fields-reordered",

                            G_CALLBACK(self_schema_fields_reordered),
                            self);
        self_schema_changed(self, schema);
        self->_priv->model_removed_signal = g_signal_connect_swapped(G_OBJECT(self->_priv->store), "row-deleted", G_CALLBACK(self_reload_preview_del), self);
        self->_priv->model_added_signal =  g_signal_connect_swapped(G_OBJECT(self->_priv->store), "row-inserted", G_CALLBACK(self_reload_preview_ins), self);
        self->_priv->model_changed_signal = g_signal_connect_swapped(G_OBJECT(self->_priv->store), "row-changed", G_CALLBACK(self_reload_preview_ins), self);
        self_reload_preview(self); 
        
    }

    override (G:Object)
    void
    finalize(G:Object *obj)
    {
        Self *self = SELF(obj);
        debug_printf("** Finalize edit schema\n");
        if(self->_priv->changed_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->changed_signal);
            self->_priv->changed_signal =0;
        }
/*        if(self->_priv->preview_box)
        {
            gtk_widget_destroy(self->_priv->preview_box);
            self->_priv->preview_box  = NULL;
        }

*/
        if(self->_priv->model_changed_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->store), self->_priv->model_changed_signal);
            self->_priv->model_changed_signal =0;
        }
        if(self->_priv->model_added_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->store), self->_priv->model_added_signal);
            self->_priv->model_added_signal =0;
        }
        if(self->_priv->model_removed_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->store), self->_priv->model_removed_signal);
            self->_priv->model_removed_signal =0;
        }


        if(self->_priv->field_changed_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->field_changed_signal);
            self->_priv->field_changed_signal =0;
        }
        if(self->_priv->field_added_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->field_added_signal);
            self->_priv->field_added_signal =0;
        }
        if(self->_priv->field_removed_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->field_removed_signal);
            self->_priv->field_removed_signal =0;
        }
        if(self->_priv->fields_reordered_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->fields_reordered_signal);
            self->_priv->fields_reordered_signal =0;
        }
        PARENT_HANDLER(obj);
    }
}
