requires 2.0.10

%h{
/* Include gtk */
#include <gtk/gtk.h>
#include <glib/gi18n.h>
#include <glade/glade.h>
#include "config.h"
#include "debug.h"
/* Include the database */

#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-data-schema.h"
#include "stuffkeeper-data-label.h"
#include "stuffkeeper-data-entry.h"
#include "stuffkeeper-data-boolean.h"
#include "stuffkeeper-data-spinbutton.h"
#include "stuffkeeper-data-rating.h"

#include "stuffkeeper-data-entry-config.h"
#include "stuffkeeper-data-spinbutton-config.h"
#include "stuffkeeper-data-boolean-config.h"
#include "stuffkeeper-data-rating-config.h"
#include "stuffkeeper-data-password-config.h"
#include "stuffkeeper-data-image-config.h"
%}
%ph{
    typedef enum _StoreFields
    {  
        COL_ID,
        COL_TYPE,
        COL_NAME,
        COL_TYPE_NAME,
        COL_IN_TITLE,
        COL_NAME_EDITABLE,
        COL_TYPE_EDITABLE,
        COL_TYPE_MODEL,
        NUM_ROWS
    }StoreFields;
%}

class Stuffkeeper:Edit:Schema from G:Object 
{
    private Stuffkeeper:Data:Schema *schema = {NULL};
    private GtkListStore *store = {gtk_list_store_new(NUM_ROWS,G_TYPE_STRING, G_TYPE_INT,G_TYPE_STRING,G_TYPE_STRING,G_TYPE_BOOLEAN,G_TYPE_BOOLEAN,G_TYPE_BOOLEAN,GTK_TYPE_TREE_MODEL)}  destroywith g_object_unref;
    private GtkCellRenderer *renderer_model= NULL;
    private GladeXML *xml;
    private GtkWidget *tree;
    private GtkWidget *win;
    private GtkWidget *preview_box;

    private guint changed_signal = 0;
    private guint field_changed_signal = 0;
    private guint field_added_signal = 0;
    private guint field_removed_signal = 0;
    private guint fields_reordered_signal = 0;

    private GtkWidget *title_entry = NULL;
    private gulong field_title_entry_changed_signal = 0;
    private guint title_entry_changed_timeout = 0;

    private guint model_changed_signal = 0;
    private guint model_added_signal = 0;
    private guint model_removed_signal = 0;


    private GtkTreeModel *model_fields = NULL;
    private GtkTreeModel *model_packings = NULL;

    private gboolean title_entry_changed(self)
    {
        const gchar *text = gtk_entry_get_text(GTK_ENTRY(self->_priv->title_entry));
        stuffkeeper_data_schema_set_title(self->_priv->schema, text);
        self->_priv->title_entry_changed_timeout = 0;
        return FALSE;
    }
    private
    void
    title_changed_real(self, gpointer data)
    {
        if(self->_priv->title_entry_changed_timeout)
        {
            g_source_remove(self->_priv->title_entry_changed_timeout);
        }
        self->_priv->title_entry_changed_timeout = g_timeout_add(1000,(GSourceFunc)self_title_entry_changed,self);
/*
        gtk_widget_modify_text(GTK_WIDGET(title_entry), GTK_STATE_NORMAL, &(GTK_WIDGET(self)->style->black));
        gtk_widget_modify_base(GTK_WIDGET(title_entry), GTK_STATE_NORMAL, &(self->_priv->writing));
        */
    }

    private
    void
    schema_changed(self, StuffkeeperDataSchema *schema)
    {
        GtkWidget *label = glade_xml_get_widget(self->_priv->xml, "title_label");
        GtkWidget *image = glade_xml_get_widget(self->_priv->xml, "type_image");
        GdkPixbuf *pixbuf = stuffkeeper_data_schema_get_pixbuf(schema);
        /**
         * update title
         */
        gchar *temp;
        printf("schema changed\n");
        temp = stuffkeeper_data_schema_get_title(schema);

        g_signal_handler_block(self->_priv->title_entry,self->_priv->field_title_entry_changed_signal);
        if(temp)
        {
            gchar *temp_escaped = g_markup_escape_text(temp,-1);
            gchar *str = g_markup_printf_escaped("<span size='large' weight='bold'>%s: '%s'</span>",_("Edit type"), temp_escaped);
            gtk_label_set_markup(GTK_LABEL(label),str);
            g_free(str);
            g_free(temp_escaped);

            gtk_entry_set_text(GTK_ENTRY(self->_priv->title_entry), temp);
            g_free(temp);
        }
        else gtk_entry_set_text(GTK_ENTRY(self->_priv->title_entry), "");
        g_signal_handler_unblock(self->_priv->title_entry,self->_priv->field_title_entry_changed_signal);
        if(pixbuf)
        {
            gtk_image_set_from_pixbuf(GTK_IMAGE(image), pixbuf);
        }
    }

    private
    void
    schema_field_changed(self, const gchar *field, StuffkeeperDataSchema *schema)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
        printf("field changed\n");
        if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
        {
            do{
                gchar *id;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                if(strcmp(id, field) ==0)
                {

                    int type = stuffkeeper_data_schema_get_field_type(schema, id);
                    gchar *name = stuffkeeper_data_schema_get_field_name(schema, id);
                    gboolean in_title = (gboolean)  stuffkeeper_data_schema_get_field_in_title(schema, id);
                    gboolean editable = TRUE;
                    gboolean type_editable = TRUE;
                    if(type == FIELD_TYPE_END_EXPANDER ||  type == FIELD_TYPE_VPACKING || type == FIELD_TYPE_HPACKING || type == FIELD_TYPE_END)
                    {
                        editable = FALSE;
                        if(type == FIELD_TYPE_END_EXPANDER || type == FIELD_TYPE_END)
                            type_editable = FALSE;
                    }
//                    if (type == FIELD_TYPE_EXPANDER) type_editable = FALSE;



                    g_object_set(G_OBJECT(self->_priv->renderer_model), "model", 
                                (type == FIELD_TYPE_VPACKING || type == FIELD_TYPE_HPACKING || type == FIELD_TYPE_EXPANDER)?
														self->_priv->model_packings:self->_priv->model_fields,
                                                        NULL);
                    gtk_list_store_set(self->_priv->store, &iter, 
                            COL_NAME, name,
                            COL_TYPE, type,
                            COL_TYPE_NAME, _(FieldNames[type]),
                            COL_NAME_EDITABLE, editable,
                            COL_IN_TITLE, in_title,
                            COL_TYPE_EDITABLE, type_editable,
                            -1);
/*                            COL_TYPE_MODEL,(type == FIELD_TYPE_VPACKING || type == FIELD_TYPE_HPACKING || type == FIELD_TYPE_EXPANDER)?
														self->_priv->model_packings:self->_priv->model_fields,
														-1);*/
                    g_free(name);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }

				self_update_field_config(self);

    }
    private
    void
    schema_field_removed(self, const gchar *removed_id, Stuffkeeper:Data:Schema *schema)
    {
        GtkTreeIter iter;
        
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
        debug_printf("removing field from list\n");
        if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
        {
            do{
                gchar *id;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                if(strcmp(id, removed_id) ==0)
                {
                    gtk_list_store_remove(self->_priv->store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    private
        void
        schema_field_added(self, const gchar *id, StuffkeeperDataSchema *schema)
        {

            GtkTreeIter iter;
            gchar *name;
            int type = stuffkeeper_data_schema_get_field_type(schema, id);
            gboolean editable = TRUE, type_editable =TRUE;
            gboolean in_title = (gboolean)  stuffkeeper_data_schema_get_field_in_title(schema, id);
            printf("field added\n");
            gtk_list_store_append(self->_priv->store, &iter);
            name = stuffkeeper_data_schema_get_field_name(schema, id);
            if(type == FIELD_TYPE_END_EXPANDER ||  type == FIELD_TYPE_VPACKING || type == FIELD_TYPE_HPACKING || type == FIELD_TYPE_END)
            {
                editable = FALSE;
                if(type == FIELD_TYPE_END_EXPANDER || type == FIELD_TYPE_END)
                    type_editable = FALSE;
            }
//            if (type == FIELD_TYPE_EXPANDER) type_editable = FALSE;

            g_object_set(G_OBJECT(self->_priv->renderer_model), "model", 
                    (type == FIELD_TYPE_VPACKING || type == FIELD_TYPE_HPACKING || type == FIELD_TYPE_EXPANDER)?
                    self->_priv->model_packings:self->_priv->model_fields,
                    NULL);
            gtk_list_store_set(self->_priv->store, &iter, 
                    COL_ID, id, 
                    COL_TYPE, type ,
                    COL_NAME, name,
                    COL_TYPE_NAME, _(FieldNames[type]),
                    COL_IN_TITLE, in_title,
                    COL_NAME_EDITABLE, editable,
                    COL_TYPE_EDITABLE, type_editable,
                    -1);
                    /*COL_TYPE_MODEL,(type == FIELD_TYPE_VPACKING || type == FIELD_TYPE_HPACKING || type == FIELD_TYPE_EXPANDER)?self->_priv->model_packings:self->_priv->model_fields,
                    -1);*/
            g_free(name);
        }
        private
        void
        schema_fields_reordered(self, StuffkeeperDataSchema *schema)
        {
            gsize length;
            int i =0;
            char **ids  = stuffkeeper_data_schema_get_fields(schema, &length);
            gtk_list_store_clear(self->_priv->store);
            for(i=0;i<length;i++)
            {
                self_schema_field_added(self, ids[i], schema); 

            }
        }

        private
        void interface_field_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeIter iter;
            GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
            printf("new: %s\n", new_text);
            debug_printf("new: %s\n", new_text);
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gchar *id;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
                stuffkeeper_data_schema_set_field_name(self->_priv->schema, id,new_text);
                stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
                g_free(id);


            }
        }
    private
        void interface_type_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeIter iter;
            GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
            printf("new type: %s\n", new_text);
            debug_printf("new: %s\n", new_text);
            if(new_text)
            {
                if(gtk_tree_model_get_iter_from_string(model, &iter, path))
                {
                    int type;
                    gchar *id = NULL;
                    gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                    for(type=0;strcmp(new_text,_(FieldNames[type])) && type < FIELD_TYPE_NUM_FIELDS;type++);
                    /* somehow type is not found default to string */
                    if(type == FIELD_TYPE_NUM_FIELDS) type = FIELD_TYPE_STRING; 
                    stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
                    stuffkeeper_data_schema_set_field_type(self->_priv->schema,id, type);
                    stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
                    g_free(id);


                    self_update_field_config(self);
                }
            }
        }
    private
    void
    interface_in_title_toggled(self, gchar *path, GtkCellRendererToggle *renderer)
    {
        GtkTreeIter iter;
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
        if(gtk_tree_model_get_iter_from_string(model, &iter, path))
        {
            int active = !gtk_cell_renderer_toggle_get_active(renderer);
            gchar *id = NULL;
            gtk_tree_model_get(model, &iter, COL_ID, &id, -1);

            /* somehow type is not found default to string */
            stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
            stuffkeeper_data_schema_set_field_in_title(self->_priv->schema,id, active);
            stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
            g_free(id);
        }
    }

    private
    void
    style_set(self, GtkStyle *style, GtkWidget *win)
    {
      gtk_widget_modify_bg(glade_xml_get_widget(self->_priv->xml, "eventbox"), 
            GTK_STATE_NORMAL, 
            &((self->_priv->win)->style->bg[GTK_STATE_SELECTED]));
      gtk_widget_modify_text(glade_xml_get_widget(self->_priv->xml, "title_label"), 
            GTK_STATE_NORMAL, 
            &((self->_priv->win)->style->text[GTK_STATE_SELECTED]));
      gtk_widget_modify_fg(glade_xml_get_widget(self->_priv->xml, "title_label"), 
            GTK_STATE_NORMAL, 
            &((self->_priv->win)->style->fg[GTK_STATE_SELECTED]));

    }
    public
    gboolean
    type_image_clicked(self, GdkEventButton *button, GtkWidget *event)
    {
        if(self->_priv->schema)
        {
            GtkWidget *dialog = gtk_file_chooser_dialog_new(_("Pick an icon"), 
                    NULL, 
                    GTK_FILE_CHOOSER_ACTION_OPEN,
                    GTK_STOCK_CLEAR, GTK_RESPONSE_NO,
                    GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                    GTK_STOCK_OPEN, GTK_RESPONSE_OK, 
                    NULL);
	    file_chooser_enable_image_preview(dialog,16);	
            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case GTK_RESPONSE_NO:
                    stuffkeeper_data_schema_set_icon(self->_priv->schema,NULL);
                    break;
                case GTK_RESPONSE_OK:
                    {
                        gchar *file = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
                        if(file)
                        {
                            stuffkeeper_data_schema_set_icon(self->_priv->schema,file);
                            g_free(file);
                        }
                    }
                default:
                    break;
            }
            gtk_widget_destroy(dialog);
        }
        debug_printf("clicked\n");
        return FALSE;
    }

    private
    void
    reload_preview_del(self,  GtkTreePath *path, GtkTreeModel *model)
    {
        self_reload_preview(self);
    }

    private
    void
    reload_preview_ins(self,  GtkTreePath *path,GtkTreeIter *iter, GtkTreeModel *model)
    {
        self_reload_preview(self);
    }
    private
    void
    reload_preview(self)
    {
        GtkWidget *event = NULL;
        GtkWidget *vbox = gtk_vbox_new(FALSE, 0);
        GList *node, *list = gtk_container_get_children(GTK_CONTAINER(self->_priv->preview_box));
        GQueue *queue = g_queue_new();
        GtkTreeIter iter;
        GtkWidget *label;
        gint depth = 0;
        /* removing old widgets */
        for(node =list; node; node = g_list_next(node)) {
            gtk_widget_destroy(GTK_WIDGET(node->data));
        }
        g_list_free(list);

        event = gtk_event_box_new();
        gtk_widget_modify_bg(GTK_WIDGET(event), GTK_STATE_NORMAL, &(self->_priv->preview_box->style->white));
        gtk_container_add(GTK_CONTAINER(self->_priv->preview_box), event);
        gtk_container_add(GTK_CONTAINER(event), vbox);
        label = gtk_label_new("");
        gtk_label_set_markup(GTK_LABEL(label), "<span size='x-large' weight='bold'>Preview layout</span>");
        gtk_misc_set_alignment(GTK_MISC(label), 0,0.0);
        gtk_misc_set_padding(GTK_MISC(label), 6,6);
        gtk_widget_modify_fg(GTK_WIDGET(label), GTK_STATE_NORMAL, &(self->_priv->preview_box->style->black));
        gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, TRUE, 0);

        g_queue_push_head(queue, vbox);
        if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
        {
            do{
                GtkWidget *vbox = g_queue_peek_head(queue);
                FieldType type;
                gchar *name;
                GdkColor color;
                gtk_tree_model_get(GTK_TREE_MODEL(self->_priv->store), &iter,COL_TYPE ,&type, COL_NAME, &name, -1);


                if (type == FIELD_TYPE_VPACKING) {

                    GtkWidget *box = gtk_vbox_new(FALSE, 6);
                    GtkWidget *event = gtk_event_box_new();
                    gtk_container_add(GTK_CONTAINER(event), box);
                    gtk_container_set_border_width(GTK_CONTAINER(event), 6);
                    g_queue_push_head(queue, box);
                    gtk_box_pack_start(GTK_BOX(vbox), event, FALSE, TRUE, 0);
                    vbox = box;

                    color.red   = ((depth%3) == 0)?65535:256*128;
                    color.blue  = ((depth%3) == 1)?65535:256*128;
                    color.green = ((depth%3) == 2)?65535:256*128;
                    gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &color);
                    depth++;
                } else if (type == FIELD_TYPE_HPACKING) {
                    GtkWidget *event = gtk_event_box_new();
                    GtkWidget *box = gtk_hbox_new(TRUE, 6);
                    gtk_container_add(GTK_CONTAINER(event), box);
                    gtk_container_set_border_width(GTK_CONTAINER(event), 6);
                    g_queue_push_head(queue, box);
                    gtk_box_pack_start(GTK_BOX(vbox), event, FALSE, TRUE, 0);
                    vbox = box;
                    color.red   = ((depth%3) == 0)?65535:256*128;
                    color.blue  = ((depth%3) == 1)?65535:256*128;
                    color.green = ((depth%3) == 2)?65535:256*128;
                    gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &color);

                    depth++;
                } else if (type == FIELD_TYPE_EXPANDER) {
                    GtkWidget *expander = gtk_expander_new(name);
                    GtkWidget *event = gtk_event_box_new(); 
                    GtkWidget *box = gtk_vbox_new(TRUE, 6);
                    gtk_container_add(GTK_CONTAINER(event), box);
                    gtk_container_set_border_width(GTK_CONTAINER(event), 6);
                    g_queue_push_head(queue, box);
                    gtk_container_add(GTK_CONTAINER(expander), event);
                    gtk_box_pack_start(GTK_BOX(vbox), expander, FALSE, TRUE, 0);
                    vbox = box;
                    color.red   = ((depth%3) == 0)?65535:256*128;
                    color.blue  = ((depth%3) == 1)?65535:256*128;
                    color.green = ((depth%3) == 2)?65535:256*128;
                    gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &color);
                    gtk_expander_set_expanded(GTK_EXPANDER(expander), TRUE);
                    depth++;
                } else if (type == FIELD_TYPE_END|| type == FIELD_TYPE_END_EXPANDER) {
                    if(g_queue_get_length(queue) > 1)
                        g_queue_pop_head(queue);
                    else
                        printf("Popped one to many\n");
                    depth--;
                }
                else
                {
                    gchar *markup = g_markup_printf_escaped("<b>%s:</b> %s", _(FieldNames[type]), name);
                    GtkWidget *event = gtk_event_box_new(); 
                    GtkWidget *label = gtk_label_new(name);
                    gtk_misc_set_alignment(GTK_MISC(label), 0,0.0);
                    gtk_misc_set_padding(GTK_MISC(label), 6,6);
                    gtk_label_set_ellipsize(GTK_LABEL(label), PANGO_ELLIPSIZE_END);
                    gtk_widget_set_tooltip_markup(GTK_WIDGET(label), markup);
                    g_free(markup);

                    color.red   = ((depth%3) == 0)?65535:256*128;
                    color.blue  = ((depth%3) == 1)?65535:256*128;
                    color.green = ((depth%3) == 2)?65535:256*128;
                    gtk_widget_modify_bg(event, GTK_STATE_NORMAL, &color);
                    gtk_widget_modify_fg(GTK_WIDGET(label), GTK_STATE_NORMAL, &(self->_priv->preview_box->style->black));
                    gtk_container_add(GTK_CONTAINER(event), label);
                    gtk_container_set_border_width(GTK_CONTAINER(event), 6);
                    gtk_box_pack_start(GTK_BOX(vbox), event, FALSE, TRUE, 0);
                }
                g_free(name);
            }while(gtk_tree_model_iter_next(GTK_TREE_MODEL(self->_priv->store), &iter));
        }
        if(depth)
        {
            label = gtk_label_new("");
            gtk_label_set_markup(GTK_LABEL(label), "<span size='large'>Missing ending padding/expander</span>");
            gtk_misc_set_alignment(GTK_MISC(label), 0,0.0);
            gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, TRUE, 0);
            gtk_misc_set_padding(GTK_MISC(label), 0,6);
        }
        g_queue_free(queue);
        gtk_widget_show_all(self->_priv->preview_box);
    }

    /** Create the interface */
    public
        Stuffkeeper:Edit:Schema * 
        new(void)
        {
            GtkWidget *sw;
            GtkTreeIter iter;
            int i,width,height;
            GtkCellRenderer *renderer;
            Self *self = GET_NEW;
            GError *error = NULL;
            

            self->_priv->xml = glade_xml_new(PACKAGE_DATADIR"/stuffkeeper.glade","edit_schema_dialog",NULL);
            if(self->_priv->xml == NULL)
            {
                g_object_unref(self);
                debug_printf("Failed top open xml file\n");
                return NULL;
            }
            self->_priv->tree = glade_xml_get_widget(self->_priv->xml, "tree");
            self->_priv->win = glade_xml_get_widget(self->_priv->xml, "edit_schema_dialog");
            gtk_widget_hide_on_delete(self->_priv->win);

            self->_priv->preview_box = gtk_viewport_new(NULL, NULL);
            /* Wrap preview in a scrolled window */ 
            sw = gtk_scrolled_window_new(NULL, NULL);
            gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
            gtk_container_add(GTK_CONTAINER(sw), self->_priv->preview_box);
            gtk_paned_add2(GTK_PANED(glade_xml_get_widget(self->_priv->xml, "hpaned2")),
                    sw);
            gtk_widget_show(sw);


            self->_priv->model_fields = (GtkTreeModel *)gtk_list_store_new(2, G_TYPE_INT, G_TYPE_STRING);
            for(i=0; i <FIELD_TYPE_NUM_FIELDS;i++)
            {
		if(i < FIELD_TYPE_EXPANDER || i > FIELD_TYPE_HPACKING)
		{
			GtkTreeIter iter;
			gtk_list_store_append(GTK_LIST_STORE(self->_priv->model_fields),&iter);
			gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_fields), &iter, 0, i, 1,_(FieldNames[i]), -1); 	
		}
            }

            g_signal_connect_swapped(G_OBJECT(self->_priv->win), "style-set", G_CALLBACK(self_style_set), self);

            self->_priv->model_packings = (GtkTreeModel *)gtk_list_store_new(2, G_TYPE_INT, G_TYPE_STRING);
            gtk_list_store_append(GTK_LIST_STORE(self->_priv->model_packings),&iter);
            gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_packings), &iter, 0, FIELD_TYPE_VPACKING,1,_(FieldNames[FIELD_TYPE_VPACKING]), -1); 
            gtk_list_store_append(GTK_LIST_STORE(self->_priv->model_packings),&iter);
            gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_packings), &iter, 0, FIELD_TYPE_HPACKING,1,_(FieldNames[FIELD_TYPE_HPACKING]), -1); 
            gtk_list_store_append(GTK_LIST_STORE(self->_priv->model_packings),&iter);
            gtk_list_store_set(GTK_LIST_STORE(self->_priv->model_packings), &iter, 0, FIELD_TYPE_EXPANDER,1,_(FieldNames[FIELD_TYPE_EXPANDER]), -1); 

            /* fill tree with columns */
            self->_priv->renderer_model = renderer = gtk_cell_renderer_combo_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->tree),-1,
                        "Type", renderer,
                        "text", COL_TYPE_NAME,
                        "editable", COL_TYPE_EDITABLE,
                        NULL);

            /*          "model",COL_TYPE_MODEL, */
            //g_object_set(G_OBJECT(renderer), "model", GTK_TREE_MODEL(store), NULL);
            g_object_set(G_OBJECT(renderer), "text-column", 1,"has-entry", FALSE, NULL);
//            g_object_set(G_OBJECT(renderer), "editable", TRUE, NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_type_edited), self);
            gtk_tree_view_column_set_expand(gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->tree), 0), TRUE);



            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->tree),-1,"Name", renderer, "text", COL_NAME,"editable", COL_NAME_EDITABLE, NULL);
//            g_object_set(G_OBJECT(renderer), "editable", TRUE, NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_field_edited), self);
            gtk_tree_view_column_set_expand(gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->tree), 1), TRUE);

            renderer = gtk_cell_renderer_toggle_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->tree),-1,"In title", renderer, "active", COL_IN_TITLE, NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "toggled", G_CALLBACK(self_interface_in_title_toggled), self);
            gtk_tree_view_column_set_expand(gtk_tree_view_get_column(GTK_TREE_VIEW(self->_priv->tree), 2), FALSE);

            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->tree), GTK_TREE_MODEL(self->_priv->store));
						g_signal_connect_swapped(G_OBJECT(gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->tree))), 
								"changed", G_CALLBACK(self_field_selection_changed), self);


            width = g_key_file_get_integer(config_file, "EDIT_SCHEMA_WINDOW", "width", &error);
            if(error) {
                g_error_free(error);
                error = NULL;
            } else {
                height = g_key_file_get_integer(config_file, "EDIT_SCHEMA_WINDOW", "height", &error);
                if(error) {
                    g_error_free(error);
                    error = NULL;
                } else {
                    gtk_window_resize(GTK_WINDOW(self->_priv->win), width, height);
                }
            }

            glade_xml_signal_autoconnect_full(self->_priv->xml, (GladeXMLConnectFunc)self____glade_xml_connect_foreach, (gpointer)self);
            gtk_widget_show(GTK_WIDGET(self->_priv->win));
	    interface_element_add(self->_priv->win);
	    return self;
        }

    private
    void
        ___glade_xml_connect_foreach(const gchar *handler_name,
                GObject *object,
                const gchar *signal_name,
                const gchar *signal_data,
                GObject *connect_object,
                gboolean after,
                gpointer user_data)
        {
            static GModule * allsymbols = NULL;

            if (!allsymbols) allsymbols = g_module_open(NULL, 0);
            if (allsymbols) {
                gchar * func_name = g_strdup_printf("stuffkeeper_edit_schema_%s", handler_name);
                GCallback func;

                if (!g_module_symbol(allsymbols, func_name, (gpointer)&func)){
                    if (!g_module_symbol(allsymbols, handler_name, (gpointer)&func)) {
                        g_warning("could not find signal handler '%s'.", func_name);
                        g_free(func_name);
                        return;
                    }
                }
                if (after)
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_AFTER | G_CONNECT_SWAPPED);
                else
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_SWAPPED);
                g_free(func_name);
            }
        }

    private
    void
    apply_order(self)
    {
        int length = gtk_tree_model_iter_n_children(GTK_TREE_MODEL(self->_priv->store), NULL);
        if(length)
        {
            int i=0;
            GtkTreeIter iter;
            char **retv = g_malloc0((length+1)*sizeof(char *));
            if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
            {
                do{
                    gchar *id;
                    gtk_tree_model_get(GTK_TREE_MODEL(self->_priv->store), &iter, COL_ID, &id, -1);
                    retv[i] = id;
                    i++;
                }while(gtk_tree_model_iter_next(GTK_TREE_MODEL(self->_priv->store), &iter));
            }
            stuffkeeper_data_schema_field_reorder(self->_priv->schema, (const char**)retv);
            g_strfreev(retv);
        }
    }
    public
    void
    reorder_apply(self)
    {
        if(self->_priv->fields_reordered_signal)
            g_signal_handler_block(self->_priv->schema,self->_priv->fields_reordered_signal);
        self_apply_order(self);
        if(self->_priv->fields_reordered_signal)
            g_signal_handler_unblock(self->_priv->schema,self->_priv->fields_reordered_signal);
        self_reload_preview(self);
    }

    public
        void
        close(self)
        {
            int value;
            gtk_window_get_size(GTK_WINDOW(self->_priv->win), &value, NULL);
            g_key_file_set_integer(config_file, "EDIT_SCHEMA_WINDOW", "width", value);
            gtk_window_get_size(GTK_WINDOW(self->_priv->win), NULL, &value);
            g_key_file_set_integer(config_file, "EDIT_SCHEMA_WINDOW", "height", value);

            self_apply_order(self);

            printf("Disconnecting everything\n");
            if(self->_priv->changed_signal)
            {
                g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->changed_signal);
                self->_priv->changed_signal =0;
            }

            if(self->_priv->model_changed_signal)
            {
                g_signal_handler_disconnect(G_OBJECT(self->_priv->store), self->_priv->model_changed_signal);
                self->_priv->model_changed_signal =0;
            }
            if(self->_priv->model_added_signal)
            {
                g_signal_handler_disconnect(G_OBJECT(self->_priv->store), self->_priv->model_added_signal);
                self->_priv->model_added_signal =0;
            }
            if(self->_priv->model_removed_signal)
            {
                g_signal_handler_disconnect(G_OBJECT(self->_priv->store), self->_priv->model_removed_signal);
                self->_priv->model_removed_signal =0;
            }


            if(self->_priv->field_changed_signal)
            {
                g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->field_changed_signal);
                self->_priv->field_changed_signal =0;
            }
            if(self->_priv->field_added_signal)
            {
                g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->field_added_signal);
                self->_priv->field_added_signal =0;
            }
            if(self->_priv->field_removed_signal)
            {
                g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->field_removed_signal);
                self->_priv->field_removed_signal =0;
            }
            if(self->_priv->fields_reordered_signal)
            {
                g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->fields_reordered_signal);
                self->_priv->fields_reordered_signal =0;
            }

            if(self->_priv->field_title_entry_changed_signal)
            {
                g_signal_handler_disconnect(G_OBJECT(self->_priv->title_entry), self->_priv->field_title_entry_changed_signal);
                self->_priv->field_title_entry_changed_signal =0;
            }
            if(self->_priv->title_entry_changed_timeout) {
                g_source_remove(self->_priv->title_entry_changed_timeout);
                self->_priv->title_entry_changed_timeout = 0;
                self_title_entry_changed(self);
            }
            gtk_widget_destroy(GTK_WIDGET(self->_priv->win));
            g_object_unref(self->_priv->xml);
            g_object_unref(self);
        }
    public
    void
    add_expander(self)
    {
        stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_EXPANDER, "New Field",FALSE);
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_END, "",FALSE);
        stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
    }
    public
    void
    add_vpadding(self)
    {
        stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_VPACKING, "",FALSE);
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_END, "",FALSE);
        stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
    }
    public
    void
    add_hpadding(self)
    {
        stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_HPACKING, "",FALSE);
        stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_END, "",FALSE);
        stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
    }
    public
        void
        add_field(self)
        {
            stuffkeeper_data_backend_begin_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
            stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_STRING, "New Field",FALSE);
            stuffkeeper_data_backend_end_transaction(STUFFKEEPER_DATA_BACKEND(stuffkeeper_data_schema_get_backend(self->_priv->schema)));
        }

   public 
   void 
   move_field_up(self)
   {
       GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
       GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->tree));
       GtkTreeIter iter;
       if(gtk_tree_selection_get_selected(sel, &model, &iter))
       {
            GtkTreeIter prev;
            GtkTreePath *path = gtk_tree_model_get_path(model, &iter);
            if(gtk_tree_path_prev(path))
            {
                if(gtk_tree_model_get_iter(model, &prev, path)){
                    gtk_list_store_swap(GTK_LIST_STORE(model), &iter, &prev);
                }
            }
            gtk_tree_path_free(path);
       }

        self_reload_preview(self);
   }
   public
   void
   move_field_down(self)
   {
       GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
       GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->tree));
       GtkTreeIter iter;
       if(gtk_tree_selection_get_selected(sel, &model, &iter))
       {
            GtkTreeIter prev;
            GtkTreePath *path = gtk_tree_model_get_path(model, &iter);
            gtk_tree_path_next(path);
            if(gtk_tree_model_get_iter(model, &prev, path)){
                gtk_list_store_swap(GTK_LIST_STORE(model), &iter, &prev);
            }
            gtk_tree_path_free(path);
       }
        self_reload_preview(self);
   }

   public
   void
   remove_field(self)
   {
       GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(self->_priv->win),
                        GTK_DIALOG_DESTROY_WITH_PARENT|GTK_DIALOG_MODAL,
                        GTK_MESSAGE_WARNING,GTK_BUTTONS_YES_NO,
                        "This will delete the field, and all data it contains in the related items.\nAre you sure you want to continue?"); 
       switch(gtk_dialog_run(GTK_DIALOG(dialog)))
       {
            case GTK_RESPONSE_YES:
                gtk_widget_destroy(dialog);
                break;
            default:
                gtk_widget_destroy(dialog);
                return;
       }
       GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
       GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->tree));
        GtkTreeIter iter;
        if(gtk_tree_selection_get_selected(sel, &model, &iter))
        {
            gchar *id;
            int type;
            gtk_tree_model_get(model, &iter,COL_TYPE, &type, COL_ID, &id, -1);

            if(type == FIELD_TYPE_EXPANDER || type == FIELD_TYPE_VPACKING || type == FIELD_TYPE_HPACKING)
            {
                int type_expect = (type == FIELD_TYPE_EXPANDER)? FIELD_TYPE_END_EXPANDER:FIELD_TYPE_END;
                do{
                    int type2;
                    gchar *id2;
                    gtk_tree_model_get(model, &iter,COL_ID, &id2,COL_TYPE, &type2,  -1);
                    if(type2 == type_expect) 
                    {
                        stuffkeeper_data_schema_remove_field(self->_priv->schema, id);
                        stuffkeeper_data_schema_remove_field(self->_priv->schema, id2);
                        g_free(id);
                        g_free(id2);
                        return;
                    }

                    g_free(id2);
                }while(gtk_tree_model_iter_next(model, &iter));

            }
            stuffkeeper_data_schema_remove_field(self->_priv->schema, id);
            g_free(id);
        }
   }
    
    public
    void
    set_schema(self, Stuffkeeper:Data:Schema *schema)
    {
        if(self->_priv->schema != NULL)
        {
            debug_printf("Allready have a schema attaches\n");
            return;
        }
        self->_priv->schema = schema;
       
        gsize length;
        int i =0;
        char **ids  = stuffkeeper_data_schema_get_fields(schema, &length);
        for(i=0;i<length;i++)
        {
            self_schema_field_added(self, ids[i], schema); 

        }

        self->_priv->changed_signal = g_signal_connect_swapped(G_OBJECT(schema),  
                            "schema-changed",
                            G_CALLBACK(self_schema_changed),
                            self);
        self->_priv->field_changed_signal = g_signal_connect_swapped(G_OBJECT(schema),  
                            "schema-field-changed",
                            G_CALLBACK(self_schema_field_changed),
                            self);
        self->_priv->field_added_signal =   g_signal_connect_swapped(G_OBJECT(schema),  
                            "schema-field-added",
                            G_CALLBACK(self_schema_field_added),
                            self);
        self->_priv->field_removed_signal = g_signal_connect_swapped(G_OBJECT(schema),
                            "schema-field-removed",
                            G_CALLBACK(self_schema_field_removed),
                            self);
        self->_priv->fields_reordered_signal = g_signal_connect_swapped(G_OBJECT(schema),
                            "schema-fields-reordered",

                            G_CALLBACK(self_schema_fields_reordered),
                            self);

        self->_priv->title_entry = glade_xml_get_widget(self->_priv->xml, "title_entry");
        self->_priv->field_title_entry_changed_signal = g_signal_connect_swapped(G_OBJECT(self->_priv->title_entry), "changed", G_CALLBACK(self_title_changed_real), self);
        self_schema_changed(self, schema);

        self->_priv->model_removed_signal = g_signal_connect_swapped(G_OBJECT(self->_priv->store), "row-deleted", G_CALLBACK(self_reload_preview_del), self);
        self->_priv->model_added_signal =  g_signal_connect_swapped(G_OBJECT(self->_priv->store), "row-inserted", G_CALLBACK(self_reload_preview_ins), self);
        self->_priv->model_changed_signal = g_signal_connect_swapped(G_OBJECT(self->_priv->store), "row-changed", G_CALLBACK(self_reload_preview_ins), self);
        
        
        
        self_reload_preview(self); 
        
    }

    override (G:Object)
    void
    finalize(G:Object *obj)
    {
        debug_printf("** Finalize edit schema\n");
        PARENT_HANDLER(obj);
    }

		private
		void
		update_field_config(self)
		{
			GtkTreeSelection *selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->tree));
			GtkWidget *container = glade_xml_get_widget(self->_priv->xml, "field_box");
            GtkWidget *frame = glade_xml_get_widget(self->_priv->xml, "field_box_frame");
			GtkWidget *child = gtk_bin_get_child(GTK_BIN(container));
			GtkTreeIter iter;
			/* Cleanup */
			if(child)
			{
				gtk_widget_destroy(child);
			}
			/* ok, now we set it up */
			if(gtk_tree_selection_get_selected(selection, (GtkTreeModel **)&(self->_priv->store), &iter))
			{
				int type = 0;
				char *id = NULL;
				gtk_tree_model_get(GTK_TREE_MODEL(self->_priv->store), &iter,COL_TYPE, &type, COL_ID, &id,-1);
				if(id){
					GtkWidget *widget = NULL;
					printf("type: %i\n", type); 
					if(type == FIELD_TYPE_STRING)
					{
						widget = stuffkeeper_data_entry_config_new(self->_priv->schema, id);
					} else if (type == FIELD_TYPE_INTEGER) {
						widget = stuffkeeper_data_spinbutton_config_new(self->_priv->schema, id);
					} else if (type == FIELD_TYPE_IMAGE) {
						widget = (GtkWidget *)stuffkeeper_data_image_config_new();
						stuffkeeper_data_image_config_setup(STUFFKEEPER_DATA_IMAGE_CONFIG(widget),self->_priv->schema, id);
					} else if (type == FIELD_TYPE_BOOLEAN) {
						widget = (GtkWidget *)stuffkeeper_data_boolean_config_new();
						stuffkeeper_data_boolean_config_setup(STUFFKEEPER_DATA_BOOLEAN_CONFIG(widget),self->_priv->schema, id);
					}else if (type == FIELD_TYPE_RATING) {
						widget = (GtkWidget *)stuffkeeper_data_rating_config_new();
						stuffkeeper_data_rating_config_setup(STUFFKEEPER_DATA_RATING_CONFIG(widget),self->_priv->schema, id);
					} else if (type == FIELD_TYPE_PASSWORD) {
						widget = (GtkWidget *)stuffkeeper_data_password_config_new(self->_priv->schema, id);
					}

					if(widget){
						gtk_container_add(GTK_CONTAINER(container), widget);
						gtk_widget_show_all(frame);
					}
                    else{
                        gtk_widget_hide(frame);
                    }
				}

				if(id)
					g_free(id);
			}
		}

		private
		void
		field_selection_changed(self,GtkTreeSelection *selection)
		{
			self_update_field_config(self);
		} 
}
