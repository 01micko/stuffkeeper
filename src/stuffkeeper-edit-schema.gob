requires 2.0.10

%h{
/* Include gtk */
#include <gtk/gtk.h>
#include <glib/gi18n.h>
#include <glade/glade.h>
#include "config.h"
#include "debug.h"
/* Include the database */

#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-data-schema.h"
#include "stuffkeeper-data-label.h"
#include "stuffkeeper-data-entry.h"
#include "stuffkeeper-data-boolean.h"
#include "stuffkeeper-data-spinbutton.h"
#include "stuffkeeper-data-rating.h"
#include "stuffkeeper-data-taglist.h"
extern GList *interface_list;
%}
%ph{
    typedef enum _StoreFields
    {  
        COL_ID,
        COL_TYPE,
        COL_NAME,
        COL_TYPE_NAME,
        NUM_ROWS
    }StoreFields;
%}

class StuffKeeper:Edit:Schema from G:Object 
{
    private StuffKeeper:Data:Schema *schema = {NULL};
    private GtkListStore *store = {gtk_list_store_new(NUM_ROWS,G_TYPE_STRING, G_TYPE_INT,G_TYPE_STRING,G_TYPE_STRING)}  destroywith g_object_unref;

    private GladeXML *xml;
    private GtkWidget *tree;
    private GtkWidget *win;

    private guint changed_signal = 0;
    private guint field_changed_signal = 0;
    private guint field_added_signal = 0;
    private guint field_removed_signal = 0;
private guint field_swapped_signal = 0;



    private
    void
    schema_changed(self, StuffKeeperDataSchema *schema)
    {
        GtkWidget *label = glade_xml_get_widget(self->_priv->xml, "title_label");
        GtkWidget *image = glade_xml_get_widget(self->_priv->xml, "type_image");
        GdkPixbuf *pixbuf = stuffkeeper_data_schema_get_pixbuf(schema);
        /**
         * update title
         */
        gchar *temp;
        temp = stuffkeeper_data_schema_get_title(schema);
        if(temp)
        {
            gchar *str = g_markup_printf_escaped("<span size='large' weight='bold'>%s: '%s'</span>",_("Edit type"), temp);
            gtk_label_set_markup(GTK_LABEL(label),str);
            g_free(str);
            g_free(temp);
        }

        if(pixbuf)
        {
            gtk_image_set_from_pixbuf(GTK_IMAGE(image), pixbuf);
        }
    }

    private
    void
    schema_field_changed(self, const gchar *field, StuffKeeperDataSchema *schema)
    {
        GtkTreeIter iter;

        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
        if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
        {
            do{
                gchar *id;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                if(strcmp(id, field) ==0)
                {

                    int type = stuffkeeper_data_schema_get_field_type(schema, id);
                    gchar *name = stuffkeeper_data_schema_get_field_name(schema, id);
                    gtk_list_store_set(self->_priv->store, &iter, 
                            COL_NAME, name,
                            COL_TYPE, type,
                            COL_TYPE_NAME, FieldNames[type],
                            -1);
                    g_free(name);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }
    private
    void
    schema_field_removed(self, const gchar *removed_id, StuffKeeper:Data:Schema *schema)
    {
        GtkTreeIter iter;
        
        GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
        debug_printf("removing field from list\n");
        if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
        {
            do{
                gchar *id;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                if(strcmp(id, removed_id) ==0)
                {
                    gtk_list_store_remove(self->_priv->store, &iter);
                    return;
                }
            }while(gtk_tree_model_iter_next(model, &iter));
        }
    }

    private
        void
        schema_field_added(self, const gchar *id, StuffKeeperDataSchema *schema)
        {

            GtkTreeIter iter;
            gchar *name;
            int type = stuffkeeper_data_schema_get_field_type(schema, id);
            gtk_list_store_append(self->_priv->store, &iter);
            name = stuffkeeper_data_schema_get_field_name(schema, id);
            gtk_list_store_set(self->_priv->store, &iter, 
                    COL_ID, id, 
                    COL_TYPE, type ,
                    COL_NAME, name,
                    COL_TYPE_NAME, FieldNames[type],
                    -1);
            g_free(name);
        }
        private
        void
        schema_field_swapped(self, const gchar *id1, const gchar *id2, StuffKeeperDataSchema *schema)
        {
            GtkTreeIter iter1, iter2,iter;
            int found1=0, found2 = 0;
            /* lookup iters */
            GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
            debug_printf("swapping field in list.\n");
            if(gtk_tree_model_get_iter_first(GTK_TREE_MODEL(self->_priv->store), &iter))
            {
                do{
                    gchar *id;
                    gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                    if(!found1  && strcmp(id, id1) ==0)
                    {
                        iter1 = iter;
                        found1 = 1;
                    }else if (!found2 && strcmp(id, id2) == 0)
                    {
                        iter2 = iter;
                        found2 = 1;
                    }
                    g_free(id);
                }while((!found1 || !found2) && gtk_tree_model_iter_next(model, &iter));

                if(found1 && found2)
                {
                    gtk_list_store_swap(GTK_LIST_STORE(model), &iter1, &iter2);
                }
            }   


        }

    public
        void interface_field_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeIter iter;
            GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
            debug_printf("new: %s\n", new_text);
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                gchar *id;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                stuffkeeper_data_schema_set_field_name(self->_priv->schema, id,new_text);
                g_free(id);


            }
        }
    public
        void interface_type_edited
        (
         self,
         gchar               *path,
         gchar               *new_text,
         GtkCellRendererText *renderer
        )
        {
            GtkTreeIter iter;
            GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
            debug_printf("new: %s\n", new_text);
            if(gtk_tree_model_get_iter_from_string(model, &iter, path))
            {
                int type;
                gchar *id = NULL;
                gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
                for(type=0;strcmp(new_text,FieldNames[type]) && type < FIELD_TYPE_NUM_FIELDS;type++);
                /* somehow type is not found default to string */
                if(type == FIELD_TYPE_NUM_FIELDS) type = FIELD_TYPE_STRING; 
                stuffkeeper_data_schema_set_field_type(self->_priv->schema,id, type);
                g_free(id);
            }
        }

    private
    void
    style_set(self, GtkStyle *style, GtkWidget *win)
    {
      gtk_widget_modify_bg(glade_xml_get_widget(self->_priv->xml, "eventbox"), 
            GTK_STATE_NORMAL, 
            &((self->_priv->win)->style->bg[GTK_STATE_SELECTED]));
      gtk_widget_modify_text(glade_xml_get_widget(self->_priv->xml, "title_label"), 
            GTK_STATE_NORMAL, 
            &((self->_priv->win)->style->text[GTK_STATE_SELECTED]));
      gtk_widget_modify_fg(glade_xml_get_widget(self->_priv->xml, "title_label"), 
            GTK_STATE_NORMAL, 
            &((self->_priv->win)->style->fg[GTK_STATE_SELECTED]));

    }
    public
    gboolean
    type_image_clicked(self, GdkEventButton *button, GtkWidget *event)
    {
        if(self->_priv->schema)
        {
            GtkWidget *dialog = gtk_file_chooser_dialog_new(_("Pick an icon"), 
                    NULL, 
                    GTK_FILE_CHOOSER_ACTION_OPEN,
                    GTK_STOCK_CLEAR, GTK_RESPONSE_NO,
                    GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
                    GTK_STOCK_OPEN, GTK_RESPONSE_OK, 
                    NULL);
            switch(gtk_dialog_run(GTK_DIALOG(dialog)))
            {
                case GTK_RESPONSE_NO:
                    stuffkeeper_data_schema_set_icon(self->_priv->schema,NULL);
                    break;
                case GTK_RESPONSE_OK:
                    {
                        gchar *file = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
                        if(file)
                        {
                            stuffkeeper_data_schema_set_icon(self->_priv->schema,file);
                            g_free(file);
                        }
                    }
                default:
                    break;
            }
            gtk_widget_destroy(dialog);




        }
        debug_printf("clicked\n");
        return FALSE;
    }

    /** Create the interface */
    public
        StuffKeeper:Edit:Schema * 
        new(void)
        {
            int i;
            GtkCellRenderer *renderer;
            Self *self = GET_NEW;
            GtkListStore *store = gtk_list_store_new(2, G_TYPE_INT, G_TYPE_STRING);
            self->_priv->xml = glade_xml_new(PACKAGE_DATADIR"/stuffkeeper.glade","edit_schema_dialog",NULL);
            if(self->_priv->xml == NULL)
            {
                g_object_unref(self);
                debug_printf("Failed top open xml file\n");
                return NULL;
            }

            self->_priv->tree = glade_xml_get_widget(self->_priv->xml, "tree");
            self->_priv->win = glade_xml_get_widget(self->_priv->xml, "edit_schema_dialog");

            for(i=0; i <FIELD_TYPE_NUM_FIELDS;i++)
            {
                GtkTreeIter iter;
                gtk_list_store_append(store,&iter);
                gtk_list_store_set(store, &iter, 0, i, 1,FieldNames[i], -1); 
            }

            g_signal_connect_swapped(G_OBJECT(self->_priv->win), "style-set", G_CALLBACK(self_style_set), self);
      


            /* fill tree with columns */
            renderer = gtk_cell_renderer_combo_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->tree),-1,"Type", renderer, "text", COL_TYPE_NAME, NULL);
            g_object_set(G_OBJECT(renderer), "model", GTK_TREE_MODEL(store), NULL);
            g_object_set(G_OBJECT(renderer), "text-column", 1,"has-entry", FALSE, NULL);
            g_object_set(G_OBJECT(renderer), "editable", TRUE, NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_type_edited), self);




            renderer = gtk_cell_renderer_text_new();
            gtk_tree_view_insert_column_with_attributes(GTK_TREE_VIEW(self->_priv->tree),-1,"Name", renderer, "text", COL_NAME, NULL);
            g_object_set(G_OBJECT(renderer), "editable", TRUE, NULL);
            g_signal_connect_swapped(G_OBJECT(renderer), "edited", G_CALLBACK(self_interface_field_edited), self);

            gtk_tree_view_set_model(GTK_TREE_VIEW(self->_priv->tree), GTK_TREE_MODEL(self->_priv->store));

            glade_xml_signal_autoconnect_full(self->_priv->xml, (GladeXMLConnectFunc)self____glade_xml_connect_foreach, (gpointer)self);
            gtk_widget_show_all(GTK_WIDGET(self->_priv->win));
            return self;
        }

    private
    void
        ___glade_xml_connect_foreach(const gchar *handler_name,
                GObject *object,
                const gchar *signal_name,
                const gchar *signal_data,
                GObject *connect_object,
                gboolean after,
                gpointer user_data)
        {
            static GModule * allsymbols = NULL;

            if (!allsymbols) allsymbols = g_module_open(NULL, 0);
            if (allsymbols) {
                gchar * func_name = g_strdup_printf("stuffkeeper_edit_schema_%s", handler_name);
                GCallback func;

                if (!g_module_symbol(allsymbols, func_name, (gpointer)&func)){
                    if (!g_module_symbol(allsymbols, handler_name, (gpointer)&func)) {
                        g_warning("could not find signal handler '%s'.", func_name);
                        g_free(func_name);
                        return;
                    }
                }
                if (after)
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_AFTER | G_CONNECT_SWAPPED);
                else
                    g_signal_connect_data(object, signal_name, func, user_data, NULL, G_CONNECT_SWAPPED);
                g_free(func_name);
            }
        }

    public
        void
        close(self)
        {
            gtk_widget_destroy(GTK_WIDGET(self->_priv->win));
            g_object_unref(self->_priv->xml);
            g_object_unref(self);
        }

    public
        void
        add_field(self)
        {
            stuffkeeper_data_schema_add_field(self->_priv->schema, FIELD_TYPE_STRING, "New Field");
        }
    
   public 
   void
   move_field_up(self)
   {
       GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
       GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->tree));
        GtkTreeIter siter,piter;
        if(gtk_tree_selection_get_selected(sel, &model, &siter))
        {
            GtkTreePath *path = gtk_tree_model_get_path(model, &siter);
            if(path)
            {
                if(gtk_tree_path_prev(path))
                {
                    if(gtk_tree_model_get_iter(model, &piter, path))
                    {
                        gchar *sid = NULL, *pid = NULL;
                        gtk_tree_model_get(model, &siter, COL_ID, &sid, -1);
                        gtk_tree_model_get(model, &piter, COL_ID, &pid, -1);
                        
                        stuffkeeper_data_schema_swap_field_pos(self->_priv->schema, sid,pid); 

                        g_free(sid); g_free(pid);
                    }
                }
                gtk_tree_path_free(path);
            }
        }
   }
   public 
   void
   move_field_down(self)
   {
       GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
       GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->tree));
       GtkTreeIter siter,piter;
       if(gtk_tree_selection_get_selected(sel, &model, &siter))
       {
           piter = siter;
           if(gtk_tree_model_iter_next(model, &piter))
           {
               gchar *sid = NULL, *pid = NULL;
               gtk_tree_model_get(model, &siter, COL_ID, &sid, -1);
               gtk_tree_model_get(model, &piter, COL_ID, &pid, -1);

               stuffkeeper_data_schema_swap_field_pos(self->_priv->schema, sid,pid); 

               g_free(sid); g_free(pid);
           }
       }
   }
   public
   void
   remove_field(self)
   {
       GtkWidget *dialog = gtk_message_dialog_new(GTK_WINDOW(self->_priv->win),
                        GTK_DIALOG_DESTROY_WITH_PARENT|GTK_DIALOG_MODAL,
                        GTK_MESSAGE_WARNING,GTK_BUTTONS_YES_NO,
                        "This will delete the field, and all data it contains in the related items.\nAre you sure you want to continue?"); 
       switch(gtk_dialog_run(GTK_DIALOG(dialog)))
       {
            case GTK_RESPONSE_YES:
                gtk_widget_destroy(dialog);
                break;
            default:
                gtk_widget_destroy(dialog);
                return;
       }
       GtkTreeModel *model = GTK_TREE_MODEL(self->_priv->store);
       GtkTreeSelection *sel = gtk_tree_view_get_selection(GTK_TREE_VIEW(self->_priv->tree));
        GtkTreeIter iter;
        if(gtk_tree_selection_get_selected(sel, &model, &iter))
        {
            gchar *id;
            gtk_tree_model_get(model, &iter, COL_ID, &id, -1);
            stuffkeeper_data_schema_remove_field(self->_priv->schema, id);
            g_free(id);
        }
   }
    
    public
    void
    set_schema(self, StuffKeeper:Data:Schema *schema)
    {
        if(self->_priv->schema != NULL)
        {
            debug_printf("Allready have a schema attaches\n");
            return;
        }
        self->_priv->schema = schema;
       
        gsize length;
        int i =0;
        char **ids  = stuffkeeper_data_schema_get_fields(schema, &length);
        for(i=0;i<length;i++)
        {
            self_schema_field_added(self, ids[i], schema); 

        }

        self->_priv->changed_signal = g_signal_connect_swapped(G_OBJECT(schema),  
                            "schema-changed",
                            G_CALLBACK(self_schema_changed),
                            self);
        self->_priv->field_changed_signal = g_signal_connect_swapped(G_OBJECT(schema),  
                            "schema-field-changed",
                            G_CALLBACK(self_schema_field_changed),
                            self);
        self->_priv->field_added_signal =   g_signal_connect_swapped(G_OBJECT(schema),  
                            "schema-field-added",
                            G_CALLBACK(self_schema_field_added),
                            self);
        self->_priv->field_removed_signal = g_signal_connect_swapped(G_OBJECT(schema),
                            "schema-field-removed",
                            G_CALLBACK(self_schema_field_removed),
                            self);
        self->_priv->field_swapped_signal = g_signal_connect_swapped(G_OBJECT(schema),
                            "schema-field-swapped",
                            G_CALLBACK(self_schema_field_swapped),
                            self);
        self_schema_changed(self, schema);

    }

    override (G:Object)
    void
    finalize(G:Object *obj)
    {
        Self *self = SELF(obj);
        debug_printf("** Finalize edit schema\n");
        if(self->_priv->changed_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->changed_signal);
            self->_priv->changed_signal =0;
        }




        if(self->_priv->field_changed_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->field_changed_signal);
            self->_priv->field_changed_signal =0;
        }
        if(self->_priv->field_added_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->field_added_signal);
            self->_priv->field_added_signal =0;
        }
        if(self->_priv->field_removed_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->field_removed_signal);
            self->_priv->field_removed_signal =0;
        }
        if(self->_priv->field_swapped_signal)
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->field_swapped_signal);
            self->_priv->field_swapped_signal =0;
        }

    }
}
