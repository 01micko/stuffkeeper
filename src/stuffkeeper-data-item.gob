requires 2.0.10

%ph{
#define KEYFILE_GENERAL "general"
#define KEYFILE_CUSTOM "custom"
/* Save a changed item after 30 seconds */
#define SAVE_TIMEOUT 30000 
%}
%h{
    #include "stuffkeeper-data-tag.h"
    #include "stuffkeeper-data-schema.h"

%}

%ph{
    #include "stuffkeeper-data-backend.h"

%}
%{
    #include <stdio.h>
%}



class StuffKeeper:Data:Item from G:Object 
{
    private gboolean changed = {FALSE};
    private StuffKeeperDataBackend *skdb = {NULL};
    private GKeyFile *data = {NULL};
    private char * path = {NULL} destroywith g_free;
    private GList *tags = {NULL} destroywith g_list_free;

    private StuffKeeperDataSchema *schema = {NULL};

    private guint schema_field_removed = {0};

    private guint save_timeout = {0};
    /**
     * Signals 
     */
    signal last NONE (STRING)
    void
    item_changed(self, const gchar *field)
    {
        /* Mark the item changed */
        self_mark_changed(self);
    }

    /* Finalize functions */
    override (G:Object)
    void
    finalize (G:Object *obj)
    {
        Self *self = SELF(obj);
        if(self->_priv->data)
        {
            g_key_file_free(self->_priv->data);
            self->_priv->data = NULL;
        }
        if(self->_priv->schema_field_removed )
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema),self->_priv->schema_field_removed );
            self->_priv->schema_field_removed = 0; 
        }
        if(self->_priv->save_timeout)
        {
            g_source_remove(self->_priv->save_timeout);
            self->_priv->save_timeout = 0;
        }
        PARENT_HANDLER(obj);
    }
    private
    void
    mark_changed(self)
    {
        if(self->_priv->save_timeout)
        {
            g_source_remove(self->_priv->save_timeout);
            self->_priv->save_timeout = 0;
        }
        self->_priv->changed = TRUE;

        self->_priv->save_timeout = g_timeout_add(SAVE_TIMEOUT, (GSourceFunc)self_save_yourself, self);
    }
    /**
     * Functions to manage 
     */
    public
    void
    save_yourself(self)
    {
        if(self->_priv->data && self->_priv->changed == TRUE)
        {
            char *content;

            gsize size=0;

            printf("Item Saving myself\n");
            /* save tags */
            /* clear previous values */
            g_key_file_remove_key(self->_priv->data, KEYFILE_GENERAL, "tags", NULL);
            gsize numtags = g_list_length(self->_priv->tags);
            if(numtags != 0)
            {
                int *items = g_malloc0(sizeof(int)*numtags); 
                GList *node = g_list_first(self->_priv->tags);
                int i=0;
                for(;node;node = g_list_next(node))
                {
                    items[i] = stuffkeeper_data_tag_get_id(STUFFKEEPER_DATA_TAG(node->data));
                    i++;
                }
                g_key_file_set_integer_list(self->_priv->data, KEYFILE_GENERAL, "tags", items, numtags);
                g_free(items);
            }
            content = g_key_file_to_data(self->_priv->data,&size, NULL);
            g_file_set_contents(self->_priv->path, content, size, NULL);
            g_free(content);
        }
        /* Mark as unchanged */
        self->_priv->changed = FALSE;
        if(self->_priv->save_timeout)
        {
            g_source_remove(self->_priv->save_timeout);
            self->_priv->save_timeout = 0;
        }

    }

    public
    void
    delete_yourself(self)
    {
        g_key_file_set_integer(self->_priv->data, KEYFILE_GENERAL,"id", -1);

        stuffkeeper_data_schema_remove_item(self->_priv->schema, G_OBJECT(self));

        GList *node = g_list_first(self->_priv->tags);
        for(;node;node = g_list_next(node))
        {
            stuffkeeper_data_tag_remove_item(STUFFKEEPER_DATA_TAG(node->data), G_OBJECT(self));
        }
        g_list_free(self->_priv->tags);
        self->_priv->tags = NULL;
        g_unlink(self->_priv->path);
        g_free(self->_priv->path);
        self->_priv->path = NULL;
    }

    /* Create new StuffKeeperDataBackend */
    public 
        StuffKeeperDataItem *
        new (G:Object *skdb, const gchar *path,StuffKeeperDataSchema *schema)
        {

            Self *obj = GET_NEW;
            Self *test= NULL;
            gint id = g_random_int();
            /** check if it exists */
            while((test = stuffkeeper_data_backend_get_item(STUFFKEEPER_DATA_BACKEND(skdb),id)) != NULL)
            {
                /* generate new id */
                printf("%i allready exists, re-trying\n",id);
                id = g_random_int();
            }

            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->path = g_strdup_printf("%s%c%i", path, G_DIR_SEPARATOR,id);
            obj->_priv->data = g_key_file_new();
            g_key_file_set_integer(obj->_priv->data, KEYFILE_GENERAL,"id", id);

            obj->_priv->schema = schema; 
            obj->_priv->schema_field_removed = g_signal_connect_swapped(G_OBJECT(obj->_priv->schema), "schema-field-removed", G_CALLBACK(self_item_schema_field_removed), obj);

            id = stuffkeeper_data_schema_get_id(schema);
            g_key_file_set_integer(obj->_priv->data, KEYFILE_GENERAL, "schema", id);
            stuffkeeper_data_schema_add_item(obj->_priv->schema, G_OBJECT(obj));

            self_save_yourself(obj);
            return obj;
        }

    public
    StuffKeeperDataItem *
    new_from_file (G:Object *skdb, const gchar *file)
    {
        Self *obj = GET_NEW;
        obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
        obj->_priv->data = g_key_file_new();
        obj->_priv->path = (file != NULL)?g_strdup(file):NULL;
        g_key_file_load_from_file(obj->_priv->data, obj->_priv->path, G_KEY_FILE_NONE, NULL);
        /* Load the tags */
        gsize items=0;
        int *tags = g_key_file_get_integer_list(obj->_priv->data, KEYFILE_GENERAL, "tags", &items, NULL);
        if(tags)
        {
           int i;
           for(i=0;i<items;i++)
           {
               StuffKeeperDataTag *tag = stuffkeeper_data_backend_add_tag(obj->_priv->skdb,obj, tags[i]);
               obj->_priv->tags = g_list_append(obj->_priv->tags, tag);
               stuffkeeper_data_tag_add_item(tag, G_OBJECT(obj));
           }
           g_free(tags);
        }
        GError *error=NULL;
        int schemaid = g_key_file_get_integer(obj->_priv->data, KEYFILE_GENERAL, "schema", &error);
        if(error == NULL)
        {
            obj->_priv->schema = stuffkeeper_data_backend_get_schema(obj->_priv->skdb, schemaid);
            obj->_priv->schema_field_removed = g_signal_connect_swapped(G_OBJECT(obj->_priv->schema), "schema-field-removed", G_CALLBACK(self_item_schema_field_removed), obj);
            stuffkeeper_data_schema_add_item(obj->_priv->schema, G_OBJECT(obj));
        }
        /* When loading the items it is marked as changed. reset this*/
        obj->_priv->changed = FALSE;
        if(obj->_priv->save_timeout)
        {
            g_source_remove(obj->_priv->save_timeout);
            obj->_priv->save_timeout = 0;
        }
        return obj;
    }

    /**
     * When a field in the schema is removed, removed the entry from the item.
     * Don't signal a change, (for now) This should be handled by the parent holding it.
     */
    private 
    void
    item_schema_field_removed(self, const char *id, StuffKeeperDataSchema *schema)
    {
        g_key_file_remove_key(self->_priv->data, KEYFILE_CUSTOM, id, NULL);
        /* Mark for change */
        self_mark_changed(self);
    }


    /**
     * ID (ro)
     */
    public
    gint
    get_id(self)
    {
        gint id = g_key_file_get_integer(self->_priv->data, KEYFILE_GENERAL, "id",NULL);
        return id;
    }
    
    /**
     * Title (rw)
     */
    public 
    gchar *
    get_title(self)
    {
        return g_key_file_get_string(self->_priv->data, KEYFILE_GENERAL, "title", NULL); 
    }


    public 
    void
    set_title(self, const gchar *title)
    {
        g_key_file_set_string(self->_priv->data, KEYFILE_GENERAL, "title", title);
        self_item_changed(self,NULL);
    }
    /**
     * Generic getting/setting items
     */
    public
    gchar *
    get_string(self, const gchar *field)
    {
        return g_key_file_get_string(self->_priv->data, KEYFILE_CUSTOM, field, NULL); 
    }

    public 
    void
    set_string(self, const gchar *field, const gchar *value)
    {
        g_key_file_set_string(self->_priv->data, KEYFILE_CUSTOM, field, value);
        self_item_changed(self,field);
    }
    public
    gint 
    get_integer(self, const gchar *field)
    {
        return g_key_file_get_integer(self->_priv->data, KEYFILE_CUSTOM, field, NULL); 
    }

    public 
    void
    set_integer(self, const gchar *field, const gint value)
    {
        g_key_file_set_integer(self->_priv->data, KEYFILE_CUSTOM, field, value);
        self_item_changed(self,field);
    }


    public
        gint 
    get_boolean(self, const gchar *field)
    {
        return g_key_file_get_boolean(self->_priv->data, KEYFILE_CUSTOM, field, NULL); 
    }

    public 
    void
    set_boolean(self, const gchar *field, const gint value)
    {
        g_key_file_set_boolean(self->_priv->data, KEYFILE_CUSTOM, field, value);
        self_item_changed(self,field);
    }
    public
        gchar **
    get_list(self, const gchar *field,gsize *length)
    {
        return g_key_file_get_string_list(self->_priv->data, KEYFILE_CUSTOM, field,length, NULL); 
    }

    public 
    void
    set_list(self, const gchar *field, const gchar *value[], gsize length)
    {
        g_key_file_set_string_list(self->_priv->data, KEYFILE_CUSTOM, field, value,length);
        self_item_changed(self,field);
    }

    /**
     * Tags
     */
    public
    gboolean
    has_tag(self, const StuffKeeperDataTag *tag)
    {
        GList *node = g_list_find(self->_priv->tags, tag);

        return (node != NULL)?TRUE:FALSE;
    }
    public
    void
    add_tag(self, StuffKeeperDataTag *tag)
    {
        self->_priv->tags = g_list_append(self->_priv->tags, tag);
        self_item_changed(self,NULL);
        stuffkeeper_data_tag_add_item(tag,G_OBJECT(self));
    }
    public
    void
    remove_tag(self, StuffKeeperDataTag *tag)
    {
        self->_priv->tags = g_list_remove(self->_priv->tags, tag);
        self_item_changed(self,NULL);
        stuffkeeper_data_tag_remove_item(tag, G_OBJECT(self));
    }
    
    /* Schema */
    public
    StuffKeeperDataSchema *
    get_schema(self)
    {
        return self->_priv->schema;
    }
    /**  Get values */
    /* usefull for searching */
    public
    gchar **
    get_values(self, gsize *length)
    {
        gchar **ids = NULL;
        *length = 0;
        ids = stuffkeeper_data_schema_get_fields(self->_priv->schema, length); 
        if(ids)
        {
            gchar **retv = g_malloc0(((*length)+2)*sizeof(gchar *));
            int i;
            int entry =0;
            /** Add title to the value list */
            retv[0] = self_get_title(self);
            if(retv)
                entry++;
            /** iterate and add every available list */
            for(i=0;i<*length;i++)
            {
                gchar *data = self_get_string(self, ids[i]);  
                if(data)
                {
                    retv[entry] = data;
                    entry++;
                }
            }
            g_strfreev(ids);
            *length = entry;
            return retv;
        }
        return NULL; 
    }

    public
    G:Object *
    get_backend(self)
    {
        return G_OBJECT(self->_priv->skdb);
    }

}
