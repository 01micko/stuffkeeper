requires 2.0.10

%ph{
#include <glib/gstdio.h>
/* Save a changed item after 30 seconds */
#define SAVE_TIMEOUT 30000 
%}

%ph{
#include "debug.h"
#include "stuffkeeper-data-backend.h"
%}
%h{
#include <sqlite3.h>
#include "stuffkeeper-data-tag.h"
#include "stuffkeeper-data-schema.h"

        typedef enum _DbItemType {
            DB_ITEMS_TYPE_ID = 1,
            DB_ITEMS_TYPE_SCHEMA = 2,
            DB_ITEMS_TYPE_MTIME = 3,
            DB_ITEMS_TYPE_CTIME = 4,
            DB_ITEMS_TYPE_TAG = 5,
            DB_ITEMS_TYPE_NAME = 6,
            DB_ITEMS_TYPE_NAME_GENERATED_CACHE = 7

        }DbItemType;
        typedef enum _DbItemFieldType {
            DB_ITEMS_FIELD_TYPE_ID = 1,
            DB_ITEMS_FIELD_TYPE_TYPE = 3,
            DB_ITEMS_FIELD_TYPE_NAME = 4
        }DbItemFieldType;

%}

%{
    #include <stdio.h>
%}



class Stuffkeeper:Data:Item from G:Object 
{
    private gboolean changed = {FALSE};
    private StuffkeeperDataBackend *skdb = {NULL};
    private GList *tags = {NULL} destroywith g_list_free;

    private StuffkeeperDataSchema *schema = {NULL};

    private guint schema_field_removed = {0};
    private guint schema_field_changed = {0};

    private gint id = {0};
    private sqlite3 *sqlHandle = {NULL};
    /**
     * Signals 
     */
    public 
    signal last NONE (STRING)
    void
    item_changed(self, const gchar *field)
    {
        /* Mark the item changed */
        if(field)
        {

            if(stuffkeeper_data_schema_get_field_in_title(self->_priv->schema, field))
            { 
                self_title_cache_refresh(self);
                self_item_changed(self, NULL);
            }
        }
    }

    private
    signal last NONE (NONE)
    void
    item_tags_changed(self)
    {

    }
    /* Finalize functions */
    override (G:Object)
    void
    finalize (G:Object *obj)
    {
        Self *self = SELF(obj);

        if(self->_priv->schema_field_removed )
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema),self->_priv->schema_field_removed );
            self->_priv->schema_field_removed = 0; 
        }
        if(self->_priv->schema_field_changed )
        {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema),self->_priv->schema_field_changed );
            self->_priv->schema_field_changed = 0; 
        } 
        PARENT_HANDLER(obj);
    }

    /**
     * Functions to manage 
     */
    public
    void
    save_yourself(self)
    {
        debug_printf("Deprecated\n");
    }

    public
    void
    delete_yourself(self)
    {
        int result;
        char *error;
        char *query = NULL; 

        stuffkeeper_data_schema_remove_item(self->_priv->schema, G_OBJECT(self));

        GList *node = g_list_first(self->_priv->tags);
        for(;node;node = g_list_next(node))
        {
            stuffkeeper_data_tag_remove_item(STUFFKEEPER_DATA_TAG(node->data), G_OBJECT(self));
        }
        g_list_free(self->_priv->tags);
        self->_priv->tags = NULL;



        query = sqlite3_mprintf("DELETE FROM Items WHERE ItemId=%i",self->_priv->id);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            debug_printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        query =  sqlite3_mprintf("DELETE FROM ItemsFields WHERE ItemId=%i",self->_priv->id);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            debug_printf("failed: %s\n", error);                                                                  
        }
        sqlite3_free(query);

        self->_priv->id = 0;
    }

    /* Create new StuffkeeperDataBackend */
    public 
        StuffkeeperDataItem *
        new (G:Object *skdb, sqlite3 *sqlHandle,StuffkeeperDataSchema *schema)
        {

            Self *obj = GET_NEW;
            int result = 0;
            char *error = NULL;
            char *query  = NULL;
            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->sqlHandle = sqlHandle;
            /**
             * Insert the first item in the list
             */
            query = sqlite3_mprintf
                ("INSERT INTO 'Items' ('type','value')"
                 "values (%i,'%i');",
                 DB_ITEMS_TYPE_ID, -1);

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* Get the id of the insert, this is now the unique id for this field*/
            obj->_priv->id = sqlite3_last_insert_rowid(obj->_priv->sqlHandle);

            /* update the last inserted row */
            query = sqlite3_mprintf
                ("UPDATE Items SET ItemId='%i' WHERE id=%i and type=%i",
                 obj->_priv->id,obj->_priv->id, DB_ITEMS_TYPE_ID);
            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* creation time */
            query = sqlite3_mprintf
                ("INSERT INTO 'Items' ('ItemId','type','value')"
                 "values (%i,%i,'%i');",
                 obj->_priv->id,DB_ITEMS_TYPE_CTIME, (int)time(NULL));

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
            sqlite3_free(query);

            /* update mtime */
            query = sqlite3_mprintf
                ("INSERT INTO 'Items' ('ItemId','type','value')"
             "values (%i,%i,'%i');",
             obj->_priv->id,DB_ITEMS_TYPE_MTIME, (int)time(NULL));

            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed to update mtime: %s\n", error);
            }
            sqlite3_free(query);

            /* update schema*/
            obj->_priv->schema = schema;
            query = sqlite3_mprintf
                ("INSERT INTO 'Items' ('ItemId','type','value')"
                 "values (%i,%i,'%i');",
                 obj->_priv->id,DB_ITEMS_TYPE_SCHEMA, stuffkeeper_data_schema_get_id(schema));
            result = sqlite3_exec(obj->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed to set schema: %s\n", error);
            }
            sqlite3_free(query);


            /* Load schemas */
            obj->_priv->schema_field_removed = g_signal_connect_swapped(G_OBJECT(obj->_priv->schema), "schema-field-removed", 
                    G_CALLBACK(self_item_schema_field_removed), obj);
            obj->_priv->schema_field_changed = g_signal_connect_swapped(G_OBJECT(obj->_priv->schema), "schema-field-changed", 
                    G_CALLBACK(self_item_schema_field_changed), obj);









            stuffkeeper_data_schema_add_item(obj->_priv->schema, G_OBJECT(obj));

            return obj;
        }

    public
        StuffkeeperDataItem *
        open_from_id (G:Object *skdb, sqlite3 *sqlHandle,gint id,gint schemaid)
        {
            char *query;
            const char *tail;
            int r;
            sqlite3_stmt *stmt;
            Self *obj = GET_NEW;
            obj->_priv->skdb = STUFFKEEPER_DATA_BACKEND(skdb);
            obj->_priv->id = id;
            obj->_priv->sqlHandle = sqlHandle;

            /* Load the tags */

            query = sqlite3_mprintf("SELECT value FROM Items WHERE ItemId=%i and type=%i ORDER BY value ASC",
                    obj->_priv->id, DB_ITEMS_TYPE_TAG);
            r = sqlite3_prepare_v2(obj->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            sqlite3_free(query);
            if (r != SQLITE_OK)
            {
                debug_printf("Failed: %s\n", sqlite3_errmsg(obj->_priv->sqlHandle));
            }
            else
            {
                debug_printf("stepping through rows\n");
                while((r = sqlite3_step(stmt)) == SQLITE_ROW)
                {
                    int tagid = sqlite3_column_int(stmt, 0); 
                    StuffkeeperDataTag *tag = stuffkeeper_data_backend_add_tag(obj->_priv->skdb,tagid);
                    debug_printf("adding tagid: %i\n", tagid);
                    obj->_priv->tags = g_list_prepend(obj->_priv->tags, tag);
                    stuffkeeper_data_tag_add_item(tag, G_OBJECT(obj));
                }
            }
            sqlite3_finalize(stmt);
            /* Load schemas */
            obj->_priv->schema = stuffkeeper_data_backend_get_schema(obj->_priv->skdb, schemaid);
            obj->_priv->schema_field_removed = g_signal_connect_swapped(G_OBJECT(obj->_priv->schema), "schema-field-removed", 
                    G_CALLBACK(self_item_schema_field_removed), obj);
            obj->_priv->schema_field_changed = g_signal_connect_swapped(G_OBJECT(obj->_priv->schema), "schema-field-changed", 
                    G_CALLBACK(self_item_schema_field_changed), obj);
            stuffkeeper_data_schema_add_item(obj->_priv->schema, G_OBJECT(obj));

/*
            query = sqlite3_mprintf("SELECT value FROM Items WHERE ItemId=%i and type=%i ORDER BY value ASC",
                    obj->_priv->id, DB_ITEMS_TYPE_SCHEMA);
            r = sqlite3_prepare_v2(obj->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            sqlite3_free(query);
            if (r != SQLITE_OK)
            {
                debug_printf("Failed: %s\n", sqlite3_errmsg(obj->_priv->sqlHandle));
            }
            else
            {
                debug_printf("stepping through rows\n");
                if((r = sqlite3_step(stmt)) == SQLITE_ROW)
                {
                    int schemaid = sqlite3_column_int(stmt, 0); 
                    debug_printf("adding schemaid: %i\n", schemaid);
                    obj->_priv->schema = stuffkeeper_data_backend_get_schema(obj->_priv->skdb, schemaid);
                    obj->_priv->schema_field_removed = g_signal_connect_swapped(G_OBJECT(obj->_priv->schema), "schema-field-removed", 
                            G_CALLBACK(self_item_schema_field_removed), obj);
                    obj->_priv->schema_field_changed = g_signal_connect_swapped(G_OBJECT(obj->_priv->schema), "schema-field-changed", 
                            G_CALLBACK(self_item_schema_field_changed), obj);
                    stuffkeeper_data_schema_add_item(obj->_priv->schema, G_OBJECT(obj));
                }
            }
            sqlite3_finalize(stmt);
*/
            return obj;
        }

    /**
     * When a field in the schema is removed, removed the entry from the item.
     * Don't signal a change, (for now) This should be handled by the parent holding it.
     */
    private 
    void
    item_schema_field_removed(self, const char *id, StuffkeeperDataSchema *schema)
    {
        int result;
        char *error,*query;
        /* no field, create it */
        query = sqlite3_mprintf("DELETE FROM 'ItemsFields' WHERE ItemId=%i and FieldId=%q", 
                self->_priv->id,
                id);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            debug_printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        /* update mtime */
        self_update_mtime(self);

    }
    private 
    void
    item_schema_field_changed(self, const char *id, StuffkeeperDataSchema *schema)
    {
        /* update title */
        self_title_cache_refresh(self);
        self_item_changed(self, NULL);
    }

    /**************************************
     * Helper functions 
     **************************************/
  /**
     * Update mtime
     */


    private 
    void
    update_mtime(self)
    {
        char *query,*error;
        int result;
        /* modification time */
        query = sqlite3_mprintf
            ("UPDATE Items SET value='%i' WHERE ItemId=%i and Type=%i",
             (int)time(NULL),self->_priv->id,DB_ITEMS_TYPE_MTIME);

        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            debug_printf("failed to update mtime: %s\n", error);
        }
        sqlite3_free(query);
   }
    /* for tags */
    private 
        void
    items_add_field_integer(self,int fieldtype, const int title)
    {
        int result;
        char *error,*query;
        query = sqlite3_mprintf("INSERT INTO 'Items' ('ItemId','type','value')"
                "values (%i,%i,%i);",
                                    self->_priv->id,
                                    fieldtype,
                                    title);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            debug_printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        /* update mtime */
        self_update_mtime(self);
    }
    /* tags */
    private 
        void
    items_remove_field_integer(self,int fieldtype, int title)
    {
        int result;
        char *error,*query;
        /* no field, create it */
        query = sqlite3_mprintf("DELETE FROM 'Items' WHERE ItemId=%i and type=%i and value=%i", 
                self->_priv->id,
                fieldtype,
                title);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            debug_printf("failed: %s\n", error);
        }
        sqlite3_free(query);
        /* update mtime */
        self_update_mtime(self);
    }



    private 
        void
        items_set_field_string(self,int fieldtype, const gchar *title)
        {
            int result;
            char *error,*query,*val;
            val = self_items_get_field_string(self, fieldtype);
            /* no field, create it */
            if(!val) {
                query = sqlite3_mprintf("INSERT INTO 'Items' ('ItemId','type','value')"
                        "values (%i,%i,%Q);",
                        self->_priv->id,
                        fieldtype,
                        title);
            } else {
                /* if they are identical, do nothing */
                if(strcmp(title, val) == 0) {
                    g_free(val);
                    debug_printf("not updating\n");
                    return;
                }
                /* update the title */
                query = sqlite3_mprintf("UPDATE Items SET value=%Q WHERE ItemId=%i and type=%i", title, self->_priv->id,fieldtype);
                g_free(val);
            }
            result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
            sqlite3_free(query);
            /* update mtime */
            self_update_mtime(self);
        }
    private 
        gchar *
        items_get_field_string(self, int fieldtype)
        {
            char *retv = NULL;
            char *query = sqlite3_mprintf("SELECT value FROM Items WHERE ItemId=%i and type=%i", self->_priv->id,fieldtype);
            sqlite3_stmt *stmt;
            const char *tail;
            int r;
            r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            if (r == SQLITE_OK) {
                if((r = sqlite3_step(stmt)) == SQLITE_ROW) {
                    retv = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
                }
            }
            sqlite3_finalize(stmt);

            sqlite3_free(query);
            return retv; 
        }
    private 
        void
        items_set_field_integer(self,int fieldtype, const int title)
        {
            int result;
            char *error, *query;
            gboolean set; 
            int val;
            set = self_items_get_field_integer(self, fieldtype,&val);
            /* no field, create it */
            if(!set) {
                query = sqlite3_mprintf("INSERT INTO 'Items' ('ItemId','type','value')"
                        "values (%i,%i,%Q);",
                        self->_priv->id,
                        fieldtype,
                        title);
            } else {
                /* if they are identical, do nothing */
                if(val == title) {
                    debug_printf("not updating\n");
                    return;
                }
                /* update the title */
                query = sqlite3_mprintf("UPDATE Items SET value=%Q WHERE ItemId=%i and type=%i", title, self->_priv->id,fieldtype);
            }
            result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
            sqlite3_free(query);
            /* update mtime */
            self_update_mtime(self);
        }

    private 
        gboolean 
        items_get_field_integer(self, int fieldtype, int *out)
        {
            gboolean set = FALSE;
            char *query = sqlite3_mprintf("SELECT value FROM Items WHERE ItemId=%i and type=%i", self->_priv->id,fieldtype);
            sqlite3_stmt *stmt;
            const char *tail;
            int r;
            r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            if (r == SQLITE_OK)
            {
                if((r = sqlite3_step(stmt)) == SQLITE_ROW)
                {
                    *out =sqlite3_column_int(stmt, 0);
                    set = TRUE;
                }
            }
            sqlite3_finalize(stmt);

            sqlite3_free(query);
            return set; 
        }

    public
    int
    has_generated_title(self)
    {
        return stuffkeeper_data_schema_has_generated_title(self->_priv->schema);
    }

    /**
     * ID (ro)
     */
    public
        gint
        get_id(self)
        {
            return self->_priv->id;
        }


    /**
     * Title (rw)
     */
    public
        void
        set_title(self, const gchar *title)
        {

            if(stuffkeeper_data_schema_has_generated_title(self->_priv->schema) > 0)
            {
                printf("not allowed with a generated title\n");
            }
            else
            {
                self_items_set_field_string(self, DB_ITEMS_TYPE_NAME, title);
                self_item_changed(self,NULL);
            }
    }
    private
    gchar *
    generate_title(self)
    {
        gsize length = 0;
        gchar **retv;
        retv = stuffkeeper_data_schema_get_fields(self->_priv->schema,&length);
        if(retv)
        {
            int i=0;
            int first =0;
            gchar *ret = NULL;
            GString *string = g_string_new("");
            for(i=0;i<length;i++)
            {
                if(stuffkeeper_data_schema_get_field_in_title(self->_priv->schema, retv[i]))
                {
                    gchar *name=  self_get_string(self, retv[i]);
                    if(first && name && name[0] != '\0')
                    {
                        g_string_append(string," - ");
                    }
                    if(name && name[0] != '\0')
                    {
                        g_string_append(string, name);
                        g_free(name);
                    }
                    if(!first)
                        first = 1;
                }
            }
            if(!first)
                g_string_append(string, _("N/A"));

            ret = string->str;
            g_string_free(string, FALSE);
            g_strfreev(retv);
            return ret;
        }
        return g_strdup(_("N/A"));
    }
    private
    void
    title_cache_refresh(self)
    {
        int result;
        char *error,*query;
        char *value = self_generate_title(self);
        //printf("free title cache\n");
        /* no field, create it */
        query = sqlite3_mprintf("UPDATE 'Items' SET value=%Q WHERE ItemId=%i and type=%i", 
                                value,
                                self->_priv->id,
                                DB_ITEMS_TYPE_NAME_GENERATED_CACHE);
        g_free(value);
        result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
        if (result != SQLITE_OK) {
            debug_printf("failed: %s\n", error);
        }
        sqlite3_free(query);
    }

    public 
    gchar *
    get_title(self)
    {
        if(stuffkeeper_data_schema_has_generated_title(self->_priv->schema) > 0)
        {
            char *val= self_items_get_field_string(self, DB_ITEMS_TYPE_NAME_GENERATED_CACHE);
            if(val)
            {
                return val;
            }
//            printf("generate title\n");
            val = self_generate_title(self);
            self_items_set_field_string(self, DB_ITEMS_TYPE_NAME_GENERATED_CACHE, val);
            return val;
        }else
        {
            char *retv = self_items_get_field_string(self, DB_ITEMS_TYPE_NAME);
            if(!retv)
                retv = g_strdup(_("Failed to get title"));
            return retv;
        }
        return NULL;
    }
    /**
     * Creation Time (ro)
     */
    public 
        gint
        get_creation_time(self)
        {
            int val;
            self_items_get_field_integer(self, DB_ITEMS_TYPE_CTIME,&val);
            return val;
        }
    public 
        gint
        get_modification_time(self)
        {
            int val;
            self_items_get_field_integer(self, DB_ITEMS_TYPE_MTIME,&val);
            return val;
        }


    /**
     * Generic getting/setting items
     */
    /**
     * Setting getting helper functions 
     */    
    public
        gchar *
        get_string(self, const char *field)
        {
            char *retv = NULL;
            char *query = sqlite3_mprintf("SELECT value FROM ItemsFields WHERE ItemId=%i and FieldId=%q", 
                    self->_priv->id,
                    field);

            sqlite3_stmt *stmt;
            const char *tail;
            int r;
            r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            if (r == SQLITE_OK)
            {
                if((r = sqlite3_step(stmt)) == SQLITE_ROW)
                {
                    retv = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
                }
            }
            sqlite3_finalize(stmt);

            sqlite3_free(query);
            return retv; 

        }
    public 
        void
        set_string(self,const gchar *id, const gchar *title)
        {
            int result;
            char *error;
            char *query;
            char *val;
            val = self_get_string(self, id);
            /* no field, create it */
            if(!val)
            {
                query = sqlite3_mprintf("INSERT INTO 'ItemsFields' ('ItemId','FieldId','value')"
                        "values (%i,%q,%Q);",
                        self->_priv->id,
                        id,
                        title);
            }
            else{
                /* if they are identical, do nothing */
                if(strcmp(title, val) == 0)
                {
                    g_free(val);
                    debug_printf("not updating\n");
                    return;
                }
                /* update the title */
                query = sqlite3_mprintf("UPDATE ItemsFields SET value=%Q WHERE ItemId=%i and FieldId=%q", 
                        title, 
                        self->_priv->id,
                        id);
                g_free(val);
            }
            result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
            sqlite3_free(query);
            /* update mtime */
            self_update_mtime(self);
            /* signal that we changed */
            self_item_changed(self,id);
        }

    public
        gboolean
        get_integer_real(self, const char *field, int *out)
        {
            gboolean set = FALSE;
            char *query = sqlite3_mprintf("SELECT value FROM ItemsFields WHERE ItemId=%i and FieldId=%q", 
                    self->_priv->id,
                    field);

            sqlite3_stmt *stmt;
            const char *tail;
            int r;
            r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            if (r == SQLITE_OK)
            {
                if((r = sqlite3_step(stmt)) == SQLITE_ROW)
                {
                    *out =sqlite3_column_int(stmt, 0);
                    set = TRUE;
                }
            }
            sqlite3_finalize(stmt);

            sqlite3_free(query);
            return set; 
        }
    public
        int
        get_integer(self,  const char *field)
        {
            int val=0;
            self_get_integer_real(self, field, &val);
            return val;
        }

    public 
        void
        set_integer(self,const gchar *id, const int title)
        {
            int result;
            char *error;
            char *query;
            gboolean set;
            int val;
            set = self_get_integer_real(self, id,&val);
            /* no field, create it */
            if(!set)
            {
                query = sqlite3_mprintf("INSERT INTO 'ItemsFields' ('ItemId','FieldId','value')"
                        "values (%i,%q,%i);",
                        self->_priv->id,
                        id,
                        title);
            }
            else{
                /* if they are identical, do nothing */
                if(val == title)
                {
                    debug_printf("not updating\n");
                    return;
                }
                /* update the title */
                query = sqlite3_mprintf("UPDATE ItemsFields SET value=%i WHERE ItemId=%i and FieldId=%q", 
                        title, 
                        self->_priv->id,
                        id);
            }
            result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
            if (result != SQLITE_OK) {
                debug_printf("failed: %s\n", error);
            }
        sqlite3_free(query);
        /* update mtime */
        self_update_mtime(self);
        /* signal that we changed */
        self_item_changed(self,id);
    }

    public
        gint 
    get_boolean(self, const gchar *field)
    {
        return self_get_integer(self, field); 
    }

    public 
    void
    set_boolean(self, const gchar *field, const gint value)
    {
        self_set_integer(self, field,value);
        self_item_changed(self,field);
    }

    public
        gchar **
    get_list(self, const gchar *field,gsize *size)
    {
        int fields =-1;
        char *query;
        gchar **retv = NULL;
        int i=0;
        /* count the number of fields */
        query = sqlite3_mprintf("SELECT COUNT(*) FROM ItemsFields WHERE ItemId=%i and FieldId=%q",self->_priv->id,field);
        sqlite3_stmt *stmt;
        const char *tail;
        int r;
        r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        if (r == SQLITE_OK)
        {
            if((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                fields = sqlite3_column_int(stmt, 0);
            }
        }
        else
        {
            debug_printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
        }
        sqlite3_finalize(stmt);
        sqlite3_free(query);
        debug_printf("%i fields found\n",fields);
        /* if no rows, return */
        if(fields <= 0)
        {
            *size = 0;
            return NULL;
        }
        /* get the rows, ordered */
        retv = g_malloc0((fields+1)*sizeof(gchar *));
        query = sqlite3_mprintf("SELECT value FROM ItemsFields WHERE ItemId=%i and FieldId=%q ORDER BY id ASC",
                self->_priv->id,
                field
                );

        r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
        sqlite3_free(query);
        if (r != SQLITE_OK)
        {
            debug_printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
        }
        else
        {
            debug_printf("stepping through rows\n");
            while((r = sqlite3_step(stmt)) == SQLITE_ROW)
            {
                retv[i] = g_strdup((gchar *)sqlite3_column_text(stmt, 0));
                debug_printf("adding id: %s\n", retv[i]);
                i++;
            }
        }
        sqlite3_finalize(stmt);

        *size = fields;
        return retv;

    }

    public 
        void
        set_list(self, const gchar *field, const gchar **value, gsize length)
        {
            gint i;
            /* remove old fields */
            self_item_schema_field_removed(self, field, NULL);
            for(i=0;i<length;i++)
            {
                int result;
                char *error,*query;
                query = sqlite3_mprintf("INSERT INTO 'ItemsFields' ('ItemId','FieldId','value')"
                        "values (%i,%q,%Q);",
                        self->_priv->id,
                        field,
                        value[i]);
                result = sqlite3_exec(self->_priv->sqlHandle, query, NULL, NULL, &error);
                if (result != SQLITE_OK) {
                    debug_printf("failed: %s\n", error);
                }
                sqlite3_free(query);
            }
            /* now add everything */
            self_item_changed(self,field);
        }

    /**
     * Tags
     */
    public
        gboolean
        has_tag(self, const StuffkeeperDataTag *tag)
        {
            GList *node = g_list_find(self->_priv->tags, tag);

            return (node != NULL)?TRUE:FALSE;
        }
    public
        void
        add_tag(self, StuffkeeperDataTag *tag)
        {
            self->_priv->tags = g_list_append(self->_priv->tags, tag);
            self_items_add_field_integer(self, DB_ITEMS_TYPE_TAG, stuffkeeper_data_tag_get_id(tag));
            self_item_changed(self,NULL);
            self_item_tags_changed(self);
            stuffkeeper_data_tag_add_item(tag,G_OBJECT(self));
        }
    public
        void
        remove_tag(self, StuffkeeperDataTag *tag)
        {
            self->_priv->tags = g_list_remove(self->_priv->tags, tag);
            self_items_remove_field_integer(self, DB_ITEMS_TYPE_TAG, stuffkeeper_data_tag_get_id(tag));
            self_item_changed(self,NULL);
            self_item_tags_changed(self);
            stuffkeeper_data_tag_remove_item(tag, G_OBJECT(self));
        }
    public
    GList * 
    get_tags(self)
    {
        return g_list_copy(self->_priv->tags);
    }
    /* Schema */
    public
        StuffkeeperDataSchema *
        get_schema(self)
        {
            return self->_priv->schema;
        }

    /**  has value */
public
        gboolean
        has_value_exact(self, const gchar *value)
        {
            int fields =0;
            char *query;
            sqlite3_stmt *stmt;
            const char *tail;
            int r;
            /* count the number of fields */
            query = sqlite3_mprintf("SELECT COUNT(*) FROM ItemsFields WHERE ItemId=%i and value LIKE '%q'",self->_priv->id,value);
            r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            if (r == SQLITE_OK)
            {
                if((r = sqlite3_step(stmt)) == SQLITE_ROW)
                {
                    fields = sqlite3_column_int(stmt, 0);
                }
            }
            else
            {
                debug_printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
            }
            sqlite3_finalize(stmt);
            if(fields > 0)
                return TRUE; 
            /* count the number of fields */
            query = sqlite3_mprintf("SELECT COUNT(*) FROM Items WHERE ItemId=%i and value LIKE '%q'",self->_priv->id,value);
            r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            if (r == SQLITE_OK)
            {
                if((r = sqlite3_step(stmt)) == SQLITE_ROW)
                {
                    fields = sqlite3_column_int(stmt, 0);
                }
            }
            else
            {
                debug_printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
            }
            sqlite3_finalize(stmt);
            return (fields> 0);
        }

    /* usefull for searching */
    public
        gboolean
        has_value(self, const gchar *value)
        {
            int fields =0;
            char *query;
            sqlite3_stmt *stmt;
            const char *tail;
            int r;
            /* count the number of fields */
            query = sqlite3_mprintf("SELECT COUNT(*) FROM ItemsFields WHERE ItemId=%i and value LIKE '%%%q%%'",self->_priv->id,value);
            r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            if (r == SQLITE_OK)
            {
                if((r = sqlite3_step(stmt)) == SQLITE_ROW)
                {
                    fields = sqlite3_column_int(stmt, 0);
                }
            }
            else
            {
                debug_printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
            }
            sqlite3_finalize(stmt);
            if(fields > 0)
                return TRUE; 
            /* count the number of fields */
            query = sqlite3_mprintf("SELECT COUNT(*) FROM Items WHERE ItemId=%i and value LIKE '%%%q%%'",self->_priv->id,value);
            r = sqlite3_prepare_v2(self->_priv->sqlHandle, query, -1,  &stmt,  &tail);
            if (r == SQLITE_OK)
            {
                if((r = sqlite3_step(stmt)) == SQLITE_ROW)
                {
                    fields = sqlite3_column_int(stmt, 0);
                }
            }
            else
            {
                debug_printf("Failed: %s\n", sqlite3_errmsg(self->_priv->sqlHandle));
            }
            sqlite3_finalize(stmt);
            return (fields> 0);
        }

    public
    G:Object *
    get_backend(self)
    {
        return G_OBJECT(self->_priv->skdb);
    }

}
