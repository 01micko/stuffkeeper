requires 2.0.10

%h{
#include <gtk/gtk.h>
#include <glib/gi18n.h>
#include "debug.h"
#include "stuffkeeper-data-item.h"
#include "stuffkeeper-data-label.h"
#include "stuffkeeper-data-entry.h"
#include "stuffkeeper-data-password.h"
#include "stuffkeeper-data-boolean.h"
#include "stuffkeeper-data-spinbutton.h"
#include "stuffkeeper-data-rating.h"
#include "stuffkeeper-data-list2.h"
#include "stuffkeeper-data-text.h"
#include "stuffkeeper-data-image.h"
#include "stuffkeeper-data-link.h"
#include "stuffkeeper-data-date2.h"
#include "stuffkeeper-data-taglist2.h"
#include "stuffkeeper-data-expander.h"
#include "stuffkeeper-data-files.h"
%}

class Stuffkeeper:Show:Item from Gtk:Event:Box
{
    private StuffkeeperDataSchema *schema = {NULL};
    private StuffkeeperDataItem *item = {NULL};

    private GtkWidget *vbox = {gtk_vbox_new(FALSE, 6)};
    /* list */
    private gchar **retv = NULL;
    private gsize length = 0;
    /* signals */
    private guint schema_field_added = 0;
    private guint schema_field_removed = 0;

    private guint schema_field_changed = 0;
    private guint schema_fields_reordered = 0;
    private GtkSizeGroup *group = {NULL} destroywith g_object_unref;

    private
    void
    reload_data(self)
    {
        int i,last_type = -1;//, reuse = FALSE;
        GtkWidget *label1,*hbox = NULL;
        GtkWidget *sub_part = NULL;
        GList *node, *list = gtk_container_get_children(GTK_CONTAINER(self->_priv->vbox));
        GQueue *queue = g_queue_new();

        /* removing old widgets */
        for(node =list; node; node = g_list_next(node)) {
            gtk_widget_destroy(GTK_WIDGET(node->data));
        }
        g_list_free(list);

        /* group */
        if(self->_priv->group)
            g_object_unref(self->_priv->group);
        self->_priv->group = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);

        g_queue_push_head(queue, self->_priv->vbox);
        for(i=0;i<self->_priv->length;i++) 
        {
            GtkWidget *vbox = g_queue_peek_head(queue);
            FieldType type = stuffkeeper_data_schema_get_field_type(self->_priv->schema, self->_priv->retv[i]);
            label1 = NULL;
            int reuse = TRUE;

            if(type != FIELD_TYPE_END){
                reuse = FALSE;
                hbox = gtk_hbox_new(FALSE, 6);
            }
            /* Title */
            if(type < FIELD_TYPE_EXPANDER || type >= FIELD_TYPE_FILES)// != FIELD_TYPE_EXPANDER && type != FIELD_TYPE_END_EXPANDER)
            {
                label1 = (GtkWidget *)stuffkeeper_data_label_new_schema_field(STUFFKEEPER_DATA_SCHEMA(self->_priv->schema), self->_priv->retv[i]);
                gtk_misc_set_alignment(GTK_MISC(label1), 1,0.5);
                gtk_widget_modify_fg(GTK_WIDGET(label1), GTK_STATE_NORMAL, &(GTK_WIDGET(self)->style->black));
                gtk_box_pack_start(GTK_BOX(hbox), label1, FALSE, TRUE, 0);
                gtk_size_group_add_widget(self->_priv->group, label1);
            }
            if(type == FIELD_TYPE_STRING) {
                label1 = stuffkeeper_data_entry_new(self->_priv->item,self->_priv->retv[i]);
            } else if (type == FIELD_TYPE_INTEGER) {
                label1 = stuffkeeper_data_spinbutton_new(self->_priv->item,self->_priv->retv[i]);
            } else if (type == FIELD_TYPE_VPACKING) {
                GtkWidget *box;

                label1 = box = gtk_vbox_new(FALSE, 6);
                g_queue_push_head(queue, box);
            } else if (type == FIELD_TYPE_HPACKING) {
                GtkWidget *box;
                label1 =box = gtk_hbox_new(TRUE, 6);
                g_queue_push_head(queue, box);
            } else if (type == FIELD_TYPE_END|| type == FIELD_TYPE_END_EXPANDER) {
                if(g_queue_get_length(queue) > 1)
                    g_queue_pop_head(queue);
                else
                    printf("Popped one to many\n");
            }else if (type == FIELD_TYPE_BOOLEAN) {
                label1 = stuffkeeper_data_boolean_new(self->_priv->item,self->_priv->retv[i]);
            }else if (type == FIELD_TYPE_RATING) {
                label1 = stuffkeeper_data_rating_new(self->_priv->item,self->_priv->retv[i]);
            }else if (type == FIELD_TYPE_LIST) {
                gtk_misc_set_alignment(GTK_MISC(label1), 1,0);
                label1 = stuffkeeper_data_list2_new(self->_priv->item,self->_priv->retv[i]);
            }else if (type == FIELD_TYPE_TEXT) {
                gtk_misc_set_alignment(GTK_MISC(label1), 1,0);
                label1 = stuffkeeper_data_text_new(self->_priv->item,self->_priv->retv[i]);                    
            }else if (type == FIELD_TYPE_IMAGE) {
                gtk_misc_set_alignment(GTK_MISC(label1), 1,0);
                label1 = stuffkeeper_data_image_new(self->_priv->item,self->_priv->retv[i]);                    
            }else if (type == FIELD_TYPE_LINK) {
                label1 = stuffkeeper_data_link_new(self->_priv->item,self->_priv->retv[i]);                    
            }else if (type == FIELD_TYPE_DATE) {
                label1 = stuffkeeper_data_date2_new(self->_priv->item,self->_priv->retv[i]);                    
            }else if (type == FIELD_TYPE_EXPANDER) {
                GtkWidget *ali = gtk_alignment_new(0.0,0,1,1);
                gtk_alignment_set_padding(GTK_ALIGNMENT(ali), 0,0,12,0);
                label1 = stuffkeeper_data_expander_new(self->_priv->item,self->_priv->retv[i]);                    
                sub_part = gtk_vbox_new(FALSE, 6);
                gtk_container_add(GTK_CONTAINER(ali), sub_part);
                gtk_container_add(GTK_CONTAINER(label1), ali);
                g_queue_push_head(queue, sub_part);
	    }else if (type == FIELD_TYPE_PASSWORD) {
		    label1 = stuffkeeper_data_password_new(self->_priv->item,self->_priv->retv[i]);
	    }else if (type == FIELD_TYPE_FILES) {
            gtk_misc_set_alignment(GTK_MISC(label1), 1,0);
            label1 = (GtkWidget *)stuffkeeper_data_files_new(self->_priv->item,self->_priv->retv[i]);
        }else {
                label1 = gtk_label_new("not supported\n");
        }
            if(label1){
                gtk_box_pack_start(GTK_BOX(hbox), label1, TRUE, TRUE, 0);
            }
            if(!reuse){
                if(GTK_IS_HBOX(vbox))//GTK_IS_VBOX(label1))
                    gtk_box_pack_start(GTK_BOX(vbox), hbox, TRUE, TRUE, 0);
                else
                    gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
            }
            last_type = type;
        }
        /* Title */
        hbox = gtk_hbox_new(FALSE, 6);
        label1 = gtk_label_new("");
        gtk_label_set_markup(GTK_LABEL(label1),_("<b>Tags</b>"));
        gtk_widget_modify_fg(GTK_WIDGET(label1), GTK_STATE_NORMAL, &(GTK_WIDGET(self)->style->black));
        gtk_misc_set_alignment(GTK_MISC(label1), 1,0.5);
        gtk_size_group_add_widget(self->_priv->group, label1);
        gtk_box_pack_start(GTK_BOX(hbox), label1, FALSE, TRUE, 0);
        /* Tag list */
        label1 =stuffkeeper_data_taglist2_new(self->_priv->item); 
        gtk_box_pack_start(GTK_BOX(hbox), label1, TRUE, TRUE, 0);

        gtk_box_pack_start(GTK_BOX(self->_priv->vbox), hbox, FALSE, TRUE, 0);
        gtk_widget_show_all(GTK_WIDGET(self));
        g_queue_free(queue);
    }

    private
    void
    fields_reordered(self, StuffkeeperDataSchema *schema)
    {
        self_field_changed(self, NULL, schema);
    }
    private 
    void
    field_changed(self, const gchar *id, StuffkeeperDataSchema *schema)
    {
        /* free old values */
        if(self->_priv->retv)
            g_strfreev(self->_priv->retv);
        self->_priv->length = 0;
        /* get new fields */
        self->_priv->retv = stuffkeeper_data_schema_get_fields(schema, &(self->_priv->length));
        /* reload */
        self_reload_data(self);
    }
    /**
     * Get the widget 
     */
    public
    Gtk:Widget * 
    new(Stuffkeeper:Data:Item *item)
    {
        Self *self = GET_NEW;
//        gtk_box_set_spacing(GTK_BOX(self), 6);
        gtk_container_add(GTK_CONTAINER(self), self->_priv->vbox);
        gtk_container_set_border_width(GTK_CONTAINER(self->_priv->vbox), 6);
        /* Get the schema  */
        self->_priv->schema = stuffkeeper_data_item_get_schema(item);
        /* Get the item */
        self->_priv->item = item;
        /* Signals */
        self->_priv->schema_field_added =   g_signal_connect_swapped(G_OBJECT(self->_priv->schema),  
                "schema-field-added",
                G_CALLBACK(self_field_changed),
                self);
        self->_priv->schema_field_removed = g_signal_connect_swapped(G_OBJECT(self->_priv->schema),
                "schema-field-removed",
                G_CALLBACK(self_field_changed),
                self);

        self->_priv->schema_field_changed= g_signal_connect_swapped(G_OBJECT(self->_priv->schema),
                "schema-field-changed",
                G_CALLBACK(self_field_changed),
                self);
        self->_priv->schema_fields_reordered= g_signal_connect_swapped(G_OBJECT(self->_priv->schema),
                "schema-fields-reordered",
                G_CALLBACK(self_fields_reordered),
                self);

        gtk_widget_modify_bg(GTK_WIDGET(self), GTK_STATE_NORMAL, &(GTK_WIDGET(self)->style->white));

        /* update */
        self_field_changed(self, NULL, self->_priv->schema);
        return GTK_WIDGET(self);
    }

    /**
     * Destroying
     */
    override (G:Object)
    void
    finalize(G:Object *obj)
    {
        Self *self = SELF(obj);
        if(self->_priv->schema_field_added) {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->schema_field_added);
            self->_priv->schema_field_added = 0;
        }
        if(self->_priv->schema_field_removed) {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->schema_field_removed);
            self->_priv->schema_field_removed = 0;
        }
        if(self->_priv->schema_field_changed) {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->schema_field_changed);
            self->_priv->schema_field_changed = 0;
        }
        if(self->_priv->schema_fields_reordered) {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->schema_fields_reordered);
            self->_priv->schema_fields_reordered = 0;
        }
        if(self->_priv->retv)
        {
            g_strfreev(self->_priv->retv);
            self->_priv->retv = NULL;
        }
        if(self->_priv->group)
        {
            g_object_unref(self->_priv->group);
            self->_priv->group = NULL;
        }
        PARENT_HANDLER(obj);
    }
}
