requires 2.0.10

%h{
#include <gtk/gtk.h>
#include <glib/gi18n.h>
#include "debug.h"
#include "stuffkeeper-data-item.h"
#include "stuffkeeper-data-label.h"
#include "stuffkeeper-data-entry.h"
#include "stuffkeeper-data-boolean.h"
#include "stuffkeeper-data-spinbutton.h"
#include "stuffkeeper-data-rating.h"
#include "stuffkeeper-data-list2.h"
#include "stuffkeeper-data-text.h"
#include "stuffkeeper-data-image.h"
#include "stuffkeeper-data-link.h"
#include "stuffkeeper-data-date.h"
#include "stuffkeeper-data-taglist2.h"
#include "stuffkeeper-data-expander.h"
%}

class StuffKeeper:Show:Item from Gtk:VBox
{
    private StuffKeeperDataSchema *schema = {NULL};
    private StuffKeeperDataItem *item = {NULL};
    /* list */
    private gchar **retv = NULL;
    private gsize length = 0;
    /* signals */
    private guint schema_field_added = 0;
    private guint schema_field_removed = 0;

    private guint schema_field_changed = 0;
    private GtkSizeGroup *group = {NULL} destroywith g_object_unref;

    private
    void
    reload_data(self)
    {
        int i,last_type = -1;//, reuse = FALSE;
        GtkWidget *label1,*hbox = NULL;
        GtkWidget *sub_part = NULL;
        GList *node, *list = gtk_container_get_children(GTK_CONTAINER(self));
        GQueue *queue = g_queue_new();

        /* removing old widgets */
        for(node =list; node; node = g_list_next(node)) {
            gtk_widget_destroy(GTK_WIDGET(node->data));
        }
        g_list_free(list);

        /* group */
        if(self->_priv->group)
            g_object_unref(self->_priv->group);
        self->_priv->group = gtk_size_group_new(GTK_SIZE_GROUP_HORIZONTAL);

        g_queue_push_head(queue, self);
        g_object_set_data(self, "split", GINT_TO_POINTER(0));
        for(i=0;i<self->_priv->length;i++) 
        {
            GtkWidget *vbox = g_queue_peek_head(queue);
            gint split = GPOINTER_TO_INT(g_object_get_data(vbox, "split"));
            FieldType type = stuffkeeper_data_schema_get_field_type(self->_priv->schema, self->_priv->retv[i]);
            label1 = NULL;
  //          reuse = TRUE;

            if(!split){//(last_type != FIELD_TYPE_BOOLEAN || last_type != type) {
//                reuse = FALSE;
                hbox = gtk_hbox_new(FALSE, 6);
            }
            /* Title */
            if(type < FIELD_TYPE_EXPANDER)// != FIELD_TYPE_EXPANDER && type != FIELD_TYPE_END_EXPANDER)
            {
                label1 = (GtkWidget *)stuffkeeper_data_label_new_schema_field(STUFFKEEPER_DATA_SCHEMA(self->_priv->schema), self->_priv->retv[i]);
                gtk_misc_set_alignment(GTK_MISC(label1), 1,0.5);
                gtk_box_pack_start(GTK_BOX(hbox), label1, FALSE, TRUE, 0);
                gtk_size_group_add_widget(self->_priv->group, label1);
            }
            if(type == FIELD_TYPE_STRING) {
                label1 = stuffkeeper_data_entry_new(self->_priv->item,self->_priv->retv[i]);
            } else if (type == FIELD_TYPE_INTEGER) {
                label1 = stuffkeeper_data_spinbutton_new(self->_priv->item,self->_priv->retv[i]);
            } else if (type == FIELD_TYPE_VSPLIT) {
                g_object_set_data(vbox, "split", GINT_TO_POINTER(1));
                split = TRUE;
            } else if (type == FIELD_TYPE_END_SPLIT) {
                g_object_set_data(vbox, "split", GINT_TO_POINTER(0));
                split = FALSE;
            }else if (type == FIELD_TYPE_BOOLEAN) {
                label1 = stuffkeeper_data_boolean_new(self->_priv->item,self->_priv->retv[i]);
                /* reset */
//                if(reuse)
  //                  type = -1;
            }else if (type == FIELD_TYPE_RATING) {
                label1 = stuffkeeper_data_rating_new(self->_priv->item,self->_priv->retv[i]);
            }else if (type == FIELD_TYPE_LIST) {
                gtk_misc_set_alignment(GTK_MISC(label1), 1,0);
                label1 = stuffkeeper_data_list2_new(self->_priv->item,self->_priv->retv[i]);
            }else if (type == FIELD_TYPE_TEXT) {
                gtk_misc_set_alignment(GTK_MISC(label1), 1,0);
                label1 = stuffkeeper_data_text_new(self->_priv->item,self->_priv->retv[i]);                    
            }else if (type == FIELD_TYPE_IMAGE) {
                gtk_misc_set_alignment(GTK_MISC(label1), 1,0);
                label1 = stuffkeeper_data_image_new(self->_priv->item,self->_priv->retv[i]);                    
            }else if (type == FIELD_TYPE_LINK) {
                label1 = stuffkeeper_data_link_new(self->_priv->item,self->_priv->retv[i]);                    
            }else if (type == FIELD_TYPE_DATE) {
                label1 = stuffkeeper_data_date_new(self->_priv->item,self->_priv->retv[i]);                    
            }else if (type == FIELD_TYPE_EXPANDER) {
                GtkWidget *ali = gtk_alignment_new(0.0,0,1,1);
                GtkWidget *frame = gtk_frame_new(NULL);
                gtk_alignment_set_padding(GTK_ALIGNMENT(ali), 0,0,12,0);
                label1 = stuffkeeper_data_expander_new(self->_priv->item,self->_priv->retv[i]);                    
                sub_part = gtk_vbox_new(FALSE, 6);
                gtk_container_add(GTK_CONTAINER(ali), frame);
                gtk_container_add(GTK_CONTAINER(frame), sub_part);
                gtk_container_add(GTK_CONTAINER(label1), ali);


                g_object_set_data(sub_part, "split", GINT_TO_POINTER(0));
                split = FALSE;
                g_queue_push_head(queue, sub_part);
            }else if (type == FIELD_TYPE_END_EXPANDER) {
                label1 = NULL; 
                sub_part = NULL;
                g_queue_pop_head(queue);
                split = FALSE;
            }else {
                label1 = gtk_label_new("not supported\n");
            }
            if(label1)
                gtk_box_pack_start(GTK_BOX(hbox), label1, TRUE, TRUE, 0);
            //if(!reuse)
            if(!split){
                /*
                if(sub_part && type != FIELD_TYPE_EXPANDER)
                    gtk_box_pack_start(GTK_BOX(sub_part), hbox, FALSE, TRUE, 0);
                else
                    gtk_box_pack_start(GTK_BOX(self), hbox, FALSE, TRUE, 0);
                    */
                gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, TRUE, 0);
            }
            last_type = type;
        }
        /* Title */
        hbox = gtk_hbox_new(FALSE, 6);
        label1 = gtk_label_new("");
        gtk_label_set_markup(GTK_LABEL(label1),_("<b>Tags</b>"));
        gtk_misc_set_alignment(GTK_MISC(label1), 1,0.5);
        gtk_size_group_add_widget(self->_priv->group, label1);
        gtk_box_pack_start(GTK_BOX(hbox), label1, FALSE, TRUE, 0);
        /* Tag list */
        label1 =stuffkeeper_data_taglist2_new(self->_priv->item); 
        gtk_box_pack_start(GTK_BOX(hbox), label1, TRUE, TRUE, 0);

        gtk_box_pack_start(GTK_BOX(self), hbox, FALSE, TRUE, 0);
        gtk_widget_show_all(GTK_WIDGET(self));
        g_queue_free(queue);
    }

    private 
    void
    field_changed(self, const gchar *id, StuffKeeperDataSchema *schema)
    {
        /* free old values */
        if(self->_priv->retv)
            g_strfreev(self->_priv->retv);
        self->_priv->length = 0;
        /* get new fields */
        self->_priv->retv = stuffkeeper_data_schema_get_fields(schema, &(self->_priv->length));
        /* reload */
        self_reload_data(self);
    }
    /**
     * Get the widget 
     */
    public
    Gtk:Widget * 
    new(StuffKeeper:Data:Item *item)
    {
        Self *self = GET_NEW;
        gtk_box_set_spacing(GTK_BOX(self), 6);
        /* Get the schema  */
        self->_priv->schema = stuffkeeper_data_item_get_schema(item);
        /* Get the item */
        self->_priv->item = item;
        /* Signals */
        self->_priv->schema_field_added =   g_signal_connect_swapped(G_OBJECT(self->_priv->schema),  
                "schema-field-added",
                G_CALLBACK(self_field_changed),
                self);
        self->_priv->schema_field_removed = g_signal_connect_swapped(G_OBJECT(self->_priv->schema),
                "schema-field-removed",
                G_CALLBACK(self_field_changed),
                self);

        self->_priv->schema_field_changed= g_signal_connect_swapped(G_OBJECT(self->_priv->schema),
                "schema-field-changed",
                G_CALLBACK(self_field_changed),
                self);

        /* update */
        self_field_changed(self, NULL, self->_priv->schema);
        return GTK_WIDGET(self);
    }

    /**
     * Destroying
     */
    override (G:Object)
    void
    finalize(G:Object *obj)
    {
        Self *self = SELF(obj);
        if(self->_priv->schema_field_added) {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->schema_field_added);
            self->_priv->schema_field_added = 0;
        }
        if(self->_priv->schema_field_removed) {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->schema_field_removed);
            self->_priv->schema_field_removed = 0;
        }
        if(self->_priv->schema_field_changed) {
            g_signal_handler_disconnect(G_OBJECT(self->_priv->schema), self->_priv->schema_field_changed);
            self->_priv->schema_field_changed = 0;
        }
        if(self->_priv->retv)
        {
            g_strfreev(self->_priv->retv);
            self->_priv->retv = NULL;
        }
        if(self->_priv->group)
        {
            g_object_unref(self->_priv->group);
            self->_priv->group = NULL;
        }
        PARENT_HANDLER(obj);
    }
}
