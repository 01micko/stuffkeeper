requires 2.0.10

%h{
#include <gtk/gtk.h>
#include <glib/gi18n.h>
#include <glade/glade.h>
#include <config.h>
#include "stuffkeeper-data-backend.h"
#include "stuffkeeper-data-schema.h"
#include "stuffkeeper-data-item.h"
%}

class StuffKeeper:Export:CSV from G:Object
{
    private StuffKeeper:Data:Backend *skdb = {NULL};
    private GladeXML *xml;

    public
    G:Object *
    new(StuffKeeperDataBackend *skdb, GtkListStore *store )
    {
        GtkWidget *dialog = NULL;
        Self *self = GET_NEW;
        GtkWidget *wid;
        GtkCellRenderer *renderer;
        /**
         * Open the dialog 
         */
        self->_priv->xml = glade_xml_new(PACKAGE_DATADIR"/stuffkeeper.glade","export_csv",NULL);
        dialog = glade_xml_get_widget(self->_priv->xml, "export_csv");
        /* header */
        g_signal_connect_swapped(G_OBJECT(glade_xml_get_widget(self->_priv->xml, "event_box_header")), 
                "style-set",
                G_CALLBACK(self_style_set), 
                self);

        wid = glade_xml_get_widget(self->_priv->xml, "cb_type");
        gtk_combo_box_set_model(GTK_COMBO_BOX(wid), GTK_TREE_MODEL(store));
        gtk_combo_box_set_active(GTK_COMBO_BOX(wid), 0);
        renderer = gtk_cell_renderer_text_new();
        gtk_cell_layout_pack_start(GTK_CELL_LAYOUT(wid),renderer, TRUE);
        gtk_cell_layout_add_attribute(GTK_CELL_LAYOUT(wid),renderer, "text",1 );
        
        gtk_widget_show_all(GTK_WIDGET(dialog));
        /* */
        g_signal_connect_swapped(G_OBJECT(dialog), "response", G_CALLBACK(self_response), self);
        return G_OBJECT(self); 
    }
    /**
     * export
     */
    private
    void
    export_to_csv(self)
    {
        gboolean do_header = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(glade_xml_get_widget(self->_priv->xml,"ckb_header"))); 
        const gchar *filename = gtk_entry_get_text(GTK_ENTRY(glade_xml_get_widget(self->_priv->xml,"filename_entry")));
        gchar *directory = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(glade_xml_get_widget(self->_priv->xml,"file_chooser_button")));
        GtkWidget *cb = glade_xml_get_widget(self->_priv->xml, "cb_type"); 
        GtkTreeIter iter;
        GtkTreeModel *model = gtk_combo_box_get_model(GTK_COMBO_BOX(cb));
        if(gtk_combo_box_get_active_iter(GTK_COMBO_BOX(cb),&iter))
        {
            StuffKeeperDataSchema *schema = NULL;
            gchar *path = g_build_path(G_DIR_SEPARATOR_S, directory, filename, NULL);

            gtk_tree_model_get(model, &iter,3, &schema, -1); 

            self_dump_to_file(path, schema,do_header);

            printf("path: %s\n", path);
            g_free(path);
        }
        g_free(directory);
    }
    /**
     * Response
     */
    private
    void
    response(self, int response, GtkWidget *dialog )
    {
        switch(response)
        {
            case 1:
                self_export_to_csv(self);
            default:
                break;
        }
        gtk_widget_destroy(GTK_WIDGET(dialog));
        g_object_unref(self);
    }

    /**
     * Utility
     */
    public
    gchar *
    strescape(const gchar *string, const gchar *file)
    {
        gchar *retv= NULL;
        int length=0,i,j;
        for(i=0;string && string[i];i++)
        {
            if(string[i] == '"')
                length++;
            length++;    
        }
        retv = g_malloc0((length+1)*sizeof(char*));
        j=0;
        for(i=0;string[i];i++)
        {
            retv[j]=string[i];
            if(string[i] == '"')
            {
                j++;
                retv[j]='"';
            }
            j++;
        }
        return retv;
    }

    /**
     * header 
     */

    private
    void
    style_set(self, GtkStyle *style, GtkWidget *wid)
    {
        g_signal_handlers_block_by_func(G_OBJECT(wid), self_style_set,self);
        gtk_widget_modify_bg(wid,
                GTK_STATE_NORMAL, 
                &((wid)->style->bg[GTK_STATE_SELECTED]));
        gtk_widget_modify_text(glade_xml_get_widget(self->_priv->xml, "label_title"), 
                GTK_STATE_NORMAL, 
                &((wid)->style->text[GTK_STATE_SELECTED]));
        gtk_widget_modify_fg(glade_xml_get_widget(self->_priv->xml, "label_title"), 
                GTK_STATE_NORMAL, 
                &((wid)->style->fg[GTK_STATE_SELECTED]));
        g_signal_handlers_unblock_by_func(G_OBJECT(wid), self_style_set,self);
    }
    /**
     * Handler to free data when object is destroyed
     */
    override (G:Object)
        void
        finalize (G:Object *obj)
        {
            //Self *self = SELF(obj);
            PARENT_HANDLER(obj);
        }

    /**
     * actual work is done here
     */
    private
    void
    dump_to_file(const gchar *path, StuffKeeperDataSchema *schema, gboolean print_header)
    {
        GList *items = NULL;
        GError *err = NULL;
        GIOChannel *gio = g_io_channel_new_file(path, "w", &err);
        if(err)
        {
            g_error_free(err);
            return;
        }
        if(print_header)
        {
            gsize length = 0;
            gchar **fields =  stuffkeeper_data_schema_get_fields(schema, &length);
            int i;
            for(i=0;i<length;i++) 
            {
                char *name = stuffkeeper_data_schema_get_field_name(schema,fields[i]); 
                g_io_channel_write_chars(gio, "\"", 1, NULL, NULL);
                if(name)
                {
                    gchar *escaped = self_strescape(name,NULL);
                    g_io_channel_write_chars(gio, escaped, -1, NULL, NULL);
                    g_free(escaped);
                }
                g_io_channel_write_chars(gio, "\"", 1, NULL, NULL);
                if(i< (length-1))
                {
                    g_io_channel_write_chars(gio, ",", 1, NULL, NULL);
                }
                g_free(name);
            }
            g_strfreev(fields);
            g_io_channel_write_chars(gio, "\n", 1, NULL, NULL);
        }
        items = stuffkeeper_data_schema_get_items(schema);
        if(items)
        {
            GList *node = NULL;
            for(node = g_list_first(items); node; node = g_list_next(node))
            {
                StuffKeeperDataItem *item = node->data;
                gsize length = 0;
                gchar **fields =  stuffkeeper_data_schema_get_fields(schema, &length);
                int i;
                for(i=0;i<length;i++) 
                {
                    FieldType type = stuffkeeper_data_schema_get_field_type(schema,fields[i]); 
                    gchar *temp , *escaped ;
                    if(type == FIELD_TYPE_LIST)
                    {
                        gsize len;
                        gchar **items =stuffkeeper_data_item_get_list(item, fields[i], &len);
                        g_io_channel_write_chars(gio, "\"", 1, NULL, NULL);
                        if(items)
                        {
                            int j;
                            for(j=0;j<len;j++)
                            {
                                escaped = self_strescape(items[j],NULL);
                                g_io_channel_write_chars(gio, escaped, -1, NULL, NULL);
                                if(j<(len-1))
                                {
                                    g_io_channel_write_chars(gio, ",", 1, NULL, NULL);
                                }
                                g_free(escaped);
                            }
                            g_strfreev(items);
                        }
                        g_io_channel_write_chars(gio, "\"", 1, NULL, NULL);                            
                    }else{
                        temp = stuffkeeper_data_item_get_string(item, fields[i]);
                        g_io_channel_write_chars(gio, "\"", 1, NULL, NULL);
                        if(temp)
                        {
                            escaped = self_strescape(temp,NULL);
                            g_io_channel_write_chars(gio, escaped, -1, NULL, NULL);
                            g_free(temp);
                            g_free(escaped);
                        }
                        g_io_channel_write_chars(gio, "\"", 1, NULL, NULL);
                    }

                    if(i < (length-1))
                    {
                        g_io_channel_write_chars(gio, ",", 1, NULL, NULL);
                    }

                }
                g_strfreev(fields);
                g_io_channel_write_chars(gio, "\n", 1,NULL, NULL);
            }
            g_list_free(items);
        }

        g_io_channel_shutdown(gio,TRUE,NULL);
    }
}
